/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader,
  $Writer = $protobuf.Writer,
  $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const Enterprise = ($root.Enterprise = (() => {
  /**
   * Namespace Enterprise.
   * @exports Enterprise
   * @namespace
   */
  const Enterprise = {};

  /**
   * KeyType enum.
   * @name Enterprise.KeyType
   * @enum {number}
   * @property {number} RSA=0 RSA value
   * @property {number} ECC=1 ECC value
   */
  Enterprise.KeyType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "RSA")] = 0;
    values[(valuesById[1] = "ECC")] = 1;
    return values;
  })();

  /**
   * RoleUserModifyStatus enum.
   * @name Enterprise.RoleUserModifyStatus
   * @enum {number}
   * @property {number} ROLE_EXISTS=0 ROLE_EXISTS value
   * @property {number} MISSING_TREE_KEY=1 MISSING_TREE_KEY value
   * @property {number} MISSING_ROLE_KEY=2 MISSING_ROLE_KEY value
   * @property {number} INVALID_ENTERPRISE_USER_ID=3 INVALID_ENTERPRISE_USER_ID value
   * @property {number} PENDING_ENTERPRISE_USER=4 PENDING_ENTERPRISE_USER value
   * @property {number} INVALID_NODE_ID=5 INVALID_NODE_ID value
   * @property {number} MAY_NOT_REMOVE_SELF_FROM_ROLE=6 MAY_NOT_REMOVE_SELF_FROM_ROLE value
   * @property {number} MUST_HAVE_ONE_USER_ADMIN=7 MUST_HAVE_ONE_USER_ADMIN value
   */
  Enterprise.RoleUserModifyStatus = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "ROLE_EXISTS")] = 0;
    values[(valuesById[1] = "MISSING_TREE_KEY")] = 1;
    values[(valuesById[2] = "MISSING_ROLE_KEY")] = 2;
    values[(valuesById[3] = "INVALID_ENTERPRISE_USER_ID")] = 3;
    values[(valuesById[4] = "PENDING_ENTERPRISE_USER")] = 4;
    values[(valuesById[5] = "INVALID_NODE_ID")] = 5;
    values[(valuesById[6] = "MAY_NOT_REMOVE_SELF_FROM_ROLE")] = 6;
    values[(valuesById[7] = "MUST_HAVE_ONE_USER_ADMIN")] = 7;
    return values;
  })();

  /**
   * EnterpriseType enum.
   * @name Enterprise.EnterpriseType
   * @enum {number}
   * @property {number} ENTERPRISE_STANDARD=0 ENTERPRISE_STANDARD value
   * @property {number} ENTERPRISE_MSP=1 ENTERPRISE_MSP value
   */
  Enterprise.EnterpriseType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "ENTERPRISE_STANDARD")] = 0;
    values[(valuesById[1] = "ENTERPRISE_MSP")] = 1;
    return values;
  })();

  /**
   * TransferAcceptanceStatus enum.
   * @name Enterprise.TransferAcceptanceStatus
   * @enum {number}
   * @property {number} UNDEFINED=0 UNDEFINED value
   * @property {number} NOT_REQUIRED=1 NOT_REQUIRED value
   * @property {number} NOT_ACCEPTED=2 NOT_ACCEPTED value
   * @property {number} PARTIALLY_ACCEPTED=3 PARTIALLY_ACCEPTED value
   * @property {number} ACCEPTED=4 ACCEPTED value
   */
  Enterprise.TransferAcceptanceStatus = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "UNDEFINED")] = 0;
    values[(valuesById[1] = "NOT_REQUIRED")] = 1;
    values[(valuesById[2] = "NOT_ACCEPTED")] = 2;
    values[(valuesById[3] = "PARTIALLY_ACCEPTED")] = 3;
    values[(valuesById[4] = "ACCEPTED")] = 4;
    return values;
  })();

  /**
   * EnterpriseDataEntity enum.
   * @name Enterprise.EnterpriseDataEntity
   * @enum {number}
   * @property {number} UNKNOWN=0 UNKNOWN value
   * @property {number} NODES=1 NODES value
   * @property {number} ROLES=2 ROLES value
   * @property {number} USERS=3 USERS value
   * @property {number} TEAMS=4 TEAMS value
   * @property {number} TEAM_USERS=5 TEAM_USERS value
   * @property {number} ROLE_USERS=6 ROLE_USERS value
   * @property {number} ROLE_PRIVILEGES=7 ROLE_PRIVILEGES value
   * @property {number} ROLE_ENFORCEMENTS=8 ROLE_ENFORCEMENTS value
   * @property {number} ROLE_TEAMS=9 ROLE_TEAMS value
   * @property {number} LICENSES=10 LICENSES value
   * @property {number} MANAGED_NODES=11 MANAGED_NODES value
   * @property {number} MANAGED_COMPANIES=12 MANAGED_COMPANIES value
   * @property {number} BRIDGES=13 BRIDGES value
   * @property {number} SCIMS=14 SCIMS value
   * @property {number} EMAIL_PROVISION=15 EMAIL_PROVISION value
   * @property {number} QUEUED_TEAMS=16 QUEUED_TEAMS value
   * @property {number} QUEUED_TEAM_USERS=17 QUEUED_TEAM_USERS value
   * @property {number} SSO_SERVICES=18 SSO_SERVICES value
   * @property {number} REPORT_FILTER_USERS=19 REPORT_FILTER_USERS value
   * @property {number} DEVICES_REQUEST_FOR_ADMIN_APPROVAL=20 DEVICES_REQUEST_FOR_ADMIN_APPROVAL value
   * @property {number} USER_ALIASES=21 USER_ALIASES value
   * @property {number} COMPLIANCE_REPORT_CRITERIA_AND_FILTER=22 COMPLIANCE_REPORT_CRITERIA_AND_FILTER value
   * @property {number} COMPLIANCE_REPORTS=23 COMPLIANCE_REPORTS value
   * @property {number} QUEUED_TEAM_USERS_INCLUDING_PENDING=24 QUEUED_TEAM_USERS_INCLUDING_PENDING value
   */
  Enterprise.EnterpriseDataEntity = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "UNKNOWN")] = 0;
    values[(valuesById[1] = "NODES")] = 1;
    values[(valuesById[2] = "ROLES")] = 2;
    values[(valuesById[3] = "USERS")] = 3;
    values[(valuesById[4] = "TEAMS")] = 4;
    values[(valuesById[5] = "TEAM_USERS")] = 5;
    values[(valuesById[6] = "ROLE_USERS")] = 6;
    values[(valuesById[7] = "ROLE_PRIVILEGES")] = 7;
    values[(valuesById[8] = "ROLE_ENFORCEMENTS")] = 8;
    values[(valuesById[9] = "ROLE_TEAMS")] = 9;
    values[(valuesById[10] = "LICENSES")] = 10;
    values[(valuesById[11] = "MANAGED_NODES")] = 11;
    values[(valuesById[12] = "MANAGED_COMPANIES")] = 12;
    values[(valuesById[13] = "BRIDGES")] = 13;
    values[(valuesById[14] = "SCIMS")] = 14;
    values[(valuesById[15] = "EMAIL_PROVISION")] = 15;
    values[(valuesById[16] = "QUEUED_TEAMS")] = 16;
    values[(valuesById[17] = "QUEUED_TEAM_USERS")] = 17;
    values[(valuesById[18] = "SSO_SERVICES")] = 18;
    values[(valuesById[19] = "REPORT_FILTER_USERS")] = 19;
    values[(valuesById[20] = "DEVICES_REQUEST_FOR_ADMIN_APPROVAL")] = 20;
    values[(valuesById[21] = "USER_ALIASES")] = 21;
    values[(valuesById[22] = "COMPLIANCE_REPORT_CRITERIA_AND_FILTER")] = 22;
    values[(valuesById[23] = "COMPLIANCE_REPORTS")] = 23;
    values[(valuesById[24] = "QUEUED_TEAM_USERS_INCLUDING_PENDING")] = 24;
    return values;
  })();

  /**
   * CacheStatus enum.
   * @name Enterprise.CacheStatus
   * @enum {number}
   * @property {number} KEEP=0 KEEP value
   * @property {number} CLEAR=1 CLEAR value
   */
  Enterprise.CacheStatus = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "KEEP")] = 0;
    values[(valuesById[1] = "CLEAR")] = 1;
    return values;
  })();

  /**
   * BackupKeyType enum.
   * @name Enterprise.BackupKeyType
   * @enum {number}
   * @property {number} NO_KEY=0 NO_KEY value
   * @property {number} ENCRYPTED_BY_DATA_KEY=1 ENCRYPTED_BY_DATA_KEY value
   * @property {number} ENCRYPTED_BY_PUBLIC_KEY=2 ENCRYPTED_BY_PUBLIC_KEY value
   * @property {number} ENCRYPTED_BY_DATA_KEY_GCM=3 ENCRYPTED_BY_DATA_KEY_GCM value
   * @property {number} ENCRYPTED_BY_PUBLIC_KEY_ECC=4 ENCRYPTED_BY_PUBLIC_KEY_ECC value
   */
  Enterprise.BackupKeyType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "NO_KEY")] = 0;
    values[(valuesById[1] = "ENCRYPTED_BY_DATA_KEY")] = 1;
    values[(valuesById[2] = "ENCRYPTED_BY_PUBLIC_KEY")] = 2;
    values[(valuesById[3] = "ENCRYPTED_BY_DATA_KEY_GCM")] = 3;
    values[(valuesById[4] = "ENCRYPTED_BY_PUBLIC_KEY_ECC")] = 4;
    return values;
  })();

  /**
   * BackupUserDataKeyType enum.
   * @name Enterprise.BackupUserDataKeyType
   * @enum {number}
   * @property {number} OWN=0 OWN value
   * @property {number} SHARED_TO_ENTERPRISE=1 SHARED_TO_ENTERPRISE value
   */
  Enterprise.BackupUserDataKeyType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "OWN")] = 0;
    values[(valuesById[1] = "SHARED_TO_ENTERPRISE")] = 1;
    return values;
  })();

  /**
   * EncryptedKeyType enum.
   * @name Enterprise.EncryptedKeyType
   * @enum {number}
   * @property {number} KT_NO_KEY=0 KT_NO_KEY value
   * @property {number} KT_ENCRYPTED_BY_DATA_KEY=1 KT_ENCRYPTED_BY_DATA_KEY value
   * @property {number} KT_ENCRYPTED_BY_PUBLIC_KEY=2 KT_ENCRYPTED_BY_PUBLIC_KEY value
   * @property {number} KT_ENCRYPTED_BY_DATA_KEY_GCM=3 KT_ENCRYPTED_BY_DATA_KEY_GCM value
   * @property {number} KT_ENCRYPTED_BY_PUBLIC_KEY_ECC=4 KT_ENCRYPTED_BY_PUBLIC_KEY_ECC value
   */
  Enterprise.EncryptedKeyType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "KT_NO_KEY")] = 0;
    values[(valuesById[1] = "KT_ENCRYPTED_BY_DATA_KEY")] = 1;
    values[(valuesById[2] = "KT_ENCRYPTED_BY_PUBLIC_KEY")] = 2;
    values[(valuesById[3] = "KT_ENCRYPTED_BY_DATA_KEY_GCM")] = 3;
    values[(valuesById[4] = "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC")] = 4;
    return values;
  })();

  /**
   * EnterpriseFlagType enum.
   * @name Enterprise.EnterpriseFlagType
   * @enum {number}
   * @property {number} INVALID=0 INVALID value
   * @property {number} ALLOW_PERSONAL_LICENSE=1 ALLOW_PERSONAL_LICENSE value
   * @property {number} SPECIAL_PROVISIONING=2 SPECIAL_PROVISIONING value
   * @property {number} RECORD_TYPES=3 RECORD_TYPES value
   * @property {number} SECRETS_MANAGER=4 SECRETS_MANAGER value
   * @property {number} ENTERPRISE_LOCKED=5 ENTERPRISE_LOCKED value
   * @property {number} FORBID_KEY_TYPE_2=6 FORBID_KEY_TYPE_2 value
   * @property {number} CONSOLE_ONBOARDED=7 CONSOLE_ONBOARDED value
   * @property {number} FORBID_ACCOUNT_TRANSFER=8 FORBID_ACCOUNT_TRANSFER value
   * @property {number} NPS_POPUP_OPT_OUT=9 NPS_POPUP_OPT_OUT value
   * @property {number} SHOW_USER_ONBOARD=10 SHOW_USER_ONBOARD value
   */
  Enterprise.EnterpriseFlagType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "INVALID")] = 0;
    values[(valuesById[1] = "ALLOW_PERSONAL_LICENSE")] = 1;
    values[(valuesById[2] = "SPECIAL_PROVISIONING")] = 2;
    values[(valuesById[3] = "RECORD_TYPES")] = 3;
    values[(valuesById[4] = "SECRETS_MANAGER")] = 4;
    values[(valuesById[5] = "ENTERPRISE_LOCKED")] = 5;
    values[(valuesById[6] = "FORBID_KEY_TYPE_2")] = 6;
    values[(valuesById[7] = "CONSOLE_ONBOARDED")] = 7;
    values[(valuesById[8] = "FORBID_ACCOUNT_TRANSFER")] = 8;
    values[(valuesById[9] = "NPS_POPUP_OPT_OUT")] = 9;
    values[(valuesById[10] = "SHOW_USER_ONBOARD")] = 10;
    return values;
  })();

  /**
   * UserUpdateStatus enum.
   * @name Enterprise.UserUpdateStatus
   * @enum {number}
   * @property {number} USER_UPDATE_OK=0 USER_UPDATE_OK value
   * @property {number} USER_UPDATE_ACCESS_DENIED=1 USER_UPDATE_ACCESS_DENIED value
   */
  Enterprise.UserUpdateStatus = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "USER_UPDATE_OK")] = 0;
    values[(valuesById[1] = "USER_UPDATE_ACCESS_DENIED")] = 1;
    return values;
  })();

  /**
   * AuditUserStatus enum.
   * @name Enterprise.AuditUserStatus
   * @enum {number}
   * @property {number} OK=0 OK value
   * @property {number} ACCESS_DENIED=1 ACCESS_DENIED value
   * @property {number} NO_LONGER_IN_ENTERPRISE=2 NO_LONGER_IN_ENTERPRISE value
   */
  Enterprise.AuditUserStatus = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "OK")] = 0;
    values[(valuesById[1] = "ACCESS_DENIED")] = 1;
    values[(valuesById[2] = "NO_LONGER_IN_ENTERPRISE")] = 2;
    return values;
  })();

  /**
   * TeamUserType enum.
   * @name Enterprise.TeamUserType
   * @enum {number}
   * @property {number} USER=0 USER value
   * @property {number} ADMIN=1 ADMIN value
   * @property {number} ADMIN_ONLY=2 ADMIN_ONLY value
   */
  Enterprise.TeamUserType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "USER")] = 0;
    values[(valuesById[1] = "ADMIN")] = 1;
    values[(valuesById[2] = "ADMIN_ONLY")] = 2;
    return values;
  })();

  /**
   * AppClientType enum.
   * @name Enterprise.AppClientType
   * @enum {number}
   * @property {number} NOT_USED=0 NOT_USED value
   * @property {number} GENERAL=1 GENERAL value
   * @property {number} DISCOVERY_AND_ROTATION_CONTROLLER=2 DISCOVERY_AND_ROTATION_CONTROLLER value
   * @property {number} KCM_CONTROLLER=3 KCM_CONTROLLER value
   * @property {number} SELF_DESTRUCT=4 SELF_DESTRUCT value
   */
  Enterprise.AppClientType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "NOT_USED")] = 0;
    values[(valuesById[1] = "GENERAL")] = 1;
    values[(valuesById[2] = "DISCOVERY_AND_ROTATION_CONTROLLER")] = 2;
    values[(valuesById[3] = "KCM_CONTROLLER")] = 3;
    values[(valuesById[4] = "SELF_DESTRUCT")] = 4;
    return values;
  })();

  /**
   * DeleteEnterpriseUsersResult enum.
   * @name Enterprise.DeleteEnterpriseUsersResult
   * @enum {number}
   * @property {number} SUCCESS=0 SUCCESS value
   * @property {number} NOT_AN_ENTERPRISE_USER=1 NOT_AN_ENTERPRISE_USER value
   * @property {number} CANNOT_DELETE_SELF=2 CANNOT_DELETE_SELF value
   * @property {number} BRIDGE_CANNOT_DELETE_ACTIVE_USER=3 BRIDGE_CANNOT_DELETE_ACTIVE_USER value
   * @property {number} ERROR=4 ERROR value
   */
  Enterprise.DeleteEnterpriseUsersResult = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "SUCCESS")] = 0;
    values[(valuesById[1] = "NOT_AN_ENTERPRISE_USER")] = 1;
    values[(valuesById[2] = "CANNOT_DELETE_SELF")] = 2;
    values[(valuesById[3] = "BRIDGE_CANNOT_DELETE_ACTIVE_USER")] = 3;
    values[(valuesById[4] = "ERROR")] = 4;
    return values;
  })();

  /**
   * ClearSecurityDataType enum.
   * @name Enterprise.ClearSecurityDataType
   * @enum {number}
   * @property {number} RECALCULATE_SUMMARY_REPORT=0 RECALCULATE_SUMMARY_REPORT value
   * @property {number} FORCE_CLIENT_CHECK_FOR_MISSING_DATA=1 FORCE_CLIENT_CHECK_FOR_MISSING_DATA value
   * @property {number} FORCE_CLIENT_RESEND_SECURITY_DATA=2 FORCE_CLIENT_RESEND_SECURITY_DATA value
   */
  Enterprise.ClearSecurityDataType = (function () {
    const valuesById = {},
      values = Object.create(valuesById);
    values[(valuesById[0] = "RECALCULATE_SUMMARY_REPORT")] = 0;
    values[(valuesById[1] = "FORCE_CLIENT_CHECK_FOR_MISSING_DATA")] = 1;
    values[(valuesById[2] = "FORCE_CLIENT_RESEND_SECURITY_DATA")] = 2;
    return values;
  })();

  Enterprise.EnterpriseKeyPairRequest = (function () {
    /**
     * Properties of an EnterpriseKeyPairRequest.
     * @memberof Enterprise
     * @interface IEnterpriseKeyPairRequest
     * @property {Uint8Array|null} [enterprisePublicKey] EnterpriseKeyPairRequest enterprisePublicKey
     * @property {Uint8Array|null} [encryptedEnterprisePrivateKey] EnterpriseKeyPairRequest encryptedEnterprisePrivateKey
     * @property {Enterprise.KeyType|null} [keyType] EnterpriseKeyPairRequest keyType
     */

    /**
     * Constructs a new EnterpriseKeyPairRequest.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseKeyPairRequest.
     * @implements IEnterpriseKeyPairRequest
     * @constructor
     * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
     */
    function EnterpriseKeyPairRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseKeyPairRequest enterprisePublicKey.
     * @member {Uint8Array} enterprisePublicKey
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @instance
     */
    EnterpriseKeyPairRequest.prototype.enterprisePublicKey = $util.newBuffer([]);

    /**
     * EnterpriseKeyPairRequest encryptedEnterprisePrivateKey.
     * @member {Uint8Array} encryptedEnterprisePrivateKey
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @instance
     */
    EnterpriseKeyPairRequest.prototype.encryptedEnterprisePrivateKey = $util.newBuffer([]);

    /**
     * EnterpriseKeyPairRequest keyType.
     * @member {Enterprise.KeyType} keyType
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @instance
     */
    EnterpriseKeyPairRequest.prototype.keyType = 0;

    /**
     * Creates a new EnterpriseKeyPairRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest instance
     */
    EnterpriseKeyPairRequest.create = function create(properties) {
      return new EnterpriseKeyPairRequest(properties);
    };

    /**
     * Encodes the specified EnterpriseKeyPairRequest message. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseKeyPairRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterprisePublicKey != null &&
        Object.hasOwnProperty.call(message, "enterprisePublicKey")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.enterprisePublicKey);
      if (
        message.encryptedEnterprisePrivateKey != null &&
        Object.hasOwnProperty.call(message, "encryptedEnterprisePrivateKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedEnterprisePrivateKey);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.keyType);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseKeyPairRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseKeyPairRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseKeyPairRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseKeyPairRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterprisePublicKey = reader.bytes();
            break;
          }
          case 2: {
            message.encryptedEnterprisePrivateKey = reader.bytes();
            break;
          }
          case 3: {
            message.keyType = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseKeyPairRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseKeyPairRequest message.
     * @function verify
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseKeyPairRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
        if (
          !(
            (message.enterprisePublicKey &&
              typeof message.enterprisePublicKey.length === "number") ||
            $util.isString(message.enterprisePublicKey)
          )
        )
          return "enterprisePublicKey: buffer expected";
      if (
        message.encryptedEnterprisePrivateKey != null &&
        message.hasOwnProperty("encryptedEnterprisePrivateKey")
      )
        if (
          !(
            (message.encryptedEnterprisePrivateKey &&
              typeof message.encryptedEnterprisePrivateKey.length === "number") ||
            $util.isString(message.encryptedEnterprisePrivateKey)
          )
        )
          return "encryptedEnterprisePrivateKey: buffer expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
            break;
        }
      return null;
    };

    /**
     * Creates an EnterpriseKeyPairRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
     */
    EnterpriseKeyPairRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseKeyPairRequest) return object;
      let message = new $root.Enterprise.EnterpriseKeyPairRequest();
      if (object.enterprisePublicKey != null)
        if (typeof object.enterprisePublicKey === "string")
          $util.base64.decode(
            object.enterprisePublicKey,
            (message.enterprisePublicKey = $util.newBuffer(
              $util.base64.length(object.enterprisePublicKey),
            )),
            0,
          );
        else if (object.enterprisePublicKey.length >= 0)
          message.enterprisePublicKey = object.enterprisePublicKey;
      if (object.encryptedEnterprisePrivateKey != null)
        if (typeof object.encryptedEnterprisePrivateKey === "string")
          $util.base64.decode(
            object.encryptedEnterprisePrivateKey,
            (message.encryptedEnterprisePrivateKey = $util.newBuffer(
              $util.base64.length(object.encryptedEnterprisePrivateKey),
            )),
            0,
          );
        else if (object.encryptedEnterprisePrivateKey.length >= 0)
          message.encryptedEnterprisePrivateKey = object.encryptedEnterprisePrivateKey;
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "RSA":
        case 0:
          message.keyType = 0;
          break;
        case "ECC":
        case 1:
          message.keyType = 1;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseKeyPairRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {Enterprise.EnterpriseKeyPairRequest} message EnterpriseKeyPairRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseKeyPairRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.enterprisePublicKey = "";
        else {
          object.enterprisePublicKey = [];
          if (options.bytes !== Array)
            object.enterprisePublicKey = $util.newBuffer(object.enterprisePublicKey);
        }
        if (options.bytes === String) object.encryptedEnterprisePrivateKey = "";
        else {
          object.encryptedEnterprisePrivateKey = [];
          if (options.bytes !== Array)
            object.encryptedEnterprisePrivateKey = $util.newBuffer(
              object.encryptedEnterprisePrivateKey,
            );
        }
        object.keyType = options.enums === String ? "RSA" : 0;
      }
      if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
        object.enterprisePublicKey =
          options.bytes === String
            ? $util.base64.encode(
                message.enterprisePublicKey,
                0,
                message.enterprisePublicKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.enterprisePublicKey)
              : message.enterprisePublicKey;
      if (
        message.encryptedEnterprisePrivateKey != null &&
        message.hasOwnProperty("encryptedEnterprisePrivateKey")
      )
        object.encryptedEnterprisePrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedEnterprisePrivateKey,
                0,
                message.encryptedEnterprisePrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedEnterprisePrivateKey)
              : message.encryptedEnterprisePrivateKey;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.KeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.KeyType[message.keyType]
            : message.keyType;
      return object;
    };

    /**
     * Converts this EnterpriseKeyPairRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseKeyPairRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseKeyPairRequest
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseKeyPairRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseKeyPairRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseKeyPairRequest";
    };

    return EnterpriseKeyPairRequest;
  })();

  Enterprise.GetTeamMemberRequest = (function () {
    /**
     * Properties of a GetTeamMemberRequest.
     * @memberof Enterprise
     * @interface IGetTeamMemberRequest
     * @property {Uint8Array|null} [teamUid] GetTeamMemberRequest teamUid
     */

    /**
     * Constructs a new GetTeamMemberRequest.
     * @memberof Enterprise
     * @classdesc Represents a GetTeamMemberRequest.
     * @implements IGetTeamMemberRequest
     * @constructor
     * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
     */
    function GetTeamMemberRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetTeamMemberRequest teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.GetTeamMemberRequest
     * @instance
     */
    GetTeamMemberRequest.prototype.teamUid = $util.newBuffer([]);

    /**
     * Creates a new GetTeamMemberRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
     * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest instance
     */
    GetTeamMemberRequest.create = function create(properties) {
      return new GetTeamMemberRequest(properties);
    };

    /**
     * Encodes the specified GetTeamMemberRequest message. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetTeamMemberRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      return writer;
    };

    /**
     * Encodes the specified GetTeamMemberRequest message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetTeamMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetTeamMemberRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetTeamMemberRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetTeamMemberRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetTeamMemberRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetTeamMemberRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetTeamMemberRequest message.
     * @function verify
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetTeamMemberRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      return null;
    };

    /**
     * Creates a GetTeamMemberRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
     */
    GetTeamMemberRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetTeamMemberRequest) return object;
      let message = new $root.Enterprise.GetTeamMemberRequest();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      return message;
    };

    /**
     * Creates a plain object from a GetTeamMemberRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {Enterprise.GetTeamMemberRequest} message GetTeamMemberRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetTeamMemberRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      return object;
    };

    /**
     * Converts this GetTeamMemberRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.GetTeamMemberRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetTeamMemberRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetTeamMemberRequest
     * @function getTypeUrl
     * @memberof Enterprise.GetTeamMemberRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetTeamMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetTeamMemberRequest";
    };

    return GetTeamMemberRequest;
  })();

  Enterprise.EnterpriseUser = (function () {
    /**
     * Properties of an EnterpriseUser.
     * @memberof Enterprise
     * @interface IEnterpriseUser
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUser enterpriseUserId
     * @property {string|null} [email] EnterpriseUser email
     * @property {string|null} [enterpriseUsername] EnterpriseUser enterpriseUsername
     * @property {boolean|null} [isShareAdmin] EnterpriseUser isShareAdmin
     * @property {string|null} [username] EnterpriseUser username
     */

    /**
     * Constructs a new EnterpriseUser.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUser.
     * @implements IEnterpriseUser
     * @constructor
     * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
     */
    function EnterpriseUser(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUser enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUser
     * @instance
     */
    EnterpriseUser.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * EnterpriseUser email.
     * @member {string} email
     * @memberof Enterprise.EnterpriseUser
     * @instance
     */
    EnterpriseUser.prototype.email = "";

    /**
     * EnterpriseUser enterpriseUsername.
     * @member {string} enterpriseUsername
     * @memberof Enterprise.EnterpriseUser
     * @instance
     */
    EnterpriseUser.prototype.enterpriseUsername = "";

    /**
     * EnterpriseUser isShareAdmin.
     * @member {boolean} isShareAdmin
     * @memberof Enterprise.EnterpriseUser
     * @instance
     */
    EnterpriseUser.prototype.isShareAdmin = false;

    /**
     * EnterpriseUser username.
     * @member {string} username
     * @memberof Enterprise.EnterpriseUser
     * @instance
     */
    EnterpriseUser.prototype.username = "";

    /**
     * Creates a new EnterpriseUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUser} EnterpriseUser instance
     */
    EnterpriseUser.create = function create(properties) {
      return new EnterpriseUser(properties);
    };

    /**
     * Encodes the specified EnterpriseUser message. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.email);
      if (
        message.enterpriseUsername != null &&
        Object.hasOwnProperty.call(message, "enterpriseUsername")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.enterpriseUsername);
      if (message.isShareAdmin != null && Object.hasOwnProperty.call(message, "isShareAdmin"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.isShareAdmin);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.username);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUser message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUser} EnterpriseUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.email = reader.string();
            break;
          }
          case 3: {
            message.enterpriseUsername = reader.string();
            break;
          }
          case 4: {
            message.isShareAdmin = reader.bool();
            break;
          }
          case 5: {
            message.username = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUser} EnterpriseUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUser message.
     * @function verify
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
        if (!$util.isString(message.enterpriseUsername))
          return "enterpriseUsername: string expected";
      if (message.isShareAdmin != null && message.hasOwnProperty("isShareAdmin"))
        if (typeof message.isShareAdmin !== "boolean") return "isShareAdmin: boolean expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUser} EnterpriseUser
     */
    EnterpriseUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUser) return object;
      let message = new $root.Enterprise.EnterpriseUser();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.email != null) message.email = String(object.email);
      if (object.enterpriseUsername != null)
        message.enterpriseUsername = String(object.enterpriseUsername);
      if (object.isShareAdmin != null) message.isShareAdmin = Boolean(object.isShareAdmin);
      if (object.username != null) message.username = String(object.username);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {Enterprise.EnterpriseUser} message EnterpriseUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.email = "";
        object.enterpriseUsername = "";
        object.isShareAdmin = false;
        object.username = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
        object.enterpriseUsername = message.enterpriseUsername;
      if (message.isShareAdmin != null && message.hasOwnProperty("isShareAdmin"))
        object.isShareAdmin = message.isShareAdmin;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      return object;
    };

    /**
     * Converts this EnterpriseUser to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUser
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUser";
    };

    return EnterpriseUser;
  })();

  Enterprise.GetTeamMemberResponse = (function () {
    /**
     * Properties of a GetTeamMemberResponse.
     * @memberof Enterprise
     * @interface IGetTeamMemberResponse
     * @property {Array.<Enterprise.IEnterpriseUser>|null} [enterpriseUser] GetTeamMemberResponse enterpriseUser
     */

    /**
     * Constructs a new GetTeamMemberResponse.
     * @memberof Enterprise
     * @classdesc Represents a GetTeamMemberResponse.
     * @implements IGetTeamMemberResponse
     * @constructor
     * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
     */
    function GetTeamMemberResponse(properties) {
      this.enterpriseUser = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetTeamMemberResponse enterpriseUser.
     * @member {Array.<Enterprise.IEnterpriseUser>} enterpriseUser
     * @memberof Enterprise.GetTeamMemberResponse
     * @instance
     */
    GetTeamMemberResponse.prototype.enterpriseUser = $util.emptyArray;

    /**
     * Creates a new GetTeamMemberResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
     * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse instance
     */
    GetTeamMemberResponse.create = function create(properties) {
      return new GetTeamMemberResponse(properties);
    };

    /**
     * Encodes the specified GetTeamMemberResponse message. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetTeamMemberResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseUser != null && message.enterpriseUser.length)
        for (let i = 0; i < message.enterpriseUser.length; ++i)
          $root.Enterprise.EnterpriseUser.encode(
            message.enterpriseUser[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified GetTeamMemberResponse message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetTeamMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetTeamMemberResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetTeamMemberResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetTeamMemberResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.enterpriseUser && message.enterpriseUser.length))
              message.enterpriseUser = [];
            message.enterpriseUser.push(
              $root.Enterprise.EnterpriseUser.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetTeamMemberResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetTeamMemberResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetTeamMemberResponse message.
     * @function verify
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetTeamMemberResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUser != null && message.hasOwnProperty("enterpriseUser")) {
        if (!Array.isArray(message.enterpriseUser)) return "enterpriseUser: array expected";
        for (let i = 0; i < message.enterpriseUser.length; ++i) {
          let error = $root.Enterprise.EnterpriseUser.verify(message.enterpriseUser[i]);
          if (error) return "enterpriseUser." + error;
        }
      }
      return null;
    };

    /**
     * Creates a GetTeamMemberResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
     */
    GetTeamMemberResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetTeamMemberResponse) return object;
      let message = new $root.Enterprise.GetTeamMemberResponse();
      if (object.enterpriseUser) {
        if (!Array.isArray(object.enterpriseUser))
          throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: array expected");
        message.enterpriseUser = [];
        for (let i = 0; i < object.enterpriseUser.length; ++i) {
          if (typeof object.enterpriseUser[i] !== "object")
            throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: object expected");
          message.enterpriseUser[i] = $root.Enterprise.EnterpriseUser.fromObject(
            object.enterpriseUser[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a GetTeamMemberResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {Enterprise.GetTeamMemberResponse} message GetTeamMemberResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetTeamMemberResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUser = [];
      if (message.enterpriseUser && message.enterpriseUser.length) {
        object.enterpriseUser = [];
        for (let j = 0; j < message.enterpriseUser.length; ++j)
          object.enterpriseUser[j] = $root.Enterprise.EnterpriseUser.toObject(
            message.enterpriseUser[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this GetTeamMemberResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.GetTeamMemberResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetTeamMemberResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetTeamMemberResponse
     * @function getTypeUrl
     * @memberof Enterprise.GetTeamMemberResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetTeamMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetTeamMemberResponse";
    };

    return GetTeamMemberResponse;
  })();

  Enterprise.EnterpriseUserIds = (function () {
    /**
     * Properties of an EnterpriseUserIds.
     * @memberof Enterprise
     * @interface IEnterpriseUserIds
     * @property {Array.<number|Long>|null} [enterpriseUserId] EnterpriseUserIds enterpriseUserId
     */

    /**
     * Constructs a new EnterpriseUserIds.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserIds.
     * @implements IEnterpriseUserIds
     * @constructor
     * @param {Enterprise.IEnterpriseUserIds=} [properties] Properties to set
     */
    function EnterpriseUserIds(properties) {
      this.enterpriseUserId = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserIds enterpriseUserId.
     * @member {Array.<number|Long>} enterpriseUserId
     * @memberof Enterprise.EnterpriseUserIds
     * @instance
     */
    EnterpriseUserIds.prototype.enterpriseUserId = $util.emptyArray;

    /**
     * Creates a new EnterpriseUserIds instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Enterprise.IEnterpriseUserIds=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds instance
     */
    EnterpriseUserIds.create = function create(properties) {
      return new EnterpriseUserIds(properties);
    };

    /**
     * Encodes the specified EnterpriseUserIds message. Does not implicitly {@link Enterprise.EnterpriseUserIds.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Enterprise.IEnterpriseUserIds} message EnterpriseUserIds message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserIds.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseUserId != null && message.enterpriseUserId.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.enterpriseUserId.length; ++i)
          writer.int64(message.enterpriseUserId[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserIds message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserIds.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Enterprise.IEnterpriseUserIds} message EnterpriseUserIds message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserIds.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserIds message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserIds.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserIds();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.enterpriseUserId && message.enterpriseUserId.length))
              message.enterpriseUserId = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserId.push(reader.int64());
            } else message.enterpriseUserId.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserIds message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserIds.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserIds message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserIds.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId")) {
        if (!Array.isArray(message.enterpriseUserId)) return "enterpriseUserId: array expected";
        for (let i = 0; i < message.enterpriseUserId.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserId[i]) &&
            !(
              message.enterpriseUserId[i] &&
              $util.isInteger(message.enterpriseUserId[i].low) &&
              $util.isInteger(message.enterpriseUserId[i].high)
            )
          )
            return "enterpriseUserId: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates an EnterpriseUserIds message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
     */
    EnterpriseUserIds.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserIds) return object;
      let message = new $root.Enterprise.EnterpriseUserIds();
      if (object.enterpriseUserId) {
        if (!Array.isArray(object.enterpriseUserId))
          throw TypeError(".Enterprise.EnterpriseUserIds.enterpriseUserId: array expected");
        message.enterpriseUserId = [];
        for (let i = 0; i < object.enterpriseUserId.length; ++i)
          if ($util.Long)
            (message.enterpriseUserId[i] = $util.Long.fromValue(
              object.enterpriseUserId[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserId[i] === "string")
            message.enterpriseUserId[i] = parseInt(object.enterpriseUserId[i], 10);
          else if (typeof object.enterpriseUserId[i] === "number")
            message.enterpriseUserId[i] = object.enterpriseUserId[i];
          else if (typeof object.enterpriseUserId[i] === "object")
            message.enterpriseUserId[i] = new $util.LongBits(
              object.enterpriseUserId[i].low >>> 0,
              object.enterpriseUserId[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserIds message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {Enterprise.EnterpriseUserIds} message EnterpriseUserIds
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserIds.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserId = [];
      if (message.enterpriseUserId && message.enterpriseUserId.length) {
        object.enterpriseUserId = [];
        for (let j = 0; j < message.enterpriseUserId.length; ++j)
          if (typeof message.enterpriseUserId[j] === "number")
            object.enterpriseUserId[j] =
              options.longs === String
                ? String(message.enterpriseUserId[j])
                : message.enterpriseUserId[j];
          else
            object.enterpriseUserId[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserId[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserId[j].low >>> 0,
                      message.enterpriseUserId[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserId[j];
      }
      return object;
    };

    /**
     * Converts this EnterpriseUserIds to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserIds
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserIds.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserIds
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserIds
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserIds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserIds";
    };

    return EnterpriseUserIds;
  })();

  Enterprise.EnterprisePersonalAccount = (function () {
    /**
     * Properties of an EnterprisePersonalAccount.
     * @memberof Enterprise
     * @interface IEnterprisePersonalAccount
     * @property {string|null} [email] EnterprisePersonalAccount email
     * @property {Uint8Array|null} [OBSOLETE_FIELD] EnterprisePersonalAccount OBSOLETE_FIELD
     */

    /**
     * Constructs a new EnterprisePersonalAccount.
     * @memberof Enterprise
     * @classdesc Represents an EnterprisePersonalAccount.
     * @implements IEnterprisePersonalAccount
     * @constructor
     * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
     */
    function EnterprisePersonalAccount(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterprisePersonalAccount email.
     * @member {string} email
     * @memberof Enterprise.EnterprisePersonalAccount
     * @instance
     */
    EnterprisePersonalAccount.prototype.email = "";

    /**
     * EnterprisePersonalAccount OBSOLETE_FIELD.
     * @member {Uint8Array} OBSOLETE_FIELD
     * @memberof Enterprise.EnterprisePersonalAccount
     * @instance
     */
    EnterprisePersonalAccount.prototype.OBSOLETE_FIELD = $util.newBuffer([]);

    /**
     * Creates a new EnterprisePersonalAccount instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
     * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount instance
     */
    EnterprisePersonalAccount.create = function create(properties) {
      return new EnterprisePersonalAccount(properties);
    };

    /**
     * Encodes the specified EnterprisePersonalAccount message. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterprisePersonalAccount.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.email);
      if (message.OBSOLETE_FIELD != null && Object.hasOwnProperty.call(message, "OBSOLETE_FIELD"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.OBSOLETE_FIELD);
      return writer;
    };

    /**
     * Encodes the specified EnterprisePersonalAccount message, length delimited. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterprisePersonalAccount.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterprisePersonalAccount message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterprisePersonalAccount.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterprisePersonalAccount();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.email = reader.string();
            break;
          }
          case 2: {
            message.OBSOLETE_FIELD = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterprisePersonalAccount message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterprisePersonalAccount.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterprisePersonalAccount message.
     * @function verify
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterprisePersonalAccount.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
        if (
          !(
            (message.OBSOLETE_FIELD && typeof message.OBSOLETE_FIELD.length === "number") ||
            $util.isString(message.OBSOLETE_FIELD)
          )
        )
          return "OBSOLETE_FIELD: buffer expected";
      return null;
    };

    /**
     * Creates an EnterprisePersonalAccount message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
     */
    EnterprisePersonalAccount.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterprisePersonalAccount) return object;
      let message = new $root.Enterprise.EnterprisePersonalAccount();
      if (object.email != null) message.email = String(object.email);
      if (object.OBSOLETE_FIELD != null)
        if (typeof object.OBSOLETE_FIELD === "string")
          $util.base64.decode(
            object.OBSOLETE_FIELD,
            (message.OBSOLETE_FIELD = $util.newBuffer($util.base64.length(object.OBSOLETE_FIELD))),
            0,
          );
        else if (object.OBSOLETE_FIELD.length >= 0) message.OBSOLETE_FIELD = object.OBSOLETE_FIELD;
      return message;
    };

    /**
     * Creates a plain object from an EnterprisePersonalAccount message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {Enterprise.EnterprisePersonalAccount} message EnterprisePersonalAccount
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterprisePersonalAccount.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.email = "";
        if (options.bytes === String) object.OBSOLETE_FIELD = "";
        else {
          object.OBSOLETE_FIELD = [];
          if (options.bytes !== Array)
            object.OBSOLETE_FIELD = $util.newBuffer(object.OBSOLETE_FIELD);
        }
      }
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
        object.OBSOLETE_FIELD =
          options.bytes === String
            ? $util.base64.encode(message.OBSOLETE_FIELD, 0, message.OBSOLETE_FIELD.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.OBSOLETE_FIELD)
              : message.OBSOLETE_FIELD;
      return object;
    };

    /**
     * Converts this EnterprisePersonalAccount to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterprisePersonalAccount
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterprisePersonalAccount.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterprisePersonalAccount
     * @function getTypeUrl
     * @memberof Enterprise.EnterprisePersonalAccount
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterprisePersonalAccount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterprisePersonalAccount";
    };

    return EnterprisePersonalAccount;
  })();

  Enterprise.EncryptedTeamKeyRequest = (function () {
    /**
     * Properties of an EncryptedTeamKeyRequest.
     * @memberof Enterprise
     * @interface IEncryptedTeamKeyRequest
     * @property {Uint8Array|null} [teamUid] EncryptedTeamKeyRequest teamUid
     * @property {Uint8Array|null} [encryptedTeamKey] EncryptedTeamKeyRequest encryptedTeamKey
     * @property {boolean|null} [force] EncryptedTeamKeyRequest force
     */

    /**
     * Constructs a new EncryptedTeamKeyRequest.
     * @memberof Enterprise
     * @classdesc Represents an EncryptedTeamKeyRequest.
     * @implements IEncryptedTeamKeyRequest
     * @constructor
     * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
     */
    function EncryptedTeamKeyRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EncryptedTeamKeyRequest teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @instance
     */
    EncryptedTeamKeyRequest.prototype.teamUid = $util.newBuffer([]);

    /**
     * EncryptedTeamKeyRequest encryptedTeamKey.
     * @member {Uint8Array} encryptedTeamKey
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @instance
     */
    EncryptedTeamKeyRequest.prototype.encryptedTeamKey = $util.newBuffer([]);

    /**
     * EncryptedTeamKeyRequest force.
     * @member {boolean} force
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @instance
     */
    EncryptedTeamKeyRequest.prototype.force = false;

    /**
     * Creates a new EncryptedTeamKeyRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
     * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest instance
     */
    EncryptedTeamKeyRequest.create = function create(properties) {
      return new EncryptedTeamKeyRequest(properties);
    };

    /**
     * Encodes the specified EncryptedTeamKeyRequest message. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptedTeamKeyRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (
        message.encryptedTeamKey != null &&
        Object.hasOwnProperty.call(message, "encryptedTeamKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedTeamKey);
      if (message.force != null && Object.hasOwnProperty.call(message, "force"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.force);
      return writer;
    };

    /**
     * Encodes the specified EncryptedTeamKeyRequest message, length delimited. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EncryptedTeamKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptedTeamKeyRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EncryptedTeamKeyRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            message.encryptedTeamKey = reader.bytes();
            break;
          }
          case 3: {
            message.force = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EncryptedTeamKeyRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EncryptedTeamKeyRequest message.
     * @function verify
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EncryptedTeamKeyRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
        if (
          !(
            (message.encryptedTeamKey && typeof message.encryptedTeamKey.length === "number") ||
            $util.isString(message.encryptedTeamKey)
          )
        )
          return "encryptedTeamKey: buffer expected";
      if (message.force != null && message.hasOwnProperty("force"))
        if (typeof message.force !== "boolean") return "force: boolean expected";
      return null;
    };

    /**
     * Creates an EncryptedTeamKeyRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
     */
    EncryptedTeamKeyRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EncryptedTeamKeyRequest) return object;
      let message = new $root.Enterprise.EncryptedTeamKeyRequest();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.encryptedTeamKey != null)
        if (typeof object.encryptedTeamKey === "string")
          $util.base64.decode(
            object.encryptedTeamKey,
            (message.encryptedTeamKey = $util.newBuffer(
              $util.base64.length(object.encryptedTeamKey),
            )),
            0,
          );
        else if (object.encryptedTeamKey.length >= 0)
          message.encryptedTeamKey = object.encryptedTeamKey;
      if (object.force != null) message.force = Boolean(object.force);
      return message;
    };

    /**
     * Creates a plain object from an EncryptedTeamKeyRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {Enterprise.EncryptedTeamKeyRequest} message EncryptedTeamKeyRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EncryptedTeamKeyRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        if (options.bytes === String) object.encryptedTeamKey = "";
        else {
          object.encryptedTeamKey = [];
          if (options.bytes !== Array)
            object.encryptedTeamKey = $util.newBuffer(object.encryptedTeamKey);
        }
        object.force = false;
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
        object.encryptedTeamKey =
          options.bytes === String
            ? $util.base64.encode(message.encryptedTeamKey, 0, message.encryptedTeamKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedTeamKey)
              : message.encryptedTeamKey;
      if (message.force != null && message.hasOwnProperty("force")) object.force = message.force;
      return object;
    };

    /**
     * Converts this EncryptedTeamKeyRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EncryptedTeamKeyRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EncryptedTeamKeyRequest
     * @function getTypeUrl
     * @memberof Enterprise.EncryptedTeamKeyRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EncryptedTeamKeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EncryptedTeamKeyRequest";
    };

    return EncryptedTeamKeyRequest;
  })();

  Enterprise.ReEncryptedData = (function () {
    /**
     * Properties of a ReEncryptedData.
     * @memberof Enterprise
     * @interface IReEncryptedData
     * @property {number|Long|null} [id] ReEncryptedData id
     * @property {string|null} [data] ReEncryptedData data
     */

    /**
     * Constructs a new ReEncryptedData.
     * @memberof Enterprise
     * @classdesc Represents a ReEncryptedData.
     * @implements IReEncryptedData
     * @constructor
     * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
     */
    function ReEncryptedData(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReEncryptedData id.
     * @member {number|Long} id
     * @memberof Enterprise.ReEncryptedData
     * @instance
     */
    ReEncryptedData.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ReEncryptedData data.
     * @member {string} data
     * @memberof Enterprise.ReEncryptedData
     * @instance
     */
    ReEncryptedData.prototype.data = "";

    /**
     * Creates a new ReEncryptedData instance using the specified properties.
     * @function create
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
     * @returns {Enterprise.ReEncryptedData} ReEncryptedData instance
     */
    ReEncryptedData.create = function create(properties) {
      return new ReEncryptedData(properties);
    };

    /**
     * Encodes the specified ReEncryptedData message. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedData.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.id != null && Object.hasOwnProperty.call(message, "id"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id);
      if (message.data != null && Object.hasOwnProperty.call(message, "data"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.data);
      return writer;
    };

    /**
     * Encodes the specified ReEncryptedData message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedData.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReEncryptedData message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ReEncryptedData} ReEncryptedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedData.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ReEncryptedData();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.id = reader.int64();
            break;
          }
          case 2: {
            message.data = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ReEncryptedData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ReEncryptedData} ReEncryptedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedData.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReEncryptedData message.
     * @function verify
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReEncryptedData.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.id != null && message.hasOwnProperty("id"))
        if (
          !$util.isInteger(message.id) &&
          !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high))
        )
          return "id: integer|Long expected";
      if (message.data != null && message.hasOwnProperty("data"))
        if (!$util.isString(message.data)) return "data: string expected";
      return null;
    };

    /**
     * Creates a ReEncryptedData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ReEncryptedData} ReEncryptedData
     */
    ReEncryptedData.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ReEncryptedData) return object;
      let message = new $root.Enterprise.ReEncryptedData();
      if (object.id != null)
        if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = false;
        else if (typeof object.id === "string") message.id = parseInt(object.id, 10);
        else if (typeof object.id === "number") message.id = object.id;
        else if (typeof object.id === "object")
          message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
      if (object.data != null) message.data = String(object.data);
      return message;
    };

    /**
     * Creates a plain object from a ReEncryptedData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {Enterprise.ReEncryptedData} message ReEncryptedData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReEncryptedData.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.id =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.id = options.longs === String ? "0" : 0;
        object.data = "";
      }
      if (message.id != null && message.hasOwnProperty("id"))
        if (typeof message.id === "number")
          object.id = options.longs === String ? String(message.id) : message.id;
        else
          object.id =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.id)
              : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber()
                : message.id;
      if (message.data != null && message.hasOwnProperty("data")) object.data = message.data;
      return object;
    };

    /**
     * Converts this ReEncryptedData to JSON.
     * @function toJSON
     * @memberof Enterprise.ReEncryptedData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReEncryptedData.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ReEncryptedData
     * @function getTypeUrl
     * @memberof Enterprise.ReEncryptedData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ReEncryptedData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ReEncryptedData";
    };

    return ReEncryptedData;
  })();

  Enterprise.ReEncryptedRoleKey = (function () {
    /**
     * Properties of a ReEncryptedRoleKey.
     * @memberof Enterprise
     * @interface IReEncryptedRoleKey
     * @property {number|Long|null} [roleId] ReEncryptedRoleKey roleId
     * @property {Uint8Array|null} [encryptedRoleKey] ReEncryptedRoleKey encryptedRoleKey
     */

    /**
     * Constructs a new ReEncryptedRoleKey.
     * @memberof Enterprise
     * @classdesc Represents a ReEncryptedRoleKey.
     * @implements IReEncryptedRoleKey
     * @constructor
     * @param {Enterprise.IReEncryptedRoleKey=} [properties] Properties to set
     */
    function ReEncryptedRoleKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReEncryptedRoleKey roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.ReEncryptedRoleKey
     * @instance
     */
    ReEncryptedRoleKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ReEncryptedRoleKey encryptedRoleKey.
     * @member {Uint8Array} encryptedRoleKey
     * @memberof Enterprise.ReEncryptedRoleKey
     * @instance
     */
    ReEncryptedRoleKey.prototype.encryptedRoleKey = $util.newBuffer([]);

    /**
     * Creates a new ReEncryptedRoleKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Enterprise.IReEncryptedRoleKey=} [properties] Properties to set
     * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey instance
     */
    ReEncryptedRoleKey.create = function create(properties) {
      return new ReEncryptedRoleKey(properties);
    };

    /**
     * Encodes the specified ReEncryptedRoleKey message. Does not implicitly {@link Enterprise.ReEncryptedRoleKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Enterprise.IReEncryptedRoleKey} message ReEncryptedRoleKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedRoleKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (
        message.encryptedRoleKey != null &&
        Object.hasOwnProperty.call(message, "encryptedRoleKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedRoleKey);
      return writer;
    };

    /**
     * Encodes the specified ReEncryptedRoleKey message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedRoleKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Enterprise.IReEncryptedRoleKey} message ReEncryptedRoleKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedRoleKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReEncryptedRoleKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedRoleKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ReEncryptedRoleKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.encryptedRoleKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ReEncryptedRoleKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedRoleKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReEncryptedRoleKey message.
     * @function verify
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReEncryptedRoleKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.encryptedRoleKey != null && message.hasOwnProperty("encryptedRoleKey"))
        if (
          !(
            (message.encryptedRoleKey && typeof message.encryptedRoleKey.length === "number") ||
            $util.isString(message.encryptedRoleKey)
          )
        )
          return "encryptedRoleKey: buffer expected";
      return null;
    };

    /**
     * Creates a ReEncryptedRoleKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
     */
    ReEncryptedRoleKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ReEncryptedRoleKey) return object;
      let message = new $root.Enterprise.ReEncryptedRoleKey();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.encryptedRoleKey != null)
        if (typeof object.encryptedRoleKey === "string")
          $util.base64.decode(
            object.encryptedRoleKey,
            (message.encryptedRoleKey = $util.newBuffer(
              $util.base64.length(object.encryptedRoleKey),
            )),
            0,
          );
        else if (object.encryptedRoleKey.length >= 0)
          message.encryptedRoleKey = object.encryptedRoleKey;
      return message;
    };

    /**
     * Creates a plain object from a ReEncryptedRoleKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {Enterprise.ReEncryptedRoleKey} message ReEncryptedRoleKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReEncryptedRoleKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedRoleKey = "";
        else {
          object.encryptedRoleKey = [];
          if (options.bytes !== Array)
            object.encryptedRoleKey = $util.newBuffer(object.encryptedRoleKey);
        }
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.encryptedRoleKey != null && message.hasOwnProperty("encryptedRoleKey"))
        object.encryptedRoleKey =
          options.bytes === String
            ? $util.base64.encode(message.encryptedRoleKey, 0, message.encryptedRoleKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedRoleKey)
              : message.encryptedRoleKey;
      return object;
    };

    /**
     * Converts this ReEncryptedRoleKey to JSON.
     * @function toJSON
     * @memberof Enterprise.ReEncryptedRoleKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReEncryptedRoleKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ReEncryptedRoleKey
     * @function getTypeUrl
     * @memberof Enterprise.ReEncryptedRoleKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ReEncryptedRoleKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ReEncryptedRoleKey";
    };

    return ReEncryptedRoleKey;
  })();

  Enterprise.ReEncryptedUserDataKey = (function () {
    /**
     * Properties of a ReEncryptedUserDataKey.
     * @memberof Enterprise
     * @interface IReEncryptedUserDataKey
     * @property {number|Long|null} [enterpriseUserId] ReEncryptedUserDataKey enterpriseUserId
     * @property {Uint8Array|null} [userEncryptedDataKey] ReEncryptedUserDataKey userEncryptedDataKey
     */

    /**
     * Constructs a new ReEncryptedUserDataKey.
     * @memberof Enterprise
     * @classdesc Represents a ReEncryptedUserDataKey.
     * @implements IReEncryptedUserDataKey
     * @constructor
     * @param {Enterprise.IReEncryptedUserDataKey=} [properties] Properties to set
     */
    function ReEncryptedUserDataKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReEncryptedUserDataKey enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @instance
     */
    ReEncryptedUserDataKey.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ReEncryptedUserDataKey userEncryptedDataKey.
     * @member {Uint8Array} userEncryptedDataKey
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @instance
     */
    ReEncryptedUserDataKey.prototype.userEncryptedDataKey = $util.newBuffer([]);

    /**
     * Creates a new ReEncryptedUserDataKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Enterprise.IReEncryptedUserDataKey=} [properties] Properties to set
     * @returns {Enterprise.ReEncryptedUserDataKey} ReEncryptedUserDataKey instance
     */
    ReEncryptedUserDataKey.create = function create(properties) {
      return new ReEncryptedUserDataKey(properties);
    };

    /**
     * Encodes the specified ReEncryptedUserDataKey message. Does not implicitly {@link Enterprise.ReEncryptedUserDataKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Enterprise.IReEncryptedUserDataKey} message ReEncryptedUserDataKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedUserDataKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (
        message.userEncryptedDataKey != null &&
        Object.hasOwnProperty.call(message, "userEncryptedDataKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.userEncryptedDataKey);
      return writer;
    };

    /**
     * Encodes the specified ReEncryptedUserDataKey message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedUserDataKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Enterprise.IReEncryptedUserDataKey} message ReEncryptedUserDataKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReEncryptedUserDataKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReEncryptedUserDataKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ReEncryptedUserDataKey} ReEncryptedUserDataKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedUserDataKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ReEncryptedUserDataKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.userEncryptedDataKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ReEncryptedUserDataKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ReEncryptedUserDataKey} ReEncryptedUserDataKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReEncryptedUserDataKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReEncryptedUserDataKey message.
     * @function verify
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReEncryptedUserDataKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        if (
          !(
            (message.userEncryptedDataKey &&
              typeof message.userEncryptedDataKey.length === "number") ||
            $util.isString(message.userEncryptedDataKey)
          )
        )
          return "userEncryptedDataKey: buffer expected";
      return null;
    };

    /**
     * Creates a ReEncryptedUserDataKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ReEncryptedUserDataKey} ReEncryptedUserDataKey
     */
    ReEncryptedUserDataKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ReEncryptedUserDataKey) return object;
      let message = new $root.Enterprise.ReEncryptedUserDataKey();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.userEncryptedDataKey != null)
        if (typeof object.userEncryptedDataKey === "string")
          $util.base64.decode(
            object.userEncryptedDataKey,
            (message.userEncryptedDataKey = $util.newBuffer(
              $util.base64.length(object.userEncryptedDataKey),
            )),
            0,
          );
        else if (object.userEncryptedDataKey.length >= 0)
          message.userEncryptedDataKey = object.userEncryptedDataKey;
      return message;
    };

    /**
     * Creates a plain object from a ReEncryptedUserDataKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {Enterprise.ReEncryptedUserDataKey} message ReEncryptedUserDataKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReEncryptedUserDataKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.userEncryptedDataKey = "";
        else {
          object.userEncryptedDataKey = [];
          if (options.bytes !== Array)
            object.userEncryptedDataKey = $util.newBuffer(object.userEncryptedDataKey);
        }
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        object.userEncryptedDataKey =
          options.bytes === String
            ? $util.base64.encode(
                message.userEncryptedDataKey,
                0,
                message.userEncryptedDataKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.userEncryptedDataKey)
              : message.userEncryptedDataKey;
      return object;
    };

    /**
     * Converts this ReEncryptedUserDataKey to JSON.
     * @function toJSON
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReEncryptedUserDataKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ReEncryptedUserDataKey
     * @function getTypeUrl
     * @memberof Enterprise.ReEncryptedUserDataKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ReEncryptedUserDataKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ReEncryptedUserDataKey";
    };

    return ReEncryptedUserDataKey;
  })();

  Enterprise.NodeToManagedCompanyRequest = (function () {
    /**
     * Properties of a NodeToManagedCompanyRequest.
     * @memberof Enterprise
     * @interface INodeToManagedCompanyRequest
     * @property {number|null} [companyId] NodeToManagedCompanyRequest companyId
     * @property {Array.<Enterprise.IReEncryptedData>|null} [nodes] NodeToManagedCompanyRequest nodes
     * @property {Array.<Enterprise.IReEncryptedData>|null} [roles] NodeToManagedCompanyRequest roles
     * @property {Array.<Enterprise.IReEncryptedData>|null} [users] NodeToManagedCompanyRequest users
     * @property {Array.<Enterprise.IReEncryptedRoleKey>|null} [roleKeys] NodeToManagedCompanyRequest roleKeys
     * @property {Array.<Enterprise.IEncryptedTeamKeyRequest>|null} [teamKeys] NodeToManagedCompanyRequest teamKeys
     * @property {Array.<Enterprise.IReEncryptedUserDataKey>|null} [usersDataKeys] NodeToManagedCompanyRequest usersDataKeys
     */

    /**
     * Constructs a new NodeToManagedCompanyRequest.
     * @memberof Enterprise
     * @classdesc Represents a NodeToManagedCompanyRequest.
     * @implements INodeToManagedCompanyRequest
     * @constructor
     * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
     */
    function NodeToManagedCompanyRequest(properties) {
      this.nodes = [];
      this.roles = [];
      this.users = [];
      this.roleKeys = [];
      this.teamKeys = [];
      this.usersDataKeys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * NodeToManagedCompanyRequest companyId.
     * @member {number} companyId
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.companyId = 0;

    /**
     * NodeToManagedCompanyRequest nodes.
     * @member {Array.<Enterprise.IReEncryptedData>} nodes
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.nodes = $util.emptyArray;

    /**
     * NodeToManagedCompanyRequest roles.
     * @member {Array.<Enterprise.IReEncryptedData>} roles
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.roles = $util.emptyArray;

    /**
     * NodeToManagedCompanyRequest users.
     * @member {Array.<Enterprise.IReEncryptedData>} users
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.users = $util.emptyArray;

    /**
     * NodeToManagedCompanyRequest roleKeys.
     * @member {Array.<Enterprise.IReEncryptedRoleKey>} roleKeys
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.roleKeys = $util.emptyArray;

    /**
     * NodeToManagedCompanyRequest teamKeys.
     * @member {Array.<Enterprise.IEncryptedTeamKeyRequest>} teamKeys
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.teamKeys = $util.emptyArray;

    /**
     * NodeToManagedCompanyRequest usersDataKeys.
     * @member {Array.<Enterprise.IReEncryptedUserDataKey>} usersDataKeys
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     */
    NodeToManagedCompanyRequest.prototype.usersDataKeys = $util.emptyArray;

    /**
     * Creates a new NodeToManagedCompanyRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
     * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest instance
     */
    NodeToManagedCompanyRequest.create = function create(properties) {
      return new NodeToManagedCompanyRequest(properties);
    };

    /**
     * Encodes the specified NodeToManagedCompanyRequest message. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NodeToManagedCompanyRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.companyId != null && Object.hasOwnProperty.call(message, "companyId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.companyId);
      if (message.nodes != null && message.nodes.length)
        for (let i = 0; i < message.nodes.length; ++i)
          $root.Enterprise.ReEncryptedData.encode(
            message.nodes[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.roles != null && message.roles.length)
        for (let i = 0; i < message.roles.length; ++i)
          $root.Enterprise.ReEncryptedData.encode(
            message.roles[i],
            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
          ).ldelim();
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.ReEncryptedData.encode(
            message.users[i],
            writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
          ).ldelim();
      if (message.roleKeys != null && message.roleKeys.length)
        for (let i = 0; i < message.roleKeys.length; ++i)
          $root.Enterprise.ReEncryptedRoleKey.encode(
            message.roleKeys[i],
            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
          ).ldelim();
      if (message.teamKeys != null && message.teamKeys.length)
        for (let i = 0; i < message.teamKeys.length; ++i)
          $root.Enterprise.EncryptedTeamKeyRequest.encode(
            message.teamKeys[i],
            writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
          ).ldelim();
      if (message.usersDataKeys != null && message.usersDataKeys.length)
        for (let i = 0; i < message.usersDataKeys.length; ++i)
          $root.Enterprise.ReEncryptedUserDataKey.encode(
            message.usersDataKeys[i],
            writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified NodeToManagedCompanyRequest message, length delimited. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NodeToManagedCompanyRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NodeToManagedCompanyRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.NodeToManagedCompanyRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.companyId = reader.int32();
            break;
          }
          case 2: {
            if (!(message.nodes && message.nodes.length)) message.nodes = [];
            message.nodes.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
            break;
          }
          case 3: {
            if (!(message.roles && message.roles.length)) message.roles = [];
            message.roles.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
            break;
          }
          case 4: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
            break;
          }
          case 5: {
            if (!(message.roleKeys && message.roleKeys.length)) message.roleKeys = [];
            message.roleKeys.push(
              $root.Enterprise.ReEncryptedRoleKey.decode(reader, reader.uint32()),
            );
            break;
          }
          case 6: {
            if (!(message.teamKeys && message.teamKeys.length)) message.teamKeys = [];
            message.teamKeys.push(
              $root.Enterprise.EncryptedTeamKeyRequest.decode(reader, reader.uint32()),
            );
            break;
          }
          case 7: {
            if (!(message.usersDataKeys && message.usersDataKeys.length))
              message.usersDataKeys = [];
            message.usersDataKeys.push(
              $root.Enterprise.ReEncryptedUserDataKey.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NodeToManagedCompanyRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NodeToManagedCompanyRequest message.
     * @function verify
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NodeToManagedCompanyRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.companyId != null && message.hasOwnProperty("companyId"))
        if (!$util.isInteger(message.companyId)) return "companyId: integer expected";
      if (message.nodes != null && message.hasOwnProperty("nodes")) {
        if (!Array.isArray(message.nodes)) return "nodes: array expected";
        for (let i = 0; i < message.nodes.length; ++i) {
          let error = $root.Enterprise.ReEncryptedData.verify(message.nodes[i]);
          if (error) return "nodes." + error;
        }
      }
      if (message.roles != null && message.hasOwnProperty("roles")) {
        if (!Array.isArray(message.roles)) return "roles: array expected";
        for (let i = 0; i < message.roles.length; ++i) {
          let error = $root.Enterprise.ReEncryptedData.verify(message.roles[i]);
          if (error) return "roles." + error;
        }
      }
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.ReEncryptedData.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      if (message.roleKeys != null && message.hasOwnProperty("roleKeys")) {
        if (!Array.isArray(message.roleKeys)) return "roleKeys: array expected";
        for (let i = 0; i < message.roleKeys.length; ++i) {
          let error = $root.Enterprise.ReEncryptedRoleKey.verify(message.roleKeys[i]);
          if (error) return "roleKeys." + error;
        }
      }
      if (message.teamKeys != null && message.hasOwnProperty("teamKeys")) {
        if (!Array.isArray(message.teamKeys)) return "teamKeys: array expected";
        for (let i = 0; i < message.teamKeys.length; ++i) {
          let error = $root.Enterprise.EncryptedTeamKeyRequest.verify(message.teamKeys[i]);
          if (error) return "teamKeys." + error;
        }
      }
      if (message.usersDataKeys != null && message.hasOwnProperty("usersDataKeys")) {
        if (!Array.isArray(message.usersDataKeys)) return "usersDataKeys: array expected";
        for (let i = 0; i < message.usersDataKeys.length; ++i) {
          let error = $root.Enterprise.ReEncryptedUserDataKey.verify(message.usersDataKeys[i]);
          if (error) return "usersDataKeys." + error;
        }
      }
      return null;
    };

    /**
     * Creates a NodeToManagedCompanyRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
     */
    NodeToManagedCompanyRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.NodeToManagedCompanyRequest) return object;
      let message = new $root.Enterprise.NodeToManagedCompanyRequest();
      if (object.companyId != null) message.companyId = object.companyId | 0;
      if (object.nodes) {
        if (!Array.isArray(object.nodes))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: array expected");
        message.nodes = [];
        for (let i = 0; i < object.nodes.length; ++i) {
          if (typeof object.nodes[i] !== "object")
            throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: object expected");
          message.nodes[i] = $root.Enterprise.ReEncryptedData.fromObject(object.nodes[i]);
        }
      }
      if (object.roles) {
        if (!Array.isArray(object.roles))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: array expected");
        message.roles = [];
        for (let i = 0; i < object.roles.length; ++i) {
          if (typeof object.roles[i] !== "object")
            throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: object expected");
          message.roles[i] = $root.Enterprise.ReEncryptedData.fromObject(object.roles[i]);
        }
      }
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: object expected");
          message.users[i] = $root.Enterprise.ReEncryptedData.fromObject(object.users[i]);
        }
      }
      if (object.roleKeys) {
        if (!Array.isArray(object.roleKeys))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roleKeys: array expected");
        message.roleKeys = [];
        for (let i = 0; i < object.roleKeys.length; ++i) {
          if (typeof object.roleKeys[i] !== "object")
            throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roleKeys: object expected");
          message.roleKeys[i] = $root.Enterprise.ReEncryptedRoleKey.fromObject(object.roleKeys[i]);
        }
      }
      if (object.teamKeys) {
        if (!Array.isArray(object.teamKeys))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.teamKeys: array expected");
        message.teamKeys = [];
        for (let i = 0; i < object.teamKeys.length; ++i) {
          if (typeof object.teamKeys[i] !== "object")
            throw TypeError(".Enterprise.NodeToManagedCompanyRequest.teamKeys: object expected");
          message.teamKeys[i] = $root.Enterprise.EncryptedTeamKeyRequest.fromObject(
            object.teamKeys[i],
          );
        }
      }
      if (object.usersDataKeys) {
        if (!Array.isArray(object.usersDataKeys))
          throw TypeError(".Enterprise.NodeToManagedCompanyRequest.usersDataKeys: array expected");
        message.usersDataKeys = [];
        for (let i = 0; i < object.usersDataKeys.length; ++i) {
          if (typeof object.usersDataKeys[i] !== "object")
            throw TypeError(
              ".Enterprise.NodeToManagedCompanyRequest.usersDataKeys: object expected",
            );
          message.usersDataKeys[i] = $root.Enterprise.ReEncryptedUserDataKey.fromObject(
            object.usersDataKeys[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a NodeToManagedCompanyRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {Enterprise.NodeToManagedCompanyRequest} message NodeToManagedCompanyRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NodeToManagedCompanyRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.nodes = [];
        object.roles = [];
        object.users = [];
        object.roleKeys = [];
        object.teamKeys = [];
        object.usersDataKeys = [];
      }
      if (options.defaults) object.companyId = 0;
      if (message.companyId != null && message.hasOwnProperty("companyId"))
        object.companyId = message.companyId;
      if (message.nodes && message.nodes.length) {
        object.nodes = [];
        for (let j = 0; j < message.nodes.length; ++j)
          object.nodes[j] = $root.Enterprise.ReEncryptedData.toObject(message.nodes[j], options);
      }
      if (message.roles && message.roles.length) {
        object.roles = [];
        for (let j = 0; j < message.roles.length; ++j)
          object.roles[j] = $root.Enterprise.ReEncryptedData.toObject(message.roles[j], options);
      }
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.ReEncryptedData.toObject(message.users[j], options);
      }
      if (message.roleKeys && message.roleKeys.length) {
        object.roleKeys = [];
        for (let j = 0; j < message.roleKeys.length; ++j)
          object.roleKeys[j] = $root.Enterprise.ReEncryptedRoleKey.toObject(
            message.roleKeys[j],
            options,
          );
      }
      if (message.teamKeys && message.teamKeys.length) {
        object.teamKeys = [];
        for (let j = 0; j < message.teamKeys.length; ++j)
          object.teamKeys[j] = $root.Enterprise.EncryptedTeamKeyRequest.toObject(
            message.teamKeys[j],
            options,
          );
      }
      if (message.usersDataKeys && message.usersDataKeys.length) {
        object.usersDataKeys = [];
        for (let j = 0; j < message.usersDataKeys.length; ++j)
          object.usersDataKeys[j] = $root.Enterprise.ReEncryptedUserDataKey.toObject(
            message.usersDataKeys[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this NodeToManagedCompanyRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NodeToManagedCompanyRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for NodeToManagedCompanyRequest
     * @function getTypeUrl
     * @memberof Enterprise.NodeToManagedCompanyRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    NodeToManagedCompanyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.NodeToManagedCompanyRequest";
    };

    return NodeToManagedCompanyRequest;
  })();

  Enterprise.RoleTeam = (function () {
    /**
     * Properties of a RoleTeam.
     * @memberof Enterprise
     * @interface IRoleTeam
     * @property {number|Long|null} [roleId] RoleTeam roleId
     * @property {Uint8Array|null} [teamUid] RoleTeam teamUid
     */

    /**
     * Constructs a new RoleTeam.
     * @memberof Enterprise
     * @classdesc Represents a RoleTeam.
     * @implements IRoleTeam
     * @constructor
     * @param {Enterprise.IRoleTeam=} [properties] Properties to set
     */
    function RoleTeam(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleTeam roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleTeam
     * @instance
     */
    RoleTeam.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleTeam teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.RoleTeam
     * @instance
     */
    RoleTeam.prototype.teamUid = $util.newBuffer([]);

    /**
     * Creates a new RoleTeam instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Enterprise.IRoleTeam=} [properties] Properties to set
     * @returns {Enterprise.RoleTeam} RoleTeam instance
     */
    RoleTeam.create = function create(properties) {
      return new RoleTeam(properties);
    };

    /**
     * Encodes the specified RoleTeam message. Does not implicitly {@link Enterprise.RoleTeam.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Enterprise.IRoleTeam} message RoleTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleTeam.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.teamUid);
      return writer;
    };

    /**
     * Encodes the specified RoleTeam message, length delimited. Does not implicitly {@link Enterprise.RoleTeam.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Enterprise.IRoleTeam} message RoleTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleTeam.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleTeam message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleTeam} RoleTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleTeam.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleTeam();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.teamUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleTeam message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleTeam} RoleTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleTeam.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleTeam message.
     * @function verify
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleTeam.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      return null;
    };

    /**
     * Creates a RoleTeam message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleTeam} RoleTeam
     */
    RoleTeam.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleTeam) return object;
      let message = new $root.Enterprise.RoleTeam();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      return message;
    };

    /**
     * Creates a plain object from a RoleTeam message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {Enterprise.RoleTeam} message RoleTeam
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleTeam.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      return object;
    };

    /**
     * Converts this RoleTeam to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleTeam
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleTeam.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleTeam
     * @function getTypeUrl
     * @memberof Enterprise.RoleTeam
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleTeam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleTeam";
    };

    return RoleTeam;
  })();

  Enterprise.RoleTeams = (function () {
    /**
     * Properties of a RoleTeams.
     * @memberof Enterprise
     * @interface IRoleTeams
     * @property {Array.<Enterprise.IRoleTeam>|null} [roleTeam] RoleTeams roleTeam
     */

    /**
     * Constructs a new RoleTeams.
     * @memberof Enterprise
     * @classdesc Represents a RoleTeams.
     * @implements IRoleTeams
     * @constructor
     * @param {Enterprise.IRoleTeams=} [properties] Properties to set
     */
    function RoleTeams(properties) {
      this.roleTeam = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleTeams roleTeam.
     * @member {Array.<Enterprise.IRoleTeam>} roleTeam
     * @memberof Enterprise.RoleTeams
     * @instance
     */
    RoleTeams.prototype.roleTeam = $util.emptyArray;

    /**
     * Creates a new RoleTeams instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Enterprise.IRoleTeams=} [properties] Properties to set
     * @returns {Enterprise.RoleTeams} RoleTeams instance
     */
    RoleTeams.create = function create(properties) {
      return new RoleTeams(properties);
    };

    /**
     * Encodes the specified RoleTeams message. Does not implicitly {@link Enterprise.RoleTeams.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Enterprise.IRoleTeams} message RoleTeams message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleTeams.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleTeam != null && message.roleTeam.length)
        for (let i = 0; i < message.roleTeam.length; ++i)
          $root.Enterprise.RoleTeam.encode(
            message.roleTeam[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleTeams message, length delimited. Does not implicitly {@link Enterprise.RoleTeams.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Enterprise.IRoleTeams} message RoleTeams message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleTeams.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleTeams message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleTeams} RoleTeams
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleTeams.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleTeams();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.roleTeam && message.roleTeam.length)) message.roleTeam = [];
            message.roleTeam.push($root.Enterprise.RoleTeam.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleTeams message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleTeams} RoleTeams
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleTeams.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleTeams message.
     * @function verify
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleTeams.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleTeam != null && message.hasOwnProperty("roleTeam")) {
        if (!Array.isArray(message.roleTeam)) return "roleTeam: array expected";
        for (let i = 0; i < message.roleTeam.length; ++i) {
          let error = $root.Enterprise.RoleTeam.verify(message.roleTeam[i]);
          if (error) return "roleTeam." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleTeams message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleTeams} RoleTeams
     */
    RoleTeams.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleTeams) return object;
      let message = new $root.Enterprise.RoleTeams();
      if (object.roleTeam) {
        if (!Array.isArray(object.roleTeam))
          throw TypeError(".Enterprise.RoleTeams.roleTeam: array expected");
        message.roleTeam = [];
        for (let i = 0; i < object.roleTeam.length; ++i) {
          if (typeof object.roleTeam[i] !== "object")
            throw TypeError(".Enterprise.RoleTeams.roleTeam: object expected");
          message.roleTeam[i] = $root.Enterprise.RoleTeam.fromObject(object.roleTeam[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleTeams message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {Enterprise.RoleTeams} message RoleTeams
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleTeams.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleTeam = [];
      if (message.roleTeam && message.roleTeam.length) {
        object.roleTeam = [];
        for (let j = 0; j < message.roleTeam.length; ++j)
          object.roleTeam[j] = $root.Enterprise.RoleTeam.toObject(message.roleTeam[j], options);
      }
      return object;
    };

    /**
     * Converts this RoleTeams to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleTeams
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleTeams.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleTeams
     * @function getTypeUrl
     * @memberof Enterprise.RoleTeams
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleTeams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleTeams";
    };

    return RoleTeams;
  })();

  Enterprise.RoleUserAddKeys = (function () {
    /**
     * Properties of a RoleUserAddKeys.
     * @memberof Enterprise
     * @interface IRoleUserAddKeys
     * @property {number|Long|null} [enterpriseUserId] RoleUserAddKeys enterpriseUserId
     * @property {string|null} [treeKey] RoleUserAddKeys treeKey
     * @property {string|null} [roleAdminKey] RoleUserAddKeys roleAdminKey
     */

    /**
     * Constructs a new RoleUserAddKeys.
     * @memberof Enterprise
     * @classdesc Represents a RoleUserAddKeys.
     * @implements IRoleUserAddKeys
     * @constructor
     * @param {Enterprise.IRoleUserAddKeys=} [properties] Properties to set
     */
    function RoleUserAddKeys(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUserAddKeys enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.RoleUserAddKeys
     * @instance
     */
    RoleUserAddKeys.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUserAddKeys treeKey.
     * @member {string} treeKey
     * @memberof Enterprise.RoleUserAddKeys
     * @instance
     */
    RoleUserAddKeys.prototype.treeKey = "";

    /**
     * RoleUserAddKeys roleAdminKey.
     * @member {string} roleAdminKey
     * @memberof Enterprise.RoleUserAddKeys
     * @instance
     */
    RoleUserAddKeys.prototype.roleAdminKey = "";

    /**
     * Creates a new RoleUserAddKeys instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Enterprise.IRoleUserAddKeys=} [properties] Properties to set
     * @returns {Enterprise.RoleUserAddKeys} RoleUserAddKeys instance
     */
    RoleUserAddKeys.create = function create(properties) {
      return new RoleUserAddKeys(properties);
    };

    /**
     * Encodes the specified RoleUserAddKeys message. Does not implicitly {@link Enterprise.RoleUserAddKeys.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Enterprise.IRoleUserAddKeys} message RoleUserAddKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAddKeys.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.treeKey != null && Object.hasOwnProperty.call(message, "treeKey"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.treeKey);
      if (message.roleAdminKey != null && Object.hasOwnProperty.call(message, "roleAdminKey"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.roleAdminKey);
      return writer;
    };

    /**
     * Encodes the specified RoleUserAddKeys message, length delimited. Does not implicitly {@link Enterprise.RoleUserAddKeys.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Enterprise.IRoleUserAddKeys} message RoleUserAddKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAddKeys.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUserAddKeys message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUserAddKeys} RoleUserAddKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAddKeys.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUserAddKeys();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.treeKey = reader.string();
            break;
          }
          case 3: {
            message.roleAdminKey = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUserAddKeys message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUserAddKeys} RoleUserAddKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAddKeys.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUserAddKeys message.
     * @function verify
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUserAddKeys.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        if (!$util.isString(message.treeKey)) return "treeKey: string expected";
      if (message.roleAdminKey != null && message.hasOwnProperty("roleAdminKey"))
        if (!$util.isString(message.roleAdminKey)) return "roleAdminKey: string expected";
      return null;
    };

    /**
     * Creates a RoleUserAddKeys message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUserAddKeys} RoleUserAddKeys
     */
    RoleUserAddKeys.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUserAddKeys) return object;
      let message = new $root.Enterprise.RoleUserAddKeys();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.treeKey != null) message.treeKey = String(object.treeKey);
      if (object.roleAdminKey != null) message.roleAdminKey = String(object.roleAdminKey);
      return message;
    };

    /**
     * Creates a plain object from a RoleUserAddKeys message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {Enterprise.RoleUserAddKeys} message RoleUserAddKeys
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUserAddKeys.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.treeKey = "";
        object.roleAdminKey = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        object.treeKey = message.treeKey;
      if (message.roleAdminKey != null && message.hasOwnProperty("roleAdminKey"))
        object.roleAdminKey = message.roleAdminKey;
      return object;
    };

    /**
     * Converts this RoleUserAddKeys to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUserAddKeys
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUserAddKeys.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUserAddKeys
     * @function getTypeUrl
     * @memberof Enterprise.RoleUserAddKeys
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUserAddKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUserAddKeys";
    };

    return RoleUserAddKeys;
  })();

  Enterprise.RoleUserAdd = (function () {
    /**
     * Properties of a RoleUserAdd.
     * @memberof Enterprise
     * @interface IRoleUserAdd
     * @property {number|Long|null} [roleId] RoleUserAdd roleId
     * @property {Array.<Enterprise.IRoleUserAddKeys>|null} [roleUserAddKeys] RoleUserAdd roleUserAddKeys
     */

    /**
     * Constructs a new RoleUserAdd.
     * @memberof Enterprise
     * @classdesc Represents a RoleUserAdd.
     * @implements IRoleUserAdd
     * @constructor
     * @param {Enterprise.IRoleUserAdd=} [properties] Properties to set
     */
    function RoleUserAdd(properties) {
      this.roleUserAddKeys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUserAdd roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleUserAdd
     * @instance
     */
    RoleUserAdd.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUserAdd roleUserAddKeys.
     * @member {Array.<Enterprise.IRoleUserAddKeys>} roleUserAddKeys
     * @memberof Enterprise.RoleUserAdd
     * @instance
     */
    RoleUserAdd.prototype.roleUserAddKeys = $util.emptyArray;

    /**
     * Creates a new RoleUserAdd instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Enterprise.IRoleUserAdd=} [properties] Properties to set
     * @returns {Enterprise.RoleUserAdd} RoleUserAdd instance
     */
    RoleUserAdd.create = function create(properties) {
      return new RoleUserAdd(properties);
    };

    /**
     * Encodes the specified RoleUserAdd message. Does not implicitly {@link Enterprise.RoleUserAdd.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Enterprise.IRoleUserAdd} message RoleUserAdd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAdd.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.roleUserAddKeys != null && message.roleUserAddKeys.length)
        for (let i = 0; i < message.roleUserAddKeys.length; ++i)
          $root.Enterprise.RoleUserAddKeys.encode(
            message.roleUserAddKeys[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleUserAdd message, length delimited. Does not implicitly {@link Enterprise.RoleUserAdd.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Enterprise.IRoleUserAdd} message RoleUserAdd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAdd.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUserAdd message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUserAdd} RoleUserAdd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAdd.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUserAdd();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.roleUserAddKeys && message.roleUserAddKeys.length))
              message.roleUserAddKeys = [];
            message.roleUserAddKeys.push(
              $root.Enterprise.RoleUserAddKeys.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUserAdd message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUserAdd} RoleUserAdd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAdd.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUserAdd message.
     * @function verify
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUserAdd.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.roleUserAddKeys != null && message.hasOwnProperty("roleUserAddKeys")) {
        if (!Array.isArray(message.roleUserAddKeys)) return "roleUserAddKeys: array expected";
        for (let i = 0; i < message.roleUserAddKeys.length; ++i) {
          let error = $root.Enterprise.RoleUserAddKeys.verify(message.roleUserAddKeys[i]);
          if (error) return "roleUserAddKeys." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleUserAdd message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUserAdd} RoleUserAdd
     */
    RoleUserAdd.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUserAdd) return object;
      let message = new $root.Enterprise.RoleUserAdd();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.roleUserAddKeys) {
        if (!Array.isArray(object.roleUserAddKeys))
          throw TypeError(".Enterprise.RoleUserAdd.roleUserAddKeys: array expected");
        message.roleUserAddKeys = [];
        for (let i = 0; i < object.roleUserAddKeys.length; ++i) {
          if (typeof object.roleUserAddKeys[i] !== "object")
            throw TypeError(".Enterprise.RoleUserAdd.roleUserAddKeys: object expected");
          message.roleUserAddKeys[i] = $root.Enterprise.RoleUserAddKeys.fromObject(
            object.roleUserAddKeys[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUserAdd message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {Enterprise.RoleUserAdd} message RoleUserAdd
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUserAdd.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleUserAddKeys = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.roleUserAddKeys && message.roleUserAddKeys.length) {
        object.roleUserAddKeys = [];
        for (let j = 0; j < message.roleUserAddKeys.length; ++j)
          object.roleUserAddKeys[j] = $root.Enterprise.RoleUserAddKeys.toObject(
            message.roleUserAddKeys[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this RoleUserAdd to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUserAdd
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUserAdd.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUserAdd
     * @function getTypeUrl
     * @memberof Enterprise.RoleUserAdd
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUserAdd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUserAdd";
    };

    return RoleUserAdd;
  })();

  Enterprise.RoleUsersAddRequest = (function () {
    /**
     * Properties of a RoleUsersAddRequest.
     * @memberof Enterprise
     * @interface IRoleUsersAddRequest
     * @property {Array.<Enterprise.IRoleUserAdd>|null} [roleUserAdds] RoleUsersAddRequest roleUserAdds
     */

    /**
     * Constructs a new RoleUsersAddRequest.
     * @memberof Enterprise
     * @classdesc Represents a RoleUsersAddRequest.
     * @implements IRoleUsersAddRequest
     * @constructor
     * @param {Enterprise.IRoleUsersAddRequest=} [properties] Properties to set
     */
    function RoleUsersAddRequest(properties) {
      this.roleUserAdds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUsersAddRequest roleUserAdds.
     * @member {Array.<Enterprise.IRoleUserAdd>} roleUserAdds
     * @memberof Enterprise.RoleUsersAddRequest
     * @instance
     */
    RoleUsersAddRequest.prototype.roleUserAdds = $util.emptyArray;

    /**
     * Creates a new RoleUsersAddRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Enterprise.IRoleUsersAddRequest=} [properties] Properties to set
     * @returns {Enterprise.RoleUsersAddRequest} RoleUsersAddRequest instance
     */
    RoleUsersAddRequest.create = function create(properties) {
      return new RoleUsersAddRequest(properties);
    };

    /**
     * Encodes the specified RoleUsersAddRequest message. Does not implicitly {@link Enterprise.RoleUsersAddRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Enterprise.IRoleUsersAddRequest} message RoleUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersAddRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleUserAdds != null && message.roleUserAdds.length)
        for (let i = 0; i < message.roleUserAdds.length; ++i)
          $root.Enterprise.RoleUserAdd.encode(
            message.roleUserAdds[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleUsersAddRequest message, length delimited. Does not implicitly {@link Enterprise.RoleUsersAddRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Enterprise.IRoleUsersAddRequest} message RoleUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUsersAddRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUsersAddRequest} RoleUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersAddRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUsersAddRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.roleUserAdds && message.roleUserAdds.length)) message.roleUserAdds = [];
            message.roleUserAdds.push($root.Enterprise.RoleUserAdd.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUsersAddRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUsersAddRequest} RoleUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersAddRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUsersAddRequest message.
     * @function verify
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUsersAddRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleUserAdds != null && message.hasOwnProperty("roleUserAdds")) {
        if (!Array.isArray(message.roleUserAdds)) return "roleUserAdds: array expected";
        for (let i = 0; i < message.roleUserAdds.length; ++i) {
          let error = $root.Enterprise.RoleUserAdd.verify(message.roleUserAdds[i]);
          if (error) return "roleUserAdds." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleUsersAddRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUsersAddRequest} RoleUsersAddRequest
     */
    RoleUsersAddRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUsersAddRequest) return object;
      let message = new $root.Enterprise.RoleUsersAddRequest();
      if (object.roleUserAdds) {
        if (!Array.isArray(object.roleUserAdds))
          throw TypeError(".Enterprise.RoleUsersAddRequest.roleUserAdds: array expected");
        message.roleUserAdds = [];
        for (let i = 0; i < object.roleUserAdds.length; ++i) {
          if (typeof object.roleUserAdds[i] !== "object")
            throw TypeError(".Enterprise.RoleUsersAddRequest.roleUserAdds: object expected");
          message.roleUserAdds[i] = $root.Enterprise.RoleUserAdd.fromObject(object.roleUserAdds[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUsersAddRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {Enterprise.RoleUsersAddRequest} message RoleUsersAddRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUsersAddRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleUserAdds = [];
      if (message.roleUserAdds && message.roleUserAdds.length) {
        object.roleUserAdds = [];
        for (let j = 0; j < message.roleUserAdds.length; ++j)
          object.roleUserAdds[j] = $root.Enterprise.RoleUserAdd.toObject(
            message.roleUserAdds[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this RoleUsersAddRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUsersAddRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUsersAddRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUsersAddRequest
     * @function getTypeUrl
     * @memberof Enterprise.RoleUsersAddRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUsersAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUsersAddRequest";
    };

    return RoleUsersAddRequest;
  })();

  Enterprise.RoleUserAddResult = (function () {
    /**
     * Properties of a RoleUserAddResult.
     * @memberof Enterprise
     * @interface IRoleUserAddResult
     * @property {number|Long|null} [roleId] RoleUserAddResult roleId
     * @property {number|Long|null} [enterpriseUserId] RoleUserAddResult enterpriseUserId
     * @property {Enterprise.RoleUserModifyStatus|null} [status] RoleUserAddResult status
     * @property {string|null} [message] RoleUserAddResult message
     */

    /**
     * Constructs a new RoleUserAddResult.
     * @memberof Enterprise
     * @classdesc Represents a RoleUserAddResult.
     * @implements IRoleUserAddResult
     * @constructor
     * @param {Enterprise.IRoleUserAddResult=} [properties] Properties to set
     */
    function RoleUserAddResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUserAddResult roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleUserAddResult
     * @instance
     */
    RoleUserAddResult.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUserAddResult enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.RoleUserAddResult
     * @instance
     */
    RoleUserAddResult.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * RoleUserAddResult status.
     * @member {Enterprise.RoleUserModifyStatus} status
     * @memberof Enterprise.RoleUserAddResult
     * @instance
     */
    RoleUserAddResult.prototype.status = 0;

    /**
     * RoleUserAddResult message.
     * @member {string} message
     * @memberof Enterprise.RoleUserAddResult
     * @instance
     */
    RoleUserAddResult.prototype.message = "";

    /**
     * Creates a new RoleUserAddResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Enterprise.IRoleUserAddResult=} [properties] Properties to set
     * @returns {Enterprise.RoleUserAddResult} RoleUserAddResult instance
     */
    RoleUserAddResult.create = function create(properties) {
      return new RoleUserAddResult(properties);
    };

    /**
     * Encodes the specified RoleUserAddResult message. Does not implicitly {@link Enterprise.RoleUserAddResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Enterprise.IRoleUserAddResult} message RoleUserAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAddResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.status);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      return writer;
    };

    /**
     * Encodes the specified RoleUserAddResult message, length delimited. Does not implicitly {@link Enterprise.RoleUserAddResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Enterprise.IRoleUserAddResult} message RoleUserAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserAddResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUserAddResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUserAddResult} RoleUserAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAddResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUserAddResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 3: {
            message.status = reader.int32();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUserAddResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUserAddResult} RoleUserAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserAddResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUserAddResult message.
     * @function verify
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUserAddResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.status != null && message.hasOwnProperty("status"))
        switch (message.status) {
          default:
            return "status: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      return null;
    };

    /**
     * Creates a RoleUserAddResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUserAddResult} RoleUserAddResult
     */
    RoleUserAddResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUserAddResult) return object;
      let message = new $root.Enterprise.RoleUserAddResult();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      switch (object.status) {
        default:
          if (typeof object.status === "number") {
            message.status = object.status;
            break;
          }
          break;
        case "ROLE_EXISTS":
        case 0:
          message.status = 0;
          break;
        case "MISSING_TREE_KEY":
        case 1:
          message.status = 1;
          break;
        case "MISSING_ROLE_KEY":
        case 2:
          message.status = 2;
          break;
        case "INVALID_ENTERPRISE_USER_ID":
        case 3:
          message.status = 3;
          break;
        case "PENDING_ENTERPRISE_USER":
        case 4:
          message.status = 4;
          break;
        case "INVALID_NODE_ID":
        case 5:
          message.status = 5;
          break;
        case "MAY_NOT_REMOVE_SELF_FROM_ROLE":
        case 6:
          message.status = 6;
          break;
        case "MUST_HAVE_ONE_USER_ADMIN":
        case 7:
          message.status = 7;
          break;
      }
      if (object.message != null) message.message = String(object.message);
      return message;
    };

    /**
     * Creates a plain object from a RoleUserAddResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {Enterprise.RoleUserAddResult} message RoleUserAddResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUserAddResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.status = options.enums === String ? "ROLE_EXISTS" : 0;
        object.message = "";
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status =
          options.enums === String
            ? $root.Enterprise.RoleUserModifyStatus[message.status] === undefined
              ? message.status
              : $root.Enterprise.RoleUserModifyStatus[message.status]
            : message.status;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      return object;
    };

    /**
     * Converts this RoleUserAddResult to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUserAddResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUserAddResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUserAddResult
     * @function getTypeUrl
     * @memberof Enterprise.RoleUserAddResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUserAddResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUserAddResult";
    };

    return RoleUserAddResult;
  })();

  Enterprise.RoleUsersAddResponse = (function () {
    /**
     * Properties of a RoleUsersAddResponse.
     * @memberof Enterprise
     * @interface IRoleUsersAddResponse
     * @property {Array.<Enterprise.IRoleUserAddResult>|null} [results] RoleUsersAddResponse results
     */

    /**
     * Constructs a new RoleUsersAddResponse.
     * @memberof Enterprise
     * @classdesc Represents a RoleUsersAddResponse.
     * @implements IRoleUsersAddResponse
     * @constructor
     * @param {Enterprise.IRoleUsersAddResponse=} [properties] Properties to set
     */
    function RoleUsersAddResponse(properties) {
      this.results = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUsersAddResponse results.
     * @member {Array.<Enterprise.IRoleUserAddResult>} results
     * @memberof Enterprise.RoleUsersAddResponse
     * @instance
     */
    RoleUsersAddResponse.prototype.results = $util.emptyArray;

    /**
     * Creates a new RoleUsersAddResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Enterprise.IRoleUsersAddResponse=} [properties] Properties to set
     * @returns {Enterprise.RoleUsersAddResponse} RoleUsersAddResponse instance
     */
    RoleUsersAddResponse.create = function create(properties) {
      return new RoleUsersAddResponse(properties);
    };

    /**
     * Encodes the specified RoleUsersAddResponse message. Does not implicitly {@link Enterprise.RoleUsersAddResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Enterprise.IRoleUsersAddResponse} message RoleUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersAddResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.results != null && message.results.length)
        for (let i = 0; i < message.results.length; ++i)
          $root.Enterprise.RoleUserAddResult.encode(
            message.results[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleUsersAddResponse message, length delimited. Does not implicitly {@link Enterprise.RoleUsersAddResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Enterprise.IRoleUsersAddResponse} message RoleUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUsersAddResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUsersAddResponse} RoleUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersAddResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUsersAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.results && message.results.length)) message.results = [];
            message.results.push(
              $root.Enterprise.RoleUserAddResult.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUsersAddResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUsersAddResponse} RoleUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersAddResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUsersAddResponse message.
     * @function verify
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUsersAddResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.results != null && message.hasOwnProperty("results")) {
        if (!Array.isArray(message.results)) return "results: array expected";
        for (let i = 0; i < message.results.length; ++i) {
          let error = $root.Enterprise.RoleUserAddResult.verify(message.results[i]);
          if (error) return "results." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleUsersAddResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUsersAddResponse} RoleUsersAddResponse
     */
    RoleUsersAddResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUsersAddResponse) return object;
      let message = new $root.Enterprise.RoleUsersAddResponse();
      if (object.results) {
        if (!Array.isArray(object.results))
          throw TypeError(".Enterprise.RoleUsersAddResponse.results: array expected");
        message.results = [];
        for (let i = 0; i < object.results.length; ++i) {
          if (typeof object.results[i] !== "object")
            throw TypeError(".Enterprise.RoleUsersAddResponse.results: object expected");
          message.results[i] = $root.Enterprise.RoleUserAddResult.fromObject(object.results[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUsersAddResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {Enterprise.RoleUsersAddResponse} message RoleUsersAddResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUsersAddResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.results = [];
      if (message.results && message.results.length) {
        object.results = [];
        for (let j = 0; j < message.results.length; ++j)
          object.results[j] = $root.Enterprise.RoleUserAddResult.toObject(
            message.results[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this RoleUsersAddResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUsersAddResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUsersAddResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUsersAddResponse
     * @function getTypeUrl
     * @memberof Enterprise.RoleUsersAddResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUsersAddResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUsersAddResponse";
    };

    return RoleUsersAddResponse;
  })();

  Enterprise.RoleUserRemove = (function () {
    /**
     * Properties of a RoleUserRemove.
     * @memberof Enterprise
     * @interface IRoleUserRemove
     * @property {number|Long|null} [roleId] RoleUserRemove roleId
     * @property {Array.<number|Long>|null} [enterpriseUserIds] RoleUserRemove enterpriseUserIds
     */

    /**
     * Constructs a new RoleUserRemove.
     * @memberof Enterprise
     * @classdesc Represents a RoleUserRemove.
     * @implements IRoleUserRemove
     * @constructor
     * @param {Enterprise.IRoleUserRemove=} [properties] Properties to set
     */
    function RoleUserRemove(properties) {
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUserRemove roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleUserRemove
     * @instance
     */
    RoleUserRemove.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUserRemove enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.RoleUserRemove
     * @instance
     */
    RoleUserRemove.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * Creates a new RoleUserRemove instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Enterprise.IRoleUserRemove=} [properties] Properties to set
     * @returns {Enterprise.RoleUserRemove} RoleUserRemove instance
     */
    RoleUserRemove.create = function create(properties) {
      return new RoleUserRemove(properties);
    };

    /**
     * Encodes the specified RoleUserRemove message. Does not implicitly {@link Enterprise.RoleUserRemove.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Enterprise.IRoleUserRemove} message RoleUserRemove message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserRemove.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified RoleUserRemove message, length delimited. Does not implicitly {@link Enterprise.RoleUserRemove.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Enterprise.IRoleUserRemove} message RoleUserRemove message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserRemove.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUserRemove message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUserRemove} RoleUserRemove
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserRemove.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUserRemove();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUserRemove message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUserRemove} RoleUserRemove
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserRemove.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUserRemove message.
     * @function verify
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUserRemove.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a RoleUserRemove message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUserRemove} RoleUserRemove
     */
    RoleUserRemove.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUserRemove) return object;
      let message = new $root.Enterprise.RoleUserRemove();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(".Enterprise.RoleUserRemove.enterpriseUserIds: array expected");
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUserRemove message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {Enterprise.RoleUserRemove} message RoleUserRemove
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUserRemove.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserIds = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      return object;
    };

    /**
     * Converts this RoleUserRemove to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUserRemove
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUserRemove.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUserRemove
     * @function getTypeUrl
     * @memberof Enterprise.RoleUserRemove
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUserRemove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUserRemove";
    };

    return RoleUserRemove;
  })();

  Enterprise.RoleUsersRemoveRequest = (function () {
    /**
     * Properties of a RoleUsersRemoveRequest.
     * @memberof Enterprise
     * @interface IRoleUsersRemoveRequest
     * @property {Array.<Enterprise.IRoleUserRemove>|null} [roleUserRemoves] RoleUsersRemoveRequest roleUserRemoves
     */

    /**
     * Constructs a new RoleUsersRemoveRequest.
     * @memberof Enterprise
     * @classdesc Represents a RoleUsersRemoveRequest.
     * @implements IRoleUsersRemoveRequest
     * @constructor
     * @param {Enterprise.IRoleUsersRemoveRequest=} [properties] Properties to set
     */
    function RoleUsersRemoveRequest(properties) {
      this.roleUserRemoves = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUsersRemoveRequest roleUserRemoves.
     * @member {Array.<Enterprise.IRoleUserRemove>} roleUserRemoves
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @instance
     */
    RoleUsersRemoveRequest.prototype.roleUserRemoves = $util.emptyArray;

    /**
     * Creates a new RoleUsersRemoveRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Enterprise.IRoleUsersRemoveRequest=} [properties] Properties to set
     * @returns {Enterprise.RoleUsersRemoveRequest} RoleUsersRemoveRequest instance
     */
    RoleUsersRemoveRequest.create = function create(properties) {
      return new RoleUsersRemoveRequest(properties);
    };

    /**
     * Encodes the specified RoleUsersRemoveRequest message. Does not implicitly {@link Enterprise.RoleUsersRemoveRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Enterprise.IRoleUsersRemoveRequest} message RoleUsersRemoveRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersRemoveRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleUserRemoves != null && message.roleUserRemoves.length)
        for (let i = 0; i < message.roleUserRemoves.length; ++i)
          $root.Enterprise.RoleUserRemove.encode(
            message.roleUserRemoves[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleUsersRemoveRequest message, length delimited. Does not implicitly {@link Enterprise.RoleUsersRemoveRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Enterprise.IRoleUsersRemoveRequest} message RoleUsersRemoveRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersRemoveRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUsersRemoveRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUsersRemoveRequest} RoleUsersRemoveRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersRemoveRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUsersRemoveRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.roleUserRemoves && message.roleUserRemoves.length))
              message.roleUserRemoves = [];
            message.roleUserRemoves.push(
              $root.Enterprise.RoleUserRemove.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUsersRemoveRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUsersRemoveRequest} RoleUsersRemoveRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersRemoveRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUsersRemoveRequest message.
     * @function verify
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUsersRemoveRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleUserRemoves != null && message.hasOwnProperty("roleUserRemoves")) {
        if (!Array.isArray(message.roleUserRemoves)) return "roleUserRemoves: array expected";
        for (let i = 0; i < message.roleUserRemoves.length; ++i) {
          let error = $root.Enterprise.RoleUserRemove.verify(message.roleUserRemoves[i]);
          if (error) return "roleUserRemoves." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleUsersRemoveRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUsersRemoveRequest} RoleUsersRemoveRequest
     */
    RoleUsersRemoveRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUsersRemoveRequest) return object;
      let message = new $root.Enterprise.RoleUsersRemoveRequest();
      if (object.roleUserRemoves) {
        if (!Array.isArray(object.roleUserRemoves))
          throw TypeError(".Enterprise.RoleUsersRemoveRequest.roleUserRemoves: array expected");
        message.roleUserRemoves = [];
        for (let i = 0; i < object.roleUserRemoves.length; ++i) {
          if (typeof object.roleUserRemoves[i] !== "object")
            throw TypeError(".Enterprise.RoleUsersRemoveRequest.roleUserRemoves: object expected");
          message.roleUserRemoves[i] = $root.Enterprise.RoleUserRemove.fromObject(
            object.roleUserRemoves[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUsersRemoveRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {Enterprise.RoleUsersRemoveRequest} message RoleUsersRemoveRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUsersRemoveRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleUserRemoves = [];
      if (message.roleUserRemoves && message.roleUserRemoves.length) {
        object.roleUserRemoves = [];
        for (let j = 0; j < message.roleUserRemoves.length; ++j)
          object.roleUserRemoves[j] = $root.Enterprise.RoleUserRemove.toObject(
            message.roleUserRemoves[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this RoleUsersRemoveRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUsersRemoveRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUsersRemoveRequest
     * @function getTypeUrl
     * @memberof Enterprise.RoleUsersRemoveRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUsersRemoveRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUsersRemoveRequest";
    };

    return RoleUsersRemoveRequest;
  })();

  Enterprise.RoleUserRemoveResult = (function () {
    /**
     * Properties of a RoleUserRemoveResult.
     * @memberof Enterprise
     * @interface IRoleUserRemoveResult
     * @property {number|Long|null} [roleId] RoleUserRemoveResult roleId
     * @property {number|Long|null} [enterpriseUserId] RoleUserRemoveResult enterpriseUserId
     * @property {Enterprise.RoleUserModifyStatus|null} [status] RoleUserRemoveResult status
     * @property {string|null} [message] RoleUserRemoveResult message
     */

    /**
     * Constructs a new RoleUserRemoveResult.
     * @memberof Enterprise
     * @classdesc Represents a RoleUserRemoveResult.
     * @implements IRoleUserRemoveResult
     * @constructor
     * @param {Enterprise.IRoleUserRemoveResult=} [properties] Properties to set
     */
    function RoleUserRemoveResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUserRemoveResult roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleUserRemoveResult
     * @instance
     */
    RoleUserRemoveResult.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUserRemoveResult enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.RoleUserRemoveResult
     * @instance
     */
    RoleUserRemoveResult.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * RoleUserRemoveResult status.
     * @member {Enterprise.RoleUserModifyStatus} status
     * @memberof Enterprise.RoleUserRemoveResult
     * @instance
     */
    RoleUserRemoveResult.prototype.status = 0;

    /**
     * RoleUserRemoveResult message.
     * @member {string} message
     * @memberof Enterprise.RoleUserRemoveResult
     * @instance
     */
    RoleUserRemoveResult.prototype.message = "";

    /**
     * Creates a new RoleUserRemoveResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Enterprise.IRoleUserRemoveResult=} [properties] Properties to set
     * @returns {Enterprise.RoleUserRemoveResult} RoleUserRemoveResult instance
     */
    RoleUserRemoveResult.create = function create(properties) {
      return new RoleUserRemoveResult(properties);
    };

    /**
     * Encodes the specified RoleUserRemoveResult message. Does not implicitly {@link Enterprise.RoleUserRemoveResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Enterprise.IRoleUserRemoveResult} message RoleUserRemoveResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserRemoveResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.status);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      return writer;
    };

    /**
     * Encodes the specified RoleUserRemoveResult message, length delimited. Does not implicitly {@link Enterprise.RoleUserRemoveResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Enterprise.IRoleUserRemoveResult} message RoleUserRemoveResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUserRemoveResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUserRemoveResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUserRemoveResult} RoleUserRemoveResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserRemoveResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUserRemoveResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 3: {
            message.status = reader.int32();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUserRemoveResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUserRemoveResult} RoleUserRemoveResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUserRemoveResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUserRemoveResult message.
     * @function verify
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUserRemoveResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.status != null && message.hasOwnProperty("status"))
        switch (message.status) {
          default:
            return "status: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            break;
        }
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      return null;
    };

    /**
     * Creates a RoleUserRemoveResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUserRemoveResult} RoleUserRemoveResult
     */
    RoleUserRemoveResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUserRemoveResult) return object;
      let message = new $root.Enterprise.RoleUserRemoveResult();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      switch (object.status) {
        default:
          if (typeof object.status === "number") {
            message.status = object.status;
            break;
          }
          break;
        case "ROLE_EXISTS":
        case 0:
          message.status = 0;
          break;
        case "MISSING_TREE_KEY":
        case 1:
          message.status = 1;
          break;
        case "MISSING_ROLE_KEY":
        case 2:
          message.status = 2;
          break;
        case "INVALID_ENTERPRISE_USER_ID":
        case 3:
          message.status = 3;
          break;
        case "PENDING_ENTERPRISE_USER":
        case 4:
          message.status = 4;
          break;
        case "INVALID_NODE_ID":
        case 5:
          message.status = 5;
          break;
        case "MAY_NOT_REMOVE_SELF_FROM_ROLE":
        case 6:
          message.status = 6;
          break;
        case "MUST_HAVE_ONE_USER_ADMIN":
        case 7:
          message.status = 7;
          break;
      }
      if (object.message != null) message.message = String(object.message);
      return message;
    };

    /**
     * Creates a plain object from a RoleUserRemoveResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {Enterprise.RoleUserRemoveResult} message RoleUserRemoveResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUserRemoveResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.status = options.enums === String ? "ROLE_EXISTS" : 0;
        object.message = "";
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status =
          options.enums === String
            ? $root.Enterprise.RoleUserModifyStatus[message.status] === undefined
              ? message.status
              : $root.Enterprise.RoleUserModifyStatus[message.status]
            : message.status;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      return object;
    };

    /**
     * Converts this RoleUserRemoveResult to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUserRemoveResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUserRemoveResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUserRemoveResult
     * @function getTypeUrl
     * @memberof Enterprise.RoleUserRemoveResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUserRemoveResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUserRemoveResult";
    };

    return RoleUserRemoveResult;
  })();

  Enterprise.RoleUsersRemoveResponse = (function () {
    /**
     * Properties of a RoleUsersRemoveResponse.
     * @memberof Enterprise
     * @interface IRoleUsersRemoveResponse
     * @property {Array.<Enterprise.IRoleUserRemoveResult>|null} [results] RoleUsersRemoveResponse results
     */

    /**
     * Constructs a new RoleUsersRemoveResponse.
     * @memberof Enterprise
     * @classdesc Represents a RoleUsersRemoveResponse.
     * @implements IRoleUsersRemoveResponse
     * @constructor
     * @param {Enterprise.IRoleUsersRemoveResponse=} [properties] Properties to set
     */
    function RoleUsersRemoveResponse(properties) {
      this.results = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUsersRemoveResponse results.
     * @member {Array.<Enterprise.IRoleUserRemoveResult>} results
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @instance
     */
    RoleUsersRemoveResponse.prototype.results = $util.emptyArray;

    /**
     * Creates a new RoleUsersRemoveResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Enterprise.IRoleUsersRemoveResponse=} [properties] Properties to set
     * @returns {Enterprise.RoleUsersRemoveResponse} RoleUsersRemoveResponse instance
     */
    RoleUsersRemoveResponse.create = function create(properties) {
      return new RoleUsersRemoveResponse(properties);
    };

    /**
     * Encodes the specified RoleUsersRemoveResponse message. Does not implicitly {@link Enterprise.RoleUsersRemoveResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Enterprise.IRoleUsersRemoveResponse} message RoleUsersRemoveResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersRemoveResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.results != null && message.results.length)
        for (let i = 0; i < message.results.length; ++i)
          $root.Enterprise.RoleUserRemoveResult.encode(
            message.results[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified RoleUsersRemoveResponse message, length delimited. Does not implicitly {@link Enterprise.RoleUsersRemoveResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Enterprise.IRoleUsersRemoveResponse} message RoleUsersRemoveResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUsersRemoveResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUsersRemoveResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUsersRemoveResponse} RoleUsersRemoveResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersRemoveResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUsersRemoveResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.results && message.results.length)) message.results = [];
            message.results.push(
              $root.Enterprise.RoleUserRemoveResult.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUsersRemoveResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUsersRemoveResponse} RoleUsersRemoveResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUsersRemoveResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUsersRemoveResponse message.
     * @function verify
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUsersRemoveResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.results != null && message.hasOwnProperty("results")) {
        if (!Array.isArray(message.results)) return "results: array expected";
        for (let i = 0; i < message.results.length; ++i) {
          let error = $root.Enterprise.RoleUserRemoveResult.verify(message.results[i]);
          if (error) return "results." + error;
        }
      }
      return null;
    };

    /**
     * Creates a RoleUsersRemoveResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUsersRemoveResponse} RoleUsersRemoveResponse
     */
    RoleUsersRemoveResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUsersRemoveResponse) return object;
      let message = new $root.Enterprise.RoleUsersRemoveResponse();
      if (object.results) {
        if (!Array.isArray(object.results))
          throw TypeError(".Enterprise.RoleUsersRemoveResponse.results: array expected");
        message.results = [];
        for (let i = 0; i < object.results.length; ++i) {
          if (typeof object.results[i] !== "object")
            throw TypeError(".Enterprise.RoleUsersRemoveResponse.results: object expected");
          message.results[i] = $root.Enterprise.RoleUserRemoveResult.fromObject(object.results[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleUsersRemoveResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {Enterprise.RoleUsersRemoveResponse} message RoleUsersRemoveResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUsersRemoveResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.results = [];
      if (message.results && message.results.length) {
        object.results = [];
        for (let j = 0; j < message.results.length; ++j)
          object.results[j] = $root.Enterprise.RoleUserRemoveResult.toObject(
            message.results[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this RoleUsersRemoveResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUsersRemoveResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUsersRemoveResponse
     * @function getTypeUrl
     * @memberof Enterprise.RoleUsersRemoveResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUsersRemoveResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUsersRemoveResponse";
    };

    return RoleUsersRemoveResponse;
  })();

  Enterprise.EnterpriseRegistration = (function () {
    /**
     * Properties of an EnterpriseRegistration.
     * @memberof Enterprise
     * @interface IEnterpriseRegistration
     * @property {Uint8Array|null} [encryptedTreeKey] EnterpriseRegistration encryptedTreeKey
     * @property {string|null} [enterpriseName] EnterpriseRegistration enterpriseName
     * @property {Uint8Array|null} [rootNodeData] EnterpriseRegistration rootNodeData
     * @property {Uint8Array|null} [adminUserData] EnterpriseRegistration adminUserData
     * @property {string|null} [adminName] EnterpriseRegistration adminName
     * @property {Uint8Array|null} [roleData] EnterpriseRegistration roleData
     * @property {Enterprise.IEnterpriseKeyPairRequest|null} [rsaKeyPair] EnterpriseRegistration rsaKeyPair
     * @property {number|null} [numberSeats] EnterpriseRegistration numberSeats
     * @property {Enterprise.EnterpriseType|null} [enterpriseType] EnterpriseRegistration enterpriseType
     * @property {Uint8Array|null} [rolePublicKey] EnterpriseRegistration rolePublicKey
     * @property {Uint8Array|null} [rolePrivateKeyEncryptedWithRoleKey] EnterpriseRegistration rolePrivateKeyEncryptedWithRoleKey
     * @property {Uint8Array|null} [roleKeyEncryptedWithTreeKey] EnterpriseRegistration roleKeyEncryptedWithTreeKey
     * @property {Enterprise.IEnterpriseKeyPairRequest|null} [eccKeyPair] EnterpriseRegistration eccKeyPair
     * @property {Uint8Array|null} [allUsersRoleData] EnterpriseRegistration allUsersRoleData
     * @property {Uint8Array|null} [roleKeyEncryptedWithUserPublicKey] EnterpriseRegistration roleKeyEncryptedWithUserPublicKey
     * @property {Uint8Array|null} [approverRoleData] EnterpriseRegistration approverRoleData
     */

    /**
     * Constructs a new EnterpriseRegistration.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseRegistration.
     * @implements IEnterpriseRegistration
     * @constructor
     * @param {Enterprise.IEnterpriseRegistration=} [properties] Properties to set
     */
    function EnterpriseRegistration(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseRegistration encryptedTreeKey.
     * @member {Uint8Array} encryptedTreeKey
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.encryptedTreeKey = $util.newBuffer([]);

    /**
     * EnterpriseRegistration enterpriseName.
     * @member {string} enterpriseName
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.enterpriseName = "";

    /**
     * EnterpriseRegistration rootNodeData.
     * @member {Uint8Array} rootNodeData
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.rootNodeData = $util.newBuffer([]);

    /**
     * EnterpriseRegistration adminUserData.
     * @member {Uint8Array} adminUserData
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.adminUserData = $util.newBuffer([]);

    /**
     * EnterpriseRegistration adminName.
     * @member {string} adminName
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.adminName = "";

    /**
     * EnterpriseRegistration roleData.
     * @member {Uint8Array} roleData
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.roleData = $util.newBuffer([]);

    /**
     * EnterpriseRegistration rsaKeyPair.
     * @member {Enterprise.IEnterpriseKeyPairRequest|null|undefined} rsaKeyPair
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.rsaKeyPair = null;

    /**
     * EnterpriseRegistration numberSeats.
     * @member {number} numberSeats
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.numberSeats = 0;

    /**
     * EnterpriseRegistration enterpriseType.
     * @member {Enterprise.EnterpriseType} enterpriseType
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.enterpriseType = 0;

    /**
     * EnterpriseRegistration rolePublicKey.
     * @member {Uint8Array} rolePublicKey
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.rolePublicKey = $util.newBuffer([]);

    /**
     * EnterpriseRegistration rolePrivateKeyEncryptedWithRoleKey.
     * @member {Uint8Array} rolePrivateKeyEncryptedWithRoleKey
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer([]);

    /**
     * EnterpriseRegistration roleKeyEncryptedWithTreeKey.
     * @member {Uint8Array} roleKeyEncryptedWithTreeKey
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.roleKeyEncryptedWithTreeKey = $util.newBuffer([]);

    /**
     * EnterpriseRegistration eccKeyPair.
     * @member {Enterprise.IEnterpriseKeyPairRequest|null|undefined} eccKeyPair
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.eccKeyPair = null;

    /**
     * EnterpriseRegistration allUsersRoleData.
     * @member {Uint8Array} allUsersRoleData
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.allUsersRoleData = $util.newBuffer([]);

    /**
     * EnterpriseRegistration roleKeyEncryptedWithUserPublicKey.
     * @member {Uint8Array} roleKeyEncryptedWithUserPublicKey
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.roleKeyEncryptedWithUserPublicKey = $util.newBuffer([]);

    /**
     * EnterpriseRegistration approverRoleData.
     * @member {Uint8Array} approverRoleData
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     */
    EnterpriseRegistration.prototype.approverRoleData = $util.newBuffer([]);

    /**
     * Creates a new EnterpriseRegistration instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Enterprise.IEnterpriseRegistration=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration instance
     */
    EnterpriseRegistration.create = function create(properties) {
      return new EnterpriseRegistration(properties);
    };

    /**
     * Encodes the specified EnterpriseRegistration message. Does not implicitly {@link Enterprise.EnterpriseRegistration.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Enterprise.IEnterpriseRegistration} message EnterpriseRegistration message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseRegistration.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.encryptedTreeKey != null &&
        Object.hasOwnProperty.call(message, "encryptedTreeKey")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.encryptedTreeKey);
      if (message.enterpriseName != null && Object.hasOwnProperty.call(message, "enterpriseName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.enterpriseName);
      if (message.rootNodeData != null && Object.hasOwnProperty.call(message, "rootNodeData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.rootNodeData);
      if (message.adminUserData != null && Object.hasOwnProperty.call(message, "adminUserData"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.adminUserData);
      if (message.adminName != null && Object.hasOwnProperty.call(message, "adminName"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.adminName);
      if (message.roleData != null && Object.hasOwnProperty.call(message, "roleData"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.roleData);
      if (message.rsaKeyPair != null && Object.hasOwnProperty.call(message, "rsaKeyPair"))
        $root.Enterprise.EnterpriseKeyPairRequest.encode(
          message.rsaKeyPair,
          writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
        ).ldelim();
      if (message.numberSeats != null && Object.hasOwnProperty.call(message, "numberSeats"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.numberSeats);
      if (message.enterpriseType != null && Object.hasOwnProperty.call(message, "enterpriseType"))
        writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.enterpriseType);
      if (message.rolePublicKey != null && Object.hasOwnProperty.call(message, "rolePublicKey"))
        writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.rolePublicKey);
      if (
        message.rolePrivateKeyEncryptedWithRoleKey != null &&
        Object.hasOwnProperty.call(message, "rolePrivateKeyEncryptedWithRoleKey")
      )
        writer
          .uint32(/* id 11, wireType 2 =*/ 90)
          .bytes(message.rolePrivateKeyEncryptedWithRoleKey);
      if (
        message.roleKeyEncryptedWithTreeKey != null &&
        Object.hasOwnProperty.call(message, "roleKeyEncryptedWithTreeKey")
      )
        writer.uint32(/* id 12, wireType 2 =*/ 98).bytes(message.roleKeyEncryptedWithTreeKey);
      if (message.eccKeyPair != null && Object.hasOwnProperty.call(message, "eccKeyPair"))
        $root.Enterprise.EnterpriseKeyPairRequest.encode(
          message.eccKeyPair,
          writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),
        ).ldelim();
      if (
        message.allUsersRoleData != null &&
        Object.hasOwnProperty.call(message, "allUsersRoleData")
      )
        writer.uint32(/* id 14, wireType 2 =*/ 114).bytes(message.allUsersRoleData);
      if (
        message.roleKeyEncryptedWithUserPublicKey != null &&
        Object.hasOwnProperty.call(message, "roleKeyEncryptedWithUserPublicKey")
      )
        writer
          .uint32(/* id 15, wireType 2 =*/ 122)
          .bytes(message.roleKeyEncryptedWithUserPublicKey);
      if (
        message.approverRoleData != null &&
        Object.hasOwnProperty.call(message, "approverRoleData")
      )
        writer.uint32(/* id 16, wireType 2 =*/ 130).bytes(message.approverRoleData);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseRegistration message, length delimited. Does not implicitly {@link Enterprise.EnterpriseRegistration.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Enterprise.IEnterpriseRegistration} message EnterpriseRegistration message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseRegistration.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseRegistration message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseRegistration.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseRegistration();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.encryptedTreeKey = reader.bytes();
            break;
          }
          case 2: {
            message.enterpriseName = reader.string();
            break;
          }
          case 3: {
            message.rootNodeData = reader.bytes();
            break;
          }
          case 4: {
            message.adminUserData = reader.bytes();
            break;
          }
          case 5: {
            message.adminName = reader.string();
            break;
          }
          case 6: {
            message.roleData = reader.bytes();
            break;
          }
          case 7: {
            message.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 8: {
            message.numberSeats = reader.int32();
            break;
          }
          case 9: {
            message.enterpriseType = reader.int32();
            break;
          }
          case 10: {
            message.rolePublicKey = reader.bytes();
            break;
          }
          case 11: {
            message.rolePrivateKeyEncryptedWithRoleKey = reader.bytes();
            break;
          }
          case 12: {
            message.roleKeyEncryptedWithTreeKey = reader.bytes();
            break;
          }
          case 13: {
            message.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 14: {
            message.allUsersRoleData = reader.bytes();
            break;
          }
          case 15: {
            message.roleKeyEncryptedWithUserPublicKey = reader.bytes();
            break;
          }
          case 16: {
            message.approverRoleData = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseRegistration message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseRegistration.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseRegistration message.
     * @function verify
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseRegistration.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
        if (
          !(
            (message.encryptedTreeKey && typeof message.encryptedTreeKey.length === "number") ||
            $util.isString(message.encryptedTreeKey)
          )
        )
          return "encryptedTreeKey: buffer expected";
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        if (!$util.isString(message.enterpriseName)) return "enterpriseName: string expected";
      if (message.rootNodeData != null && message.hasOwnProperty("rootNodeData"))
        if (
          !(
            (message.rootNodeData && typeof message.rootNodeData.length === "number") ||
            $util.isString(message.rootNodeData)
          )
        )
          return "rootNodeData: buffer expected";
      if (message.adminUserData != null && message.hasOwnProperty("adminUserData"))
        if (
          !(
            (message.adminUserData && typeof message.adminUserData.length === "number") ||
            $util.isString(message.adminUserData)
          )
        )
          return "adminUserData: buffer expected";
      if (message.adminName != null && message.hasOwnProperty("adminName"))
        if (!$util.isString(message.adminName)) return "adminName: string expected";
      if (message.roleData != null && message.hasOwnProperty("roleData"))
        if (
          !(
            (message.roleData && typeof message.roleData.length === "number") ||
            $util.isString(message.roleData)
          )
        )
          return "roleData: buffer expected";
      if (message.rsaKeyPair != null && message.hasOwnProperty("rsaKeyPair")) {
        let error = $root.Enterprise.EnterpriseKeyPairRequest.verify(message.rsaKeyPair);
        if (error) return "rsaKeyPair." + error;
      }
      if (message.numberSeats != null && message.hasOwnProperty("numberSeats"))
        if (!$util.isInteger(message.numberSeats)) return "numberSeats: integer expected";
      if (message.enterpriseType != null && message.hasOwnProperty("enterpriseType"))
        switch (message.enterpriseType) {
          default:
            return "enterpriseType: enum value expected";
          case 0:
          case 1:
            break;
        }
      if (message.rolePublicKey != null && message.hasOwnProperty("rolePublicKey"))
        if (
          !(
            (message.rolePublicKey && typeof message.rolePublicKey.length === "number") ||
            $util.isString(message.rolePublicKey)
          )
        )
          return "rolePublicKey: buffer expected";
      if (
        message.rolePrivateKeyEncryptedWithRoleKey != null &&
        message.hasOwnProperty("rolePrivateKeyEncryptedWithRoleKey")
      )
        if (
          !(
            (message.rolePrivateKeyEncryptedWithRoleKey &&
              typeof message.rolePrivateKeyEncryptedWithRoleKey.length === "number") ||
            $util.isString(message.rolePrivateKeyEncryptedWithRoleKey)
          )
        )
          return "rolePrivateKeyEncryptedWithRoleKey: buffer expected";
      if (
        message.roleKeyEncryptedWithTreeKey != null &&
        message.hasOwnProperty("roleKeyEncryptedWithTreeKey")
      )
        if (
          !(
            (message.roleKeyEncryptedWithTreeKey &&
              typeof message.roleKeyEncryptedWithTreeKey.length === "number") ||
            $util.isString(message.roleKeyEncryptedWithTreeKey)
          )
        )
          return "roleKeyEncryptedWithTreeKey: buffer expected";
      if (message.eccKeyPair != null && message.hasOwnProperty("eccKeyPair")) {
        let error = $root.Enterprise.EnterpriseKeyPairRequest.verify(message.eccKeyPair);
        if (error) return "eccKeyPair." + error;
      }
      if (message.allUsersRoleData != null && message.hasOwnProperty("allUsersRoleData"))
        if (
          !(
            (message.allUsersRoleData && typeof message.allUsersRoleData.length === "number") ||
            $util.isString(message.allUsersRoleData)
          )
        )
          return "allUsersRoleData: buffer expected";
      if (
        message.roleKeyEncryptedWithUserPublicKey != null &&
        message.hasOwnProperty("roleKeyEncryptedWithUserPublicKey")
      )
        if (
          !(
            (message.roleKeyEncryptedWithUserPublicKey &&
              typeof message.roleKeyEncryptedWithUserPublicKey.length === "number") ||
            $util.isString(message.roleKeyEncryptedWithUserPublicKey)
          )
        )
          return "roleKeyEncryptedWithUserPublicKey: buffer expected";
      if (message.approverRoleData != null && message.hasOwnProperty("approverRoleData"))
        if (
          !(
            (message.approverRoleData && typeof message.approverRoleData.length === "number") ||
            $util.isString(message.approverRoleData)
          )
        )
          return "approverRoleData: buffer expected";
      return null;
    };

    /**
     * Creates an EnterpriseRegistration message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
     */
    EnterpriseRegistration.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseRegistration) return object;
      let message = new $root.Enterprise.EnterpriseRegistration();
      if (object.encryptedTreeKey != null)
        if (typeof object.encryptedTreeKey === "string")
          $util.base64.decode(
            object.encryptedTreeKey,
            (message.encryptedTreeKey = $util.newBuffer(
              $util.base64.length(object.encryptedTreeKey),
            )),
            0,
          );
        else if (object.encryptedTreeKey.length >= 0)
          message.encryptedTreeKey = object.encryptedTreeKey;
      if (object.enterpriseName != null) message.enterpriseName = String(object.enterpriseName);
      if (object.rootNodeData != null)
        if (typeof object.rootNodeData === "string")
          $util.base64.decode(
            object.rootNodeData,
            (message.rootNodeData = $util.newBuffer($util.base64.length(object.rootNodeData))),
            0,
          );
        else if (object.rootNodeData.length >= 0) message.rootNodeData = object.rootNodeData;
      if (object.adminUserData != null)
        if (typeof object.adminUserData === "string")
          $util.base64.decode(
            object.adminUserData,
            (message.adminUserData = $util.newBuffer($util.base64.length(object.adminUserData))),
            0,
          );
        else if (object.adminUserData.length >= 0) message.adminUserData = object.adminUserData;
      if (object.adminName != null) message.adminName = String(object.adminName);
      if (object.roleData != null)
        if (typeof object.roleData === "string")
          $util.base64.decode(
            object.roleData,
            (message.roleData = $util.newBuffer($util.base64.length(object.roleData))),
            0,
          );
        else if (object.roleData.length >= 0) message.roleData = object.roleData;
      if (object.rsaKeyPair != null) {
        if (typeof object.rsaKeyPair !== "object")
          throw TypeError(".Enterprise.EnterpriseRegistration.rsaKeyPair: object expected");
        message.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.fromObject(
          object.rsaKeyPair,
        );
      }
      if (object.numberSeats != null) message.numberSeats = object.numberSeats | 0;
      switch (object.enterpriseType) {
        default:
          if (typeof object.enterpriseType === "number") {
            message.enterpriseType = object.enterpriseType;
            break;
          }
          break;
        case "ENTERPRISE_STANDARD":
        case 0:
          message.enterpriseType = 0;
          break;
        case "ENTERPRISE_MSP":
        case 1:
          message.enterpriseType = 1;
          break;
      }
      if (object.rolePublicKey != null)
        if (typeof object.rolePublicKey === "string")
          $util.base64.decode(
            object.rolePublicKey,
            (message.rolePublicKey = $util.newBuffer($util.base64.length(object.rolePublicKey))),
            0,
          );
        else if (object.rolePublicKey.length >= 0) message.rolePublicKey = object.rolePublicKey;
      if (object.rolePrivateKeyEncryptedWithRoleKey != null)
        if (typeof object.rolePrivateKeyEncryptedWithRoleKey === "string")
          $util.base64.decode(
            object.rolePrivateKeyEncryptedWithRoleKey,
            (message.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer(
              $util.base64.length(object.rolePrivateKeyEncryptedWithRoleKey),
            )),
            0,
          );
        else if (object.rolePrivateKeyEncryptedWithRoleKey.length >= 0)
          message.rolePrivateKeyEncryptedWithRoleKey = object.rolePrivateKeyEncryptedWithRoleKey;
      if (object.roleKeyEncryptedWithTreeKey != null)
        if (typeof object.roleKeyEncryptedWithTreeKey === "string")
          $util.base64.decode(
            object.roleKeyEncryptedWithTreeKey,
            (message.roleKeyEncryptedWithTreeKey = $util.newBuffer(
              $util.base64.length(object.roleKeyEncryptedWithTreeKey),
            )),
            0,
          );
        else if (object.roleKeyEncryptedWithTreeKey.length >= 0)
          message.roleKeyEncryptedWithTreeKey = object.roleKeyEncryptedWithTreeKey;
      if (object.eccKeyPair != null) {
        if (typeof object.eccKeyPair !== "object")
          throw TypeError(".Enterprise.EnterpriseRegistration.eccKeyPair: object expected");
        message.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.fromObject(
          object.eccKeyPair,
        );
      }
      if (object.allUsersRoleData != null)
        if (typeof object.allUsersRoleData === "string")
          $util.base64.decode(
            object.allUsersRoleData,
            (message.allUsersRoleData = $util.newBuffer(
              $util.base64.length(object.allUsersRoleData),
            )),
            0,
          );
        else if (object.allUsersRoleData.length >= 0)
          message.allUsersRoleData = object.allUsersRoleData;
      if (object.roleKeyEncryptedWithUserPublicKey != null)
        if (typeof object.roleKeyEncryptedWithUserPublicKey === "string")
          $util.base64.decode(
            object.roleKeyEncryptedWithUserPublicKey,
            (message.roleKeyEncryptedWithUserPublicKey = $util.newBuffer(
              $util.base64.length(object.roleKeyEncryptedWithUserPublicKey),
            )),
            0,
          );
        else if (object.roleKeyEncryptedWithUserPublicKey.length >= 0)
          message.roleKeyEncryptedWithUserPublicKey = object.roleKeyEncryptedWithUserPublicKey;
      if (object.approverRoleData != null)
        if (typeof object.approverRoleData === "string")
          $util.base64.decode(
            object.approverRoleData,
            (message.approverRoleData = $util.newBuffer(
              $util.base64.length(object.approverRoleData),
            )),
            0,
          );
        else if (object.approverRoleData.length >= 0)
          message.approverRoleData = object.approverRoleData;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseRegistration message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {Enterprise.EnterpriseRegistration} message EnterpriseRegistration
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseRegistration.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.encryptedTreeKey = "";
        else {
          object.encryptedTreeKey = [];
          if (options.bytes !== Array)
            object.encryptedTreeKey = $util.newBuffer(object.encryptedTreeKey);
        }
        object.enterpriseName = "";
        if (options.bytes === String) object.rootNodeData = "";
        else {
          object.rootNodeData = [];
          if (options.bytes !== Array) object.rootNodeData = $util.newBuffer(object.rootNodeData);
        }
        if (options.bytes === String) object.adminUserData = "";
        else {
          object.adminUserData = [];
          if (options.bytes !== Array) object.adminUserData = $util.newBuffer(object.adminUserData);
        }
        object.adminName = "";
        if (options.bytes === String) object.roleData = "";
        else {
          object.roleData = [];
          if (options.bytes !== Array) object.roleData = $util.newBuffer(object.roleData);
        }
        object.rsaKeyPair = null;
        object.numberSeats = 0;
        object.enterpriseType = options.enums === String ? "ENTERPRISE_STANDARD" : 0;
        if (options.bytes === String) object.rolePublicKey = "";
        else {
          object.rolePublicKey = [];
          if (options.bytes !== Array) object.rolePublicKey = $util.newBuffer(object.rolePublicKey);
        }
        if (options.bytes === String) object.rolePrivateKeyEncryptedWithRoleKey = "";
        else {
          object.rolePrivateKeyEncryptedWithRoleKey = [];
          if (options.bytes !== Array)
            object.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer(
              object.rolePrivateKeyEncryptedWithRoleKey,
            );
        }
        if (options.bytes === String) object.roleKeyEncryptedWithTreeKey = "";
        else {
          object.roleKeyEncryptedWithTreeKey = [];
          if (options.bytes !== Array)
            object.roleKeyEncryptedWithTreeKey = $util.newBuffer(
              object.roleKeyEncryptedWithTreeKey,
            );
        }
        object.eccKeyPair = null;
        if (options.bytes === String) object.allUsersRoleData = "";
        else {
          object.allUsersRoleData = [];
          if (options.bytes !== Array)
            object.allUsersRoleData = $util.newBuffer(object.allUsersRoleData);
        }
        if (options.bytes === String) object.roleKeyEncryptedWithUserPublicKey = "";
        else {
          object.roleKeyEncryptedWithUserPublicKey = [];
          if (options.bytes !== Array)
            object.roleKeyEncryptedWithUserPublicKey = $util.newBuffer(
              object.roleKeyEncryptedWithUserPublicKey,
            );
        }
        if (options.bytes === String) object.approverRoleData = "";
        else {
          object.approverRoleData = [];
          if (options.bytes !== Array)
            object.approverRoleData = $util.newBuffer(object.approverRoleData);
        }
      }
      if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
        object.encryptedTreeKey =
          options.bytes === String
            ? $util.base64.encode(message.encryptedTreeKey, 0, message.encryptedTreeKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedTreeKey)
              : message.encryptedTreeKey;
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        object.enterpriseName = message.enterpriseName;
      if (message.rootNodeData != null && message.hasOwnProperty("rootNodeData"))
        object.rootNodeData =
          options.bytes === String
            ? $util.base64.encode(message.rootNodeData, 0, message.rootNodeData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rootNodeData)
              : message.rootNodeData;
      if (message.adminUserData != null && message.hasOwnProperty("adminUserData"))
        object.adminUserData =
          options.bytes === String
            ? $util.base64.encode(message.adminUserData, 0, message.adminUserData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.adminUserData)
              : message.adminUserData;
      if (message.adminName != null && message.hasOwnProperty("adminName"))
        object.adminName = message.adminName;
      if (message.roleData != null && message.hasOwnProperty("roleData"))
        object.roleData =
          options.bytes === String
            ? $util.base64.encode(message.roleData, 0, message.roleData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.roleData)
              : message.roleData;
      if (message.rsaKeyPair != null && message.hasOwnProperty("rsaKeyPair"))
        object.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.toObject(
          message.rsaKeyPair,
          options,
        );
      if (message.numberSeats != null && message.hasOwnProperty("numberSeats"))
        object.numberSeats = message.numberSeats;
      if (message.enterpriseType != null && message.hasOwnProperty("enterpriseType"))
        object.enterpriseType =
          options.enums === String
            ? $root.Enterprise.EnterpriseType[message.enterpriseType] === undefined
              ? message.enterpriseType
              : $root.Enterprise.EnterpriseType[message.enterpriseType]
            : message.enterpriseType;
      if (message.rolePublicKey != null && message.hasOwnProperty("rolePublicKey"))
        object.rolePublicKey =
          options.bytes === String
            ? $util.base64.encode(message.rolePublicKey, 0, message.rolePublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rolePublicKey)
              : message.rolePublicKey;
      if (
        message.rolePrivateKeyEncryptedWithRoleKey != null &&
        message.hasOwnProperty("rolePrivateKeyEncryptedWithRoleKey")
      )
        object.rolePrivateKeyEncryptedWithRoleKey =
          options.bytes === String
            ? $util.base64.encode(
                message.rolePrivateKeyEncryptedWithRoleKey,
                0,
                message.rolePrivateKeyEncryptedWithRoleKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rolePrivateKeyEncryptedWithRoleKey)
              : message.rolePrivateKeyEncryptedWithRoleKey;
      if (
        message.roleKeyEncryptedWithTreeKey != null &&
        message.hasOwnProperty("roleKeyEncryptedWithTreeKey")
      )
        object.roleKeyEncryptedWithTreeKey =
          options.bytes === String
            ? $util.base64.encode(
                message.roleKeyEncryptedWithTreeKey,
                0,
                message.roleKeyEncryptedWithTreeKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.roleKeyEncryptedWithTreeKey)
              : message.roleKeyEncryptedWithTreeKey;
      if (message.eccKeyPair != null && message.hasOwnProperty("eccKeyPair"))
        object.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.toObject(
          message.eccKeyPair,
          options,
        );
      if (message.allUsersRoleData != null && message.hasOwnProperty("allUsersRoleData"))
        object.allUsersRoleData =
          options.bytes === String
            ? $util.base64.encode(message.allUsersRoleData, 0, message.allUsersRoleData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.allUsersRoleData)
              : message.allUsersRoleData;
      if (
        message.roleKeyEncryptedWithUserPublicKey != null &&
        message.hasOwnProperty("roleKeyEncryptedWithUserPublicKey")
      )
        object.roleKeyEncryptedWithUserPublicKey =
          options.bytes === String
            ? $util.base64.encode(
                message.roleKeyEncryptedWithUserPublicKey,
                0,
                message.roleKeyEncryptedWithUserPublicKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.roleKeyEncryptedWithUserPublicKey)
              : message.roleKeyEncryptedWithUserPublicKey;
      if (message.approverRoleData != null && message.hasOwnProperty("approverRoleData"))
        object.approverRoleData =
          options.bytes === String
            ? $util.base64.encode(message.approverRoleData, 0, message.approverRoleData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.approverRoleData)
              : message.approverRoleData;
      return object;
    };

    /**
     * Converts this EnterpriseRegistration to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseRegistration
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseRegistration.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseRegistration
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseRegistration
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseRegistration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseRegistration";
    };

    return EnterpriseRegistration;
  })();

  Enterprise.DomainPasswordRulesRequest = (function () {
    /**
     * Properties of a DomainPasswordRulesRequest.
     * @memberof Enterprise
     * @interface IDomainPasswordRulesRequest
     * @property {string|null} [username] DomainPasswordRulesRequest username
     * @property {string|null} [verificationCode] DomainPasswordRulesRequest verificationCode
     */

    /**
     * Constructs a new DomainPasswordRulesRequest.
     * @memberof Enterprise
     * @classdesc Represents a DomainPasswordRulesRequest.
     * @implements IDomainPasswordRulesRequest
     * @constructor
     * @param {Enterprise.IDomainPasswordRulesRequest=} [properties] Properties to set
     */
    function DomainPasswordRulesRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainPasswordRulesRequest username.
     * @member {string} username
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @instance
     */
    DomainPasswordRulesRequest.prototype.username = "";

    /**
     * DomainPasswordRulesRequest verificationCode.
     * @member {string} verificationCode
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @instance
     */
    DomainPasswordRulesRequest.prototype.verificationCode = "";

    /**
     * Creates a new DomainPasswordRulesRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Enterprise.IDomainPasswordRulesRequest=} [properties] Properties to set
     * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest instance
     */
    DomainPasswordRulesRequest.create = function create(properties) {
      return new DomainPasswordRulesRequest(properties);
    };

    /**
     * Encodes the specified DomainPasswordRulesRequest message. Does not implicitly {@link Enterprise.DomainPasswordRulesRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Enterprise.IDomainPasswordRulesRequest} message DomainPasswordRulesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.username);
      if (
        message.verificationCode != null &&
        Object.hasOwnProperty.call(message, "verificationCode")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.verificationCode);
      return writer;
    };

    /**
     * Encodes the specified DomainPasswordRulesRequest message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Enterprise.IDomainPasswordRulesRequest} message DomainPasswordRulesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainPasswordRulesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainPasswordRulesRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.username = reader.string();
            break;
          }
          case 2: {
            message.verificationCode = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainPasswordRulesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainPasswordRulesRequest message.
     * @function verify
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainPasswordRulesRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
        if (!$util.isString(message.verificationCode)) return "verificationCode: string expected";
      return null;
    };

    /**
     * Creates a DomainPasswordRulesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
     */
    DomainPasswordRulesRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainPasswordRulesRequest) return object;
      let message = new $root.Enterprise.DomainPasswordRulesRequest();
      if (object.username != null) message.username = String(object.username);
      if (object.verificationCode != null)
        message.verificationCode = String(object.verificationCode);
      return message;
    };

    /**
     * Creates a plain object from a DomainPasswordRulesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {Enterprise.DomainPasswordRulesRequest} message DomainPasswordRulesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainPasswordRulesRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.username = "";
        object.verificationCode = "";
      }
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
        object.verificationCode = message.verificationCode;
      return object;
    };

    /**
     * Converts this DomainPasswordRulesRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainPasswordRulesRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainPasswordRulesRequest
     * @function getTypeUrl
     * @memberof Enterprise.DomainPasswordRulesRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainPasswordRulesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainPasswordRulesRequest";
    };

    return DomainPasswordRulesRequest;
  })();

  Enterprise.DomainPasswordRulesFields = (function () {
    /**
     * Properties of a DomainPasswordRulesFields.
     * @memberof Enterprise
     * @interface IDomainPasswordRulesFields
     * @property {string|null} [type] DomainPasswordRulesFields type
     * @property {number|null} [minimum] DomainPasswordRulesFields minimum
     * @property {number|null} [maximum] DomainPasswordRulesFields maximum
     * @property {boolean|null} [allowed] DomainPasswordRulesFields allowed
     */

    /**
     * Constructs a new DomainPasswordRulesFields.
     * @memberof Enterprise
     * @classdesc Represents a DomainPasswordRulesFields.
     * @implements IDomainPasswordRulesFields
     * @constructor
     * @param {Enterprise.IDomainPasswordRulesFields=} [properties] Properties to set
     */
    function DomainPasswordRulesFields(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainPasswordRulesFields type.
     * @member {string} type
     * @memberof Enterprise.DomainPasswordRulesFields
     * @instance
     */
    DomainPasswordRulesFields.prototype.type = "";

    /**
     * DomainPasswordRulesFields minimum.
     * @member {number} minimum
     * @memberof Enterprise.DomainPasswordRulesFields
     * @instance
     */
    DomainPasswordRulesFields.prototype.minimum = 0;

    /**
     * DomainPasswordRulesFields maximum.
     * @member {number} maximum
     * @memberof Enterprise.DomainPasswordRulesFields
     * @instance
     */
    DomainPasswordRulesFields.prototype.maximum = 0;

    /**
     * DomainPasswordRulesFields allowed.
     * @member {boolean} allowed
     * @memberof Enterprise.DomainPasswordRulesFields
     * @instance
     */
    DomainPasswordRulesFields.prototype.allowed = false;

    /**
     * Creates a new DomainPasswordRulesFields instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Enterprise.IDomainPasswordRulesFields=} [properties] Properties to set
     * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields instance
     */
    DomainPasswordRulesFields.create = function create(properties) {
      return new DomainPasswordRulesFields(properties);
    };

    /**
     * Encodes the specified DomainPasswordRulesFields message. Does not implicitly {@link Enterprise.DomainPasswordRulesFields.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Enterprise.IDomainPasswordRulesFields} message DomainPasswordRulesFields message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesFields.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type);
      if (message.minimum != null && Object.hasOwnProperty.call(message, "minimum"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.minimum);
      if (message.maximum != null && Object.hasOwnProperty.call(message, "maximum"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.maximum);
      if (message.allowed != null && Object.hasOwnProperty.call(message, "allowed"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.allowed);
      return writer;
    };

    /**
     * Encodes the specified DomainPasswordRulesFields message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesFields.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Enterprise.IDomainPasswordRulesFields} message DomainPasswordRulesFields message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesFields.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainPasswordRulesFields message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesFields.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainPasswordRulesFields();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.type = reader.string();
            break;
          }
          case 2: {
            message.minimum = reader.int32();
            break;
          }
          case 3: {
            message.maximum = reader.int32();
            break;
          }
          case 4: {
            message.allowed = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainPasswordRulesFields message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesFields.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainPasswordRulesFields message.
     * @function verify
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainPasswordRulesFields.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.type != null && message.hasOwnProperty("type"))
        if (!$util.isString(message.type)) return "type: string expected";
      if (message.minimum != null && message.hasOwnProperty("minimum"))
        if (!$util.isInteger(message.minimum)) return "minimum: integer expected";
      if (message.maximum != null && message.hasOwnProperty("maximum"))
        if (!$util.isInteger(message.maximum)) return "maximum: integer expected";
      if (message.allowed != null && message.hasOwnProperty("allowed"))
        if (typeof message.allowed !== "boolean") return "allowed: boolean expected";
      return null;
    };

    /**
     * Creates a DomainPasswordRulesFields message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
     */
    DomainPasswordRulesFields.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainPasswordRulesFields) return object;
      let message = new $root.Enterprise.DomainPasswordRulesFields();
      if (object.type != null) message.type = String(object.type);
      if (object.minimum != null) message.minimum = object.minimum | 0;
      if (object.maximum != null) message.maximum = object.maximum | 0;
      if (object.allowed != null) message.allowed = Boolean(object.allowed);
      return message;
    };

    /**
     * Creates a plain object from a DomainPasswordRulesFields message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {Enterprise.DomainPasswordRulesFields} message DomainPasswordRulesFields
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainPasswordRulesFields.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.type = "";
        object.minimum = 0;
        object.maximum = 0;
        object.allowed = false;
      }
      if (message.type != null && message.hasOwnProperty("type")) object.type = message.type;
      if (message.minimum != null && message.hasOwnProperty("minimum"))
        object.minimum = message.minimum;
      if (message.maximum != null && message.hasOwnProperty("maximum"))
        object.maximum = message.maximum;
      if (message.allowed != null && message.hasOwnProperty("allowed"))
        object.allowed = message.allowed;
      return object;
    };

    /**
     * Converts this DomainPasswordRulesFields to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainPasswordRulesFields
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainPasswordRulesFields.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainPasswordRulesFields
     * @function getTypeUrl
     * @memberof Enterprise.DomainPasswordRulesFields
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainPasswordRulesFields.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainPasswordRulesFields";
    };

    return DomainPasswordRulesFields;
  })();

  Enterprise.LoginToMcRequest = (function () {
    /**
     * Properties of a LoginToMcRequest.
     * @memberof Enterprise
     * @interface ILoginToMcRequest
     * @property {number|null} [mcEnterpriseId] LoginToMcRequest mcEnterpriseId
     * @property {Uint8Array|null} [messageSessionUid] LoginToMcRequest messageSessionUid
     */

    /**
     * Constructs a new LoginToMcRequest.
     * @memberof Enterprise
     * @classdesc Represents a LoginToMcRequest.
     * @implements ILoginToMcRequest
     * @constructor
     * @param {Enterprise.ILoginToMcRequest=} [properties] Properties to set
     */
    function LoginToMcRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoginToMcRequest mcEnterpriseId.
     * @member {number} mcEnterpriseId
     * @memberof Enterprise.LoginToMcRequest
     * @instance
     */
    LoginToMcRequest.prototype.mcEnterpriseId = 0;

    /**
     * LoginToMcRequest messageSessionUid.
     * @member {Uint8Array} messageSessionUid
     * @memberof Enterprise.LoginToMcRequest
     * @instance
     */
    LoginToMcRequest.prototype.messageSessionUid = $util.newBuffer([]);

    /**
     * Creates a new LoginToMcRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Enterprise.ILoginToMcRequest=} [properties] Properties to set
     * @returns {Enterprise.LoginToMcRequest} LoginToMcRequest instance
     */
    LoginToMcRequest.create = function create(properties) {
      return new LoginToMcRequest(properties);
    };

    /**
     * Encodes the specified LoginToMcRequest message. Does not implicitly {@link Enterprise.LoginToMcRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Enterprise.ILoginToMcRequest} message LoginToMcRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoginToMcRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.mcEnterpriseId != null && Object.hasOwnProperty.call(message, "mcEnterpriseId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mcEnterpriseId);
      if (
        message.messageSessionUid != null &&
        Object.hasOwnProperty.call(message, "messageSessionUid")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.messageSessionUid);
      return writer;
    };

    /**
     * Encodes the specified LoginToMcRequest message, length delimited. Does not implicitly {@link Enterprise.LoginToMcRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Enterprise.ILoginToMcRequest} message LoginToMcRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoginToMcRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoginToMcRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.LoginToMcRequest} LoginToMcRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoginToMcRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.LoginToMcRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.mcEnterpriseId = reader.int32();
            break;
          }
          case 2: {
            message.messageSessionUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a LoginToMcRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.LoginToMcRequest} LoginToMcRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoginToMcRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoginToMcRequest message.
     * @function verify
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoginToMcRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
        if (!$util.isInteger(message.mcEnterpriseId)) return "mcEnterpriseId: integer expected";
      if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
        if (
          !(
            (message.messageSessionUid && typeof message.messageSessionUid.length === "number") ||
            $util.isString(message.messageSessionUid)
          )
        )
          return "messageSessionUid: buffer expected";
      return null;
    };

    /**
     * Creates a LoginToMcRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.LoginToMcRequest} LoginToMcRequest
     */
    LoginToMcRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.LoginToMcRequest) return object;
      let message = new $root.Enterprise.LoginToMcRequest();
      if (object.mcEnterpriseId != null) message.mcEnterpriseId = object.mcEnterpriseId | 0;
      if (object.messageSessionUid != null)
        if (typeof object.messageSessionUid === "string")
          $util.base64.decode(
            object.messageSessionUid,
            (message.messageSessionUid = $util.newBuffer(
              $util.base64.length(object.messageSessionUid),
            )),
            0,
          );
        else if (object.messageSessionUid.length >= 0)
          message.messageSessionUid = object.messageSessionUid;
      return message;
    };

    /**
     * Creates a plain object from a LoginToMcRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {Enterprise.LoginToMcRequest} message LoginToMcRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoginToMcRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.mcEnterpriseId = 0;
        if (options.bytes === String) object.messageSessionUid = "";
        else {
          object.messageSessionUid = [];
          if (options.bytes !== Array)
            object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
        }
      }
      if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
        object.mcEnterpriseId = message.mcEnterpriseId;
      if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
        object.messageSessionUid =
          options.bytes === String
            ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.messageSessionUid)
              : message.messageSessionUid;
      return object;
    };

    /**
     * Converts this LoginToMcRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.LoginToMcRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoginToMcRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LoginToMcRequest
     * @function getTypeUrl
     * @memberof Enterprise.LoginToMcRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LoginToMcRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.LoginToMcRequest";
    };

    return LoginToMcRequest;
  })();

  Enterprise.LoginToMcResponse = (function () {
    /**
     * Properties of a LoginToMcResponse.
     * @memberof Enterprise
     * @interface ILoginToMcResponse
     * @property {Uint8Array|null} [encryptedSessionToken] LoginToMcResponse encryptedSessionToken
     * @property {string|null} [encryptedTreeKey] LoginToMcResponse encryptedTreeKey
     */

    /**
     * Constructs a new LoginToMcResponse.
     * @memberof Enterprise
     * @classdesc Represents a LoginToMcResponse.
     * @implements ILoginToMcResponse
     * @constructor
     * @param {Enterprise.ILoginToMcResponse=} [properties] Properties to set
     */
    function LoginToMcResponse(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * LoginToMcResponse encryptedSessionToken.
     * @member {Uint8Array} encryptedSessionToken
     * @memberof Enterprise.LoginToMcResponse
     * @instance
     */
    LoginToMcResponse.prototype.encryptedSessionToken = $util.newBuffer([]);

    /**
     * LoginToMcResponse encryptedTreeKey.
     * @member {string} encryptedTreeKey
     * @memberof Enterprise.LoginToMcResponse
     * @instance
     */
    LoginToMcResponse.prototype.encryptedTreeKey = "";

    /**
     * Creates a new LoginToMcResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Enterprise.ILoginToMcResponse=} [properties] Properties to set
     * @returns {Enterprise.LoginToMcResponse} LoginToMcResponse instance
     */
    LoginToMcResponse.create = function create(properties) {
      return new LoginToMcResponse(properties);
    };

    /**
     * Encodes the specified LoginToMcResponse message. Does not implicitly {@link Enterprise.LoginToMcResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Enterprise.ILoginToMcResponse} message LoginToMcResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoginToMcResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.encryptedSessionToken != null &&
        Object.hasOwnProperty.call(message, "encryptedSessionToken")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.encryptedSessionToken);
      if (
        message.encryptedTreeKey != null &&
        Object.hasOwnProperty.call(message, "encryptedTreeKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.encryptedTreeKey);
      return writer;
    };

    /**
     * Encodes the specified LoginToMcResponse message, length delimited. Does not implicitly {@link Enterprise.LoginToMcResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Enterprise.ILoginToMcResponse} message LoginToMcResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LoginToMcResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LoginToMcResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.LoginToMcResponse} LoginToMcResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoginToMcResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.LoginToMcResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.encryptedSessionToken = reader.bytes();
            break;
          }
          case 2: {
            message.encryptedTreeKey = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a LoginToMcResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.LoginToMcResponse} LoginToMcResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LoginToMcResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LoginToMcResponse message.
     * @function verify
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LoginToMcResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
        if (
          !(
            (message.encryptedSessionToken &&
              typeof message.encryptedSessionToken.length === "number") ||
            $util.isString(message.encryptedSessionToken)
          )
        )
          return "encryptedSessionToken: buffer expected";
      if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
        if (!$util.isString(message.encryptedTreeKey)) return "encryptedTreeKey: string expected";
      return null;
    };

    /**
     * Creates a LoginToMcResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.LoginToMcResponse} LoginToMcResponse
     */
    LoginToMcResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.LoginToMcResponse) return object;
      let message = new $root.Enterprise.LoginToMcResponse();
      if (object.encryptedSessionToken != null)
        if (typeof object.encryptedSessionToken === "string")
          $util.base64.decode(
            object.encryptedSessionToken,
            (message.encryptedSessionToken = $util.newBuffer(
              $util.base64.length(object.encryptedSessionToken),
            )),
            0,
          );
        else if (object.encryptedSessionToken.length >= 0)
          message.encryptedSessionToken = object.encryptedSessionToken;
      if (object.encryptedTreeKey != null)
        message.encryptedTreeKey = String(object.encryptedTreeKey);
      return message;
    };

    /**
     * Creates a plain object from a LoginToMcResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {Enterprise.LoginToMcResponse} message LoginToMcResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LoginToMcResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.encryptedSessionToken = "";
        else {
          object.encryptedSessionToken = [];
          if (options.bytes !== Array)
            object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
        }
        object.encryptedTreeKey = "";
      }
      if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
        object.encryptedSessionToken =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedSessionToken,
                0,
                message.encryptedSessionToken.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedSessionToken)
              : message.encryptedSessionToken;
      if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
        object.encryptedTreeKey = message.encryptedTreeKey;
      return object;
    };

    /**
     * Converts this LoginToMcResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.LoginToMcResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LoginToMcResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LoginToMcResponse
     * @function getTypeUrl
     * @memberof Enterprise.LoginToMcResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LoginToMcResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.LoginToMcResponse";
    };

    return LoginToMcResponse;
  })();

  Enterprise.DomainPasswordRulesResponse = (function () {
    /**
     * Properties of a DomainPasswordRulesResponse.
     * @memberof Enterprise
     * @interface IDomainPasswordRulesResponse
     * @property {Array.<Enterprise.IDomainPasswordRulesFields>|null} [domainPasswordRulesFields] DomainPasswordRulesResponse domainPasswordRulesFields
     */

    /**
     * Constructs a new DomainPasswordRulesResponse.
     * @memberof Enterprise
     * @classdesc Represents a DomainPasswordRulesResponse.
     * @implements IDomainPasswordRulesResponse
     * @constructor
     * @param {Enterprise.IDomainPasswordRulesResponse=} [properties] Properties to set
     */
    function DomainPasswordRulesResponse(properties) {
      this.domainPasswordRulesFields = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainPasswordRulesResponse domainPasswordRulesFields.
     * @member {Array.<Enterprise.IDomainPasswordRulesFields>} domainPasswordRulesFields
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @instance
     */
    DomainPasswordRulesResponse.prototype.domainPasswordRulesFields = $util.emptyArray;

    /**
     * Creates a new DomainPasswordRulesResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Enterprise.IDomainPasswordRulesResponse=} [properties] Properties to set
     * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse instance
     */
    DomainPasswordRulesResponse.create = function create(properties) {
      return new DomainPasswordRulesResponse(properties);
    };

    /**
     * Encodes the specified DomainPasswordRulesResponse message. Does not implicitly {@link Enterprise.DomainPasswordRulesResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Enterprise.IDomainPasswordRulesResponse} message DomainPasswordRulesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.domainPasswordRulesFields != null && message.domainPasswordRulesFields.length)
        for (let i = 0; i < message.domainPasswordRulesFields.length; ++i)
          $root.Enterprise.DomainPasswordRulesFields.encode(
            message.domainPasswordRulesFields[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified DomainPasswordRulesResponse message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Enterprise.IDomainPasswordRulesResponse} message DomainPasswordRulesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainPasswordRulesResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainPasswordRulesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainPasswordRulesResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.domainPasswordRulesFields && message.domainPasswordRulesFields.length))
              message.domainPasswordRulesFields = [];
            message.domainPasswordRulesFields.push(
              $root.Enterprise.DomainPasswordRulesFields.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainPasswordRulesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainPasswordRulesResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainPasswordRulesResponse message.
     * @function verify
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainPasswordRulesResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (
        message.domainPasswordRulesFields != null &&
        message.hasOwnProperty("domainPasswordRulesFields")
      ) {
        if (!Array.isArray(message.domainPasswordRulesFields))
          return "domainPasswordRulesFields: array expected";
        for (let i = 0; i < message.domainPasswordRulesFields.length; ++i) {
          let error = $root.Enterprise.DomainPasswordRulesFields.verify(
            message.domainPasswordRulesFields[i],
          );
          if (error) return "domainPasswordRulesFields." + error;
        }
      }
      return null;
    };

    /**
     * Creates a DomainPasswordRulesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
     */
    DomainPasswordRulesResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainPasswordRulesResponse) return object;
      let message = new $root.Enterprise.DomainPasswordRulesResponse();
      if (object.domainPasswordRulesFields) {
        if (!Array.isArray(object.domainPasswordRulesFields))
          throw TypeError(
            ".Enterprise.DomainPasswordRulesResponse.domainPasswordRulesFields: array expected",
          );
        message.domainPasswordRulesFields = [];
        for (let i = 0; i < object.domainPasswordRulesFields.length; ++i) {
          if (typeof object.domainPasswordRulesFields[i] !== "object")
            throw TypeError(
              ".Enterprise.DomainPasswordRulesResponse.domainPasswordRulesFields: object expected",
            );
          message.domainPasswordRulesFields[i] =
            $root.Enterprise.DomainPasswordRulesFields.fromObject(
              object.domainPasswordRulesFields[i],
            );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a DomainPasswordRulesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {Enterprise.DomainPasswordRulesResponse} message DomainPasswordRulesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainPasswordRulesResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.domainPasswordRulesFields = [];
      if (message.domainPasswordRulesFields && message.domainPasswordRulesFields.length) {
        object.domainPasswordRulesFields = [];
        for (let j = 0; j < message.domainPasswordRulesFields.length; ++j)
          object.domainPasswordRulesFields[j] = $root.Enterprise.DomainPasswordRulesFields.toObject(
            message.domainPasswordRulesFields[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this DomainPasswordRulesResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainPasswordRulesResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainPasswordRulesResponse
     * @function getTypeUrl
     * @memberof Enterprise.DomainPasswordRulesResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainPasswordRulesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainPasswordRulesResponse";
    };

    return DomainPasswordRulesResponse;
  })();

  Enterprise.ApproveUserDeviceRequest = (function () {
    /**
     * Properties of an ApproveUserDeviceRequest.
     * @memberof Enterprise
     * @interface IApproveUserDeviceRequest
     * @property {number|Long|null} [enterpriseUserId] ApproveUserDeviceRequest enterpriseUserId
     * @property {Uint8Array|null} [encryptedDeviceToken] ApproveUserDeviceRequest encryptedDeviceToken
     * @property {Uint8Array|null} [encryptedDeviceDataKey] ApproveUserDeviceRequest encryptedDeviceDataKey
     * @property {boolean|null} [denyApproval] ApproveUserDeviceRequest denyApproval
     */

    /**
     * Constructs a new ApproveUserDeviceRequest.
     * @memberof Enterprise
     * @classdesc Represents an ApproveUserDeviceRequest.
     * @implements IApproveUserDeviceRequest
     * @constructor
     * @param {Enterprise.IApproveUserDeviceRequest=} [properties] Properties to set
     */
    function ApproveUserDeviceRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ApproveUserDeviceRequest enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @instance
     */
    ApproveUserDeviceRequest.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ApproveUserDeviceRequest encryptedDeviceToken.
     * @member {Uint8Array} encryptedDeviceToken
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @instance
     */
    ApproveUserDeviceRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

    /**
     * ApproveUserDeviceRequest encryptedDeviceDataKey.
     * @member {Uint8Array} encryptedDeviceDataKey
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @instance
     */
    ApproveUserDeviceRequest.prototype.encryptedDeviceDataKey = $util.newBuffer([]);

    /**
     * ApproveUserDeviceRequest denyApproval.
     * @member {boolean} denyApproval
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @instance
     */
    ApproveUserDeviceRequest.prototype.denyApproval = false;

    /**
     * Creates a new ApproveUserDeviceRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Enterprise.IApproveUserDeviceRequest=} [properties] Properties to set
     * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest instance
     */
    ApproveUserDeviceRequest.create = function create(properties) {
      return new ApproveUserDeviceRequest(properties);
    };

    /**
     * Encodes the specified ApproveUserDeviceRequest message. Does not implicitly {@link Enterprise.ApproveUserDeviceRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Enterprise.IApproveUserDeviceRequest} message ApproveUserDeviceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDeviceRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (
        message.encryptedDeviceToken != null &&
        Object.hasOwnProperty.call(message, "encryptedDeviceToken")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedDeviceToken);
      if (
        message.encryptedDeviceDataKey != null &&
        Object.hasOwnProperty.call(message, "encryptedDeviceDataKey")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.encryptedDeviceDataKey);
      if (message.denyApproval != null && Object.hasOwnProperty.call(message, "denyApproval"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.denyApproval);
      return writer;
    };

    /**
     * Encodes the specified ApproveUserDeviceRequest message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDeviceRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Enterprise.IApproveUserDeviceRequest} message ApproveUserDeviceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ApproveUserDeviceRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDeviceRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ApproveUserDeviceRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.encryptedDeviceToken = reader.bytes();
            break;
          }
          case 3: {
            message.encryptedDeviceDataKey = reader.bytes();
            break;
          }
          case 4: {
            message.denyApproval = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an ApproveUserDeviceRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDeviceRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ApproveUserDeviceRequest message.
     * @function verify
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ApproveUserDeviceRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        if (
          !(
            (message.encryptedDeviceToken &&
              typeof message.encryptedDeviceToken.length === "number") ||
            $util.isString(message.encryptedDeviceToken)
          )
        )
          return "encryptedDeviceToken: buffer expected";
      if (
        message.encryptedDeviceDataKey != null &&
        message.hasOwnProperty("encryptedDeviceDataKey")
      )
        if (
          !(
            (message.encryptedDeviceDataKey &&
              typeof message.encryptedDeviceDataKey.length === "number") ||
            $util.isString(message.encryptedDeviceDataKey)
          )
        )
          return "encryptedDeviceDataKey: buffer expected";
      if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
        if (typeof message.denyApproval !== "boolean") return "denyApproval: boolean expected";
      return null;
    };

    /**
     * Creates an ApproveUserDeviceRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
     */
    ApproveUserDeviceRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ApproveUserDeviceRequest) return object;
      let message = new $root.Enterprise.ApproveUserDeviceRequest();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.encryptedDeviceToken != null)
        if (typeof object.encryptedDeviceToken === "string")
          $util.base64.decode(
            object.encryptedDeviceToken,
            (message.encryptedDeviceToken = $util.newBuffer(
              $util.base64.length(object.encryptedDeviceToken),
            )),
            0,
          );
        else if (object.encryptedDeviceToken.length >= 0)
          message.encryptedDeviceToken = object.encryptedDeviceToken;
      if (object.encryptedDeviceDataKey != null)
        if (typeof object.encryptedDeviceDataKey === "string")
          $util.base64.decode(
            object.encryptedDeviceDataKey,
            (message.encryptedDeviceDataKey = $util.newBuffer(
              $util.base64.length(object.encryptedDeviceDataKey),
            )),
            0,
          );
        else if (object.encryptedDeviceDataKey.length >= 0)
          message.encryptedDeviceDataKey = object.encryptedDeviceDataKey;
      if (object.denyApproval != null) message.denyApproval = Boolean(object.denyApproval);
      return message;
    };

    /**
     * Creates a plain object from an ApproveUserDeviceRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {Enterprise.ApproveUserDeviceRequest} message ApproveUserDeviceRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ApproveUserDeviceRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedDeviceToken = "";
        else {
          object.encryptedDeviceToken = [];
          if (options.bytes !== Array)
            object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
        }
        if (options.bytes === String) object.encryptedDeviceDataKey = "";
        else {
          object.encryptedDeviceDataKey = [];
          if (options.bytes !== Array)
            object.encryptedDeviceDataKey = $util.newBuffer(object.encryptedDeviceDataKey);
        }
        object.denyApproval = false;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        object.encryptedDeviceToken =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedDeviceToken,
                0,
                message.encryptedDeviceToken.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedDeviceToken)
              : message.encryptedDeviceToken;
      if (
        message.encryptedDeviceDataKey != null &&
        message.hasOwnProperty("encryptedDeviceDataKey")
      )
        object.encryptedDeviceDataKey =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedDeviceDataKey,
                0,
                message.encryptedDeviceDataKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedDeviceDataKey)
              : message.encryptedDeviceDataKey;
      if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
        object.denyApproval = message.denyApproval;
      return object;
    };

    /**
     * Converts this ApproveUserDeviceRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ApproveUserDeviceRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ApproveUserDeviceRequest
     * @function getTypeUrl
     * @memberof Enterprise.ApproveUserDeviceRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ApproveUserDeviceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ApproveUserDeviceRequest";
    };

    return ApproveUserDeviceRequest;
  })();

  Enterprise.ApproveUserDeviceResponse = (function () {
    /**
     * Properties of an ApproveUserDeviceResponse.
     * @memberof Enterprise
     * @interface IApproveUserDeviceResponse
     * @property {number|Long|null} [enterpriseUserId] ApproveUserDeviceResponse enterpriseUserId
     * @property {Uint8Array|null} [encryptedDeviceToken] ApproveUserDeviceResponse encryptedDeviceToken
     * @property {boolean|null} [failed] ApproveUserDeviceResponse failed
     * @property {string|null} [message] ApproveUserDeviceResponse message
     */

    /**
     * Constructs a new ApproveUserDeviceResponse.
     * @memberof Enterprise
     * @classdesc Represents an ApproveUserDeviceResponse.
     * @implements IApproveUserDeviceResponse
     * @constructor
     * @param {Enterprise.IApproveUserDeviceResponse=} [properties] Properties to set
     */
    function ApproveUserDeviceResponse(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ApproveUserDeviceResponse enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @instance
     */
    ApproveUserDeviceResponse.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ApproveUserDeviceResponse encryptedDeviceToken.
     * @member {Uint8Array} encryptedDeviceToken
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @instance
     */
    ApproveUserDeviceResponse.prototype.encryptedDeviceToken = $util.newBuffer([]);

    /**
     * ApproveUserDeviceResponse failed.
     * @member {boolean} failed
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @instance
     */
    ApproveUserDeviceResponse.prototype.failed = false;

    /**
     * ApproveUserDeviceResponse message.
     * @member {string} message
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @instance
     */
    ApproveUserDeviceResponse.prototype.message = "";

    /**
     * Creates a new ApproveUserDeviceResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Enterprise.IApproveUserDeviceResponse=} [properties] Properties to set
     * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse instance
     */
    ApproveUserDeviceResponse.create = function create(properties) {
      return new ApproveUserDeviceResponse(properties);
    };

    /**
     * Encodes the specified ApproveUserDeviceResponse message. Does not implicitly {@link Enterprise.ApproveUserDeviceResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Enterprise.IApproveUserDeviceResponse} message ApproveUserDeviceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDeviceResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (
        message.encryptedDeviceToken != null &&
        Object.hasOwnProperty.call(message, "encryptedDeviceToken")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedDeviceToken);
      if (message.failed != null && Object.hasOwnProperty.call(message, "failed"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.failed);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      return writer;
    };

    /**
     * Encodes the specified ApproveUserDeviceResponse message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDeviceResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Enterprise.IApproveUserDeviceResponse} message ApproveUserDeviceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDeviceResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ApproveUserDeviceResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDeviceResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ApproveUserDeviceResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.encryptedDeviceToken = reader.bytes();
            break;
          }
          case 3: {
            message.failed = reader.bool();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an ApproveUserDeviceResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDeviceResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ApproveUserDeviceResponse message.
     * @function verify
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ApproveUserDeviceResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        if (
          !(
            (message.encryptedDeviceToken &&
              typeof message.encryptedDeviceToken.length === "number") ||
            $util.isString(message.encryptedDeviceToken)
          )
        )
          return "encryptedDeviceToken: buffer expected";
      if (message.failed != null && message.hasOwnProperty("failed"))
        if (typeof message.failed !== "boolean") return "failed: boolean expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      return null;
    };

    /**
     * Creates an ApproveUserDeviceResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
     */
    ApproveUserDeviceResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ApproveUserDeviceResponse) return object;
      let message = new $root.Enterprise.ApproveUserDeviceResponse();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.encryptedDeviceToken != null)
        if (typeof object.encryptedDeviceToken === "string")
          $util.base64.decode(
            object.encryptedDeviceToken,
            (message.encryptedDeviceToken = $util.newBuffer(
              $util.base64.length(object.encryptedDeviceToken),
            )),
            0,
          );
        else if (object.encryptedDeviceToken.length >= 0)
          message.encryptedDeviceToken = object.encryptedDeviceToken;
      if (object.failed != null) message.failed = Boolean(object.failed);
      if (object.message != null) message.message = String(object.message);
      return message;
    };

    /**
     * Creates a plain object from an ApproveUserDeviceResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {Enterprise.ApproveUserDeviceResponse} message ApproveUserDeviceResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ApproveUserDeviceResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedDeviceToken = "";
        else {
          object.encryptedDeviceToken = [];
          if (options.bytes !== Array)
            object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
        }
        object.failed = false;
        object.message = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        object.encryptedDeviceToken =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedDeviceToken,
                0,
                message.encryptedDeviceToken.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedDeviceToken)
              : message.encryptedDeviceToken;
      if (message.failed != null && message.hasOwnProperty("failed"))
        object.failed = message.failed;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      return object;
    };

    /**
     * Converts this ApproveUserDeviceResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ApproveUserDeviceResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ApproveUserDeviceResponse
     * @function getTypeUrl
     * @memberof Enterprise.ApproveUserDeviceResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ApproveUserDeviceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ApproveUserDeviceResponse";
    };

    return ApproveUserDeviceResponse;
  })();

  Enterprise.ApproveUserDevicesRequest = (function () {
    /**
     * Properties of an ApproveUserDevicesRequest.
     * @memberof Enterprise
     * @interface IApproveUserDevicesRequest
     * @property {Array.<Enterprise.IApproveUserDeviceRequest>|null} [deviceRequests] ApproveUserDevicesRequest deviceRequests
     */

    /**
     * Constructs a new ApproveUserDevicesRequest.
     * @memberof Enterprise
     * @classdesc Represents an ApproveUserDevicesRequest.
     * @implements IApproveUserDevicesRequest
     * @constructor
     * @param {Enterprise.IApproveUserDevicesRequest=} [properties] Properties to set
     */
    function ApproveUserDevicesRequest(properties) {
      this.deviceRequests = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ApproveUserDevicesRequest deviceRequests.
     * @member {Array.<Enterprise.IApproveUserDeviceRequest>} deviceRequests
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @instance
     */
    ApproveUserDevicesRequest.prototype.deviceRequests = $util.emptyArray;

    /**
     * Creates a new ApproveUserDevicesRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Enterprise.IApproveUserDevicesRequest=} [properties] Properties to set
     * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest instance
     */
    ApproveUserDevicesRequest.create = function create(properties) {
      return new ApproveUserDevicesRequest(properties);
    };

    /**
     * Encodes the specified ApproveUserDevicesRequest message. Does not implicitly {@link Enterprise.ApproveUserDevicesRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Enterprise.IApproveUserDevicesRequest} message ApproveUserDevicesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDevicesRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.deviceRequests != null && message.deviceRequests.length)
        for (let i = 0; i < message.deviceRequests.length; ++i)
          $root.Enterprise.ApproveUserDeviceRequest.encode(
            message.deviceRequests[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified ApproveUserDevicesRequest message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDevicesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Enterprise.IApproveUserDevicesRequest} message ApproveUserDevicesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDevicesRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ApproveUserDevicesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDevicesRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ApproveUserDevicesRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.deviceRequests && message.deviceRequests.length))
              message.deviceRequests = [];
            message.deviceRequests.push(
              $root.Enterprise.ApproveUserDeviceRequest.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an ApproveUserDevicesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDevicesRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ApproveUserDevicesRequest message.
     * @function verify
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ApproveUserDevicesRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.deviceRequests != null && message.hasOwnProperty("deviceRequests")) {
        if (!Array.isArray(message.deviceRequests)) return "deviceRequests: array expected";
        for (let i = 0; i < message.deviceRequests.length; ++i) {
          let error = $root.Enterprise.ApproveUserDeviceRequest.verify(message.deviceRequests[i]);
          if (error) return "deviceRequests." + error;
        }
      }
      return null;
    };

    /**
     * Creates an ApproveUserDevicesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
     */
    ApproveUserDevicesRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ApproveUserDevicesRequest) return object;
      let message = new $root.Enterprise.ApproveUserDevicesRequest();
      if (object.deviceRequests) {
        if (!Array.isArray(object.deviceRequests))
          throw TypeError(".Enterprise.ApproveUserDevicesRequest.deviceRequests: array expected");
        message.deviceRequests = [];
        for (let i = 0; i < object.deviceRequests.length; ++i) {
          if (typeof object.deviceRequests[i] !== "object")
            throw TypeError(
              ".Enterprise.ApproveUserDevicesRequest.deviceRequests: object expected",
            );
          message.deviceRequests[i] = $root.Enterprise.ApproveUserDeviceRequest.fromObject(
            object.deviceRequests[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an ApproveUserDevicesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {Enterprise.ApproveUserDevicesRequest} message ApproveUserDevicesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ApproveUserDevicesRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.deviceRequests = [];
      if (message.deviceRequests && message.deviceRequests.length) {
        object.deviceRequests = [];
        for (let j = 0; j < message.deviceRequests.length; ++j)
          object.deviceRequests[j] = $root.Enterprise.ApproveUserDeviceRequest.toObject(
            message.deviceRequests[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this ApproveUserDevicesRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ApproveUserDevicesRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ApproveUserDevicesRequest
     * @function getTypeUrl
     * @memberof Enterprise.ApproveUserDevicesRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ApproveUserDevicesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ApproveUserDevicesRequest";
    };

    return ApproveUserDevicesRequest;
  })();

  Enterprise.ApproveUserDevicesResponse = (function () {
    /**
     * Properties of an ApproveUserDevicesResponse.
     * @memberof Enterprise
     * @interface IApproveUserDevicesResponse
     * @property {Array.<Enterprise.IApproveUserDeviceResponse>|null} [deviceResponses] ApproveUserDevicesResponse deviceResponses
     */

    /**
     * Constructs a new ApproveUserDevicesResponse.
     * @memberof Enterprise
     * @classdesc Represents an ApproveUserDevicesResponse.
     * @implements IApproveUserDevicesResponse
     * @constructor
     * @param {Enterprise.IApproveUserDevicesResponse=} [properties] Properties to set
     */
    function ApproveUserDevicesResponse(properties) {
      this.deviceResponses = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ApproveUserDevicesResponse deviceResponses.
     * @member {Array.<Enterprise.IApproveUserDeviceResponse>} deviceResponses
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @instance
     */
    ApproveUserDevicesResponse.prototype.deviceResponses = $util.emptyArray;

    /**
     * Creates a new ApproveUserDevicesResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Enterprise.IApproveUserDevicesResponse=} [properties] Properties to set
     * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse instance
     */
    ApproveUserDevicesResponse.create = function create(properties) {
      return new ApproveUserDevicesResponse(properties);
    };

    /**
     * Encodes the specified ApproveUserDevicesResponse message. Does not implicitly {@link Enterprise.ApproveUserDevicesResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Enterprise.IApproveUserDevicesResponse} message ApproveUserDevicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDevicesResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.deviceResponses != null && message.deviceResponses.length)
        for (let i = 0; i < message.deviceResponses.length; ++i)
          $root.Enterprise.ApproveUserDeviceResponse.encode(
            message.deviceResponses[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified ApproveUserDevicesResponse message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDevicesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Enterprise.IApproveUserDevicesResponse} message ApproveUserDevicesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ApproveUserDevicesResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ApproveUserDevicesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDevicesResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ApproveUserDevicesResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.deviceResponses && message.deviceResponses.length))
              message.deviceResponses = [];
            message.deviceResponses.push(
              $root.Enterprise.ApproveUserDeviceResponse.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an ApproveUserDevicesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ApproveUserDevicesResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ApproveUserDevicesResponse message.
     * @function verify
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ApproveUserDevicesResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.deviceResponses != null && message.hasOwnProperty("deviceResponses")) {
        if (!Array.isArray(message.deviceResponses)) return "deviceResponses: array expected";
        for (let i = 0; i < message.deviceResponses.length; ++i) {
          let error = $root.Enterprise.ApproveUserDeviceResponse.verify(message.deviceResponses[i]);
          if (error) return "deviceResponses." + error;
        }
      }
      return null;
    };

    /**
     * Creates an ApproveUserDevicesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
     */
    ApproveUserDevicesResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ApproveUserDevicesResponse) return object;
      let message = new $root.Enterprise.ApproveUserDevicesResponse();
      if (object.deviceResponses) {
        if (!Array.isArray(object.deviceResponses))
          throw TypeError(".Enterprise.ApproveUserDevicesResponse.deviceResponses: array expected");
        message.deviceResponses = [];
        for (let i = 0; i < object.deviceResponses.length; ++i) {
          if (typeof object.deviceResponses[i] !== "object")
            throw TypeError(
              ".Enterprise.ApproveUserDevicesResponse.deviceResponses: object expected",
            );
          message.deviceResponses[i] = $root.Enterprise.ApproveUserDeviceResponse.fromObject(
            object.deviceResponses[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an ApproveUserDevicesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {Enterprise.ApproveUserDevicesResponse} message ApproveUserDevicesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ApproveUserDevicesResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.deviceResponses = [];
      if (message.deviceResponses && message.deviceResponses.length) {
        object.deviceResponses = [];
        for (let j = 0; j < message.deviceResponses.length; ++j)
          object.deviceResponses[j] = $root.Enterprise.ApproveUserDeviceResponse.toObject(
            message.deviceResponses[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this ApproveUserDevicesResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ApproveUserDevicesResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ApproveUserDevicesResponse
     * @function getTypeUrl
     * @memberof Enterprise.ApproveUserDevicesResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ApproveUserDevicesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ApproveUserDevicesResponse";
    };

    return ApproveUserDevicesResponse;
  })();

  Enterprise.EnterpriseUserDataKey = (function () {
    /**
     * Properties of an EnterpriseUserDataKey.
     * @memberof Enterprise
     * @interface IEnterpriseUserDataKey
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUserDataKey enterpriseUserId
     * @property {Uint8Array|null} [userEncryptedDataKey] EnterpriseUserDataKey userEncryptedDataKey
     * @property {number|null} [keyTypeId] EnterpriseUserDataKey keyTypeId
     * @property {Uint8Array|null} [roleKey] EnterpriseUserDataKey roleKey
     * @property {Uint8Array|null} [privateKey] EnterpriseUserDataKey privateKey
     */

    /**
     * Constructs a new EnterpriseUserDataKey.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserDataKey.
     * @implements IEnterpriseUserDataKey
     * @constructor
     * @param {Enterprise.IEnterpriseUserDataKey=} [properties] Properties to set
     */
    function EnterpriseUserDataKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserDataKey enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     */
    EnterpriseUserDataKey.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUserDataKey userEncryptedDataKey.
     * @member {Uint8Array} userEncryptedDataKey
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     */
    EnterpriseUserDataKey.prototype.userEncryptedDataKey = $util.newBuffer([]);

    /**
     * EnterpriseUserDataKey keyTypeId.
     * @member {number} keyTypeId
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     */
    EnterpriseUserDataKey.prototype.keyTypeId = 0;

    /**
     * EnterpriseUserDataKey roleKey.
     * @member {Uint8Array} roleKey
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     */
    EnterpriseUserDataKey.prototype.roleKey = $util.newBuffer([]);

    /**
     * EnterpriseUserDataKey privateKey.
     * @member {Uint8Array} privateKey
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     */
    EnterpriseUserDataKey.prototype.privateKey = $util.newBuffer([]);

    /**
     * Creates a new EnterpriseUserDataKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Enterprise.IEnterpriseUserDataKey=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey instance
     */
    EnterpriseUserDataKey.create = function create(properties) {
      return new EnterpriseUserDataKey(properties);
    };

    /**
     * Encodes the specified EnterpriseUserDataKey message. Does not implicitly {@link Enterprise.EnterpriseUserDataKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Enterprise.IEnterpriseUserDataKey} message EnterpriseUserDataKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (
        message.userEncryptedDataKey != null &&
        Object.hasOwnProperty.call(message, "userEncryptedDataKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.userEncryptedDataKey);
      if (message.keyTypeId != null && Object.hasOwnProperty.call(message, "keyTypeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.keyTypeId);
      if (message.roleKey != null && Object.hasOwnProperty.call(message, "roleKey"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.roleKey);
      if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.privateKey);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserDataKey message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Enterprise.IEnterpriseUserDataKey} message EnterpriseUserDataKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserDataKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserDataKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.userEncryptedDataKey = reader.bytes();
            break;
          }
          case 3: {
            message.keyTypeId = reader.int32();
            break;
          }
          case 4: {
            message.roleKey = reader.bytes();
            break;
          }
          case 5: {
            message.privateKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserDataKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserDataKey message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserDataKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        if (
          !(
            (message.userEncryptedDataKey &&
              typeof message.userEncryptedDataKey.length === "number") ||
            $util.isString(message.userEncryptedDataKey)
          )
        )
          return "userEncryptedDataKey: buffer expected";
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        if (!$util.isInteger(message.keyTypeId)) return "keyTypeId: integer expected";
      if (message.roleKey != null && message.hasOwnProperty("roleKey"))
        if (
          !(
            (message.roleKey && typeof message.roleKey.length === "number") ||
            $util.isString(message.roleKey)
          )
        )
          return "roleKey: buffer expected";
      if (message.privateKey != null && message.hasOwnProperty("privateKey"))
        if (
          !(
            (message.privateKey && typeof message.privateKey.length === "number") ||
            $util.isString(message.privateKey)
          )
        )
          return "privateKey: buffer expected";
      return null;
    };

    /**
     * Creates an EnterpriseUserDataKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
     */
    EnterpriseUserDataKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserDataKey) return object;
      let message = new $root.Enterprise.EnterpriseUserDataKey();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.userEncryptedDataKey != null)
        if (typeof object.userEncryptedDataKey === "string")
          $util.base64.decode(
            object.userEncryptedDataKey,
            (message.userEncryptedDataKey = $util.newBuffer(
              $util.base64.length(object.userEncryptedDataKey),
            )),
            0,
          );
        else if (object.userEncryptedDataKey.length >= 0)
          message.userEncryptedDataKey = object.userEncryptedDataKey;
      if (object.keyTypeId != null) message.keyTypeId = object.keyTypeId | 0;
      if (object.roleKey != null)
        if (typeof object.roleKey === "string")
          $util.base64.decode(
            object.roleKey,
            (message.roleKey = $util.newBuffer($util.base64.length(object.roleKey))),
            0,
          );
        else if (object.roleKey.length >= 0) message.roleKey = object.roleKey;
      if (object.privateKey != null)
        if (typeof object.privateKey === "string")
          $util.base64.decode(
            object.privateKey,
            (message.privateKey = $util.newBuffer($util.base64.length(object.privateKey))),
            0,
          );
        else if (object.privateKey.length >= 0) message.privateKey = object.privateKey;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserDataKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {Enterprise.EnterpriseUserDataKey} message EnterpriseUserDataKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserDataKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.userEncryptedDataKey = "";
        else {
          object.userEncryptedDataKey = [];
          if (options.bytes !== Array)
            object.userEncryptedDataKey = $util.newBuffer(object.userEncryptedDataKey);
        }
        object.keyTypeId = 0;
        if (options.bytes === String) object.roleKey = "";
        else {
          object.roleKey = [];
          if (options.bytes !== Array) object.roleKey = $util.newBuffer(object.roleKey);
        }
        if (options.bytes === String) object.privateKey = "";
        else {
          object.privateKey = [];
          if (options.bytes !== Array) object.privateKey = $util.newBuffer(object.privateKey);
        }
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        object.userEncryptedDataKey =
          options.bytes === String
            ? $util.base64.encode(
                message.userEncryptedDataKey,
                0,
                message.userEncryptedDataKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.userEncryptedDataKey)
              : message.userEncryptedDataKey;
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        object.keyTypeId = message.keyTypeId;
      if (message.roleKey != null && message.hasOwnProperty("roleKey"))
        object.roleKey =
          options.bytes === String
            ? $util.base64.encode(message.roleKey, 0, message.roleKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.roleKey)
              : message.roleKey;
      if (message.privateKey != null && message.hasOwnProperty("privateKey"))
        object.privateKey =
          options.bytes === String
            ? $util.base64.encode(message.privateKey, 0, message.privateKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.privateKey)
              : message.privateKey;
      return object;
    };

    /**
     * Converts this EnterpriseUserDataKey to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserDataKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserDataKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserDataKey
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserDataKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserDataKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserDataKey";
    };

    return EnterpriseUserDataKey;
  })();

  Enterprise.EnterpriseUserDataKeys = (function () {
    /**
     * Properties of an EnterpriseUserDataKeys.
     * @memberof Enterprise
     * @interface IEnterpriseUserDataKeys
     * @property {Array.<Enterprise.IEnterpriseUserDataKey>|null} [keys] EnterpriseUserDataKeys keys
     */

    /**
     * Constructs a new EnterpriseUserDataKeys.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserDataKeys.
     * @implements IEnterpriseUserDataKeys
     * @constructor
     * @param {Enterprise.IEnterpriseUserDataKeys=} [properties] Properties to set
     */
    function EnterpriseUserDataKeys(properties) {
      this.keys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserDataKeys keys.
     * @member {Array.<Enterprise.IEnterpriseUserDataKey>} keys
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @instance
     */
    EnterpriseUserDataKeys.prototype.keys = $util.emptyArray;

    /**
     * Creates a new EnterpriseUserDataKeys instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeys=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys instance
     */
    EnterpriseUserDataKeys.create = function create(properties) {
      return new EnterpriseUserDataKeys(properties);
    };

    /**
     * Encodes the specified EnterpriseUserDataKeys message. Does not implicitly {@link Enterprise.EnterpriseUserDataKeys.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeys} message EnterpriseUserDataKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeys.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.keys != null && message.keys.length)
        for (let i = 0; i < message.keys.length; ++i)
          $root.Enterprise.EnterpriseUserDataKey.encode(
            message.keys[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserDataKeys message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKeys.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeys} message EnterpriseUserDataKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeys.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserDataKeys message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeys.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserDataKeys();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.keys && message.keys.length)) message.keys = [];
            message.keys.push(
              $root.Enterprise.EnterpriseUserDataKey.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserDataKeys message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeys.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserDataKeys message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserDataKeys.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.keys != null && message.hasOwnProperty("keys")) {
        if (!Array.isArray(message.keys)) return "keys: array expected";
        for (let i = 0; i < message.keys.length; ++i) {
          let error = $root.Enterprise.EnterpriseUserDataKey.verify(message.keys[i]);
          if (error) return "keys." + error;
        }
      }
      return null;
    };

    /**
     * Creates an EnterpriseUserDataKeys message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
     */
    EnterpriseUserDataKeys.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserDataKeys) return object;
      let message = new $root.Enterprise.EnterpriseUserDataKeys();
      if (object.keys) {
        if (!Array.isArray(object.keys))
          throw TypeError(".Enterprise.EnterpriseUserDataKeys.keys: array expected");
        message.keys = [];
        for (let i = 0; i < object.keys.length; ++i) {
          if (typeof object.keys[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseUserDataKeys.keys: object expected");
          message.keys[i] = $root.Enterprise.EnterpriseUserDataKey.fromObject(object.keys[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserDataKeys message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {Enterprise.EnterpriseUserDataKeys} message EnterpriseUserDataKeys
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserDataKeys.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.keys = [];
      if (message.keys && message.keys.length) {
        object.keys = [];
        for (let j = 0; j < message.keys.length; ++j)
          object.keys[j] = $root.Enterprise.EnterpriseUserDataKey.toObject(
            message.keys[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this EnterpriseUserDataKeys to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserDataKeys.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserDataKeys
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserDataKeys
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserDataKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserDataKeys";
    };

    return EnterpriseUserDataKeys;
  })();

  Enterprise.EnterpriseUserDataKeyLight = (function () {
    /**
     * Properties of an EnterpriseUserDataKeyLight.
     * @memberof Enterprise
     * @interface IEnterpriseUserDataKeyLight
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUserDataKeyLight enterpriseUserId
     * @property {Uint8Array|null} [userEncryptedDataKey] EnterpriseUserDataKeyLight userEncryptedDataKey
     * @property {number|null} [keyTypeId] EnterpriseUserDataKeyLight keyTypeId
     */

    /**
     * Constructs a new EnterpriseUserDataKeyLight.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserDataKeyLight.
     * @implements IEnterpriseUserDataKeyLight
     * @constructor
     * @param {Enterprise.IEnterpriseUserDataKeyLight=} [properties] Properties to set
     */
    function EnterpriseUserDataKeyLight(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserDataKeyLight enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @instance
     */
    EnterpriseUserDataKeyLight.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUserDataKeyLight userEncryptedDataKey.
     * @member {Uint8Array} userEncryptedDataKey
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @instance
     */
    EnterpriseUserDataKeyLight.prototype.userEncryptedDataKey = $util.newBuffer([]);

    /**
     * EnterpriseUserDataKeyLight keyTypeId.
     * @member {number} keyTypeId
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @instance
     */
    EnterpriseUserDataKeyLight.prototype.keyTypeId = 0;

    /**
     * Creates a new EnterpriseUserDataKeyLight instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeyLight=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserDataKeyLight} EnterpriseUserDataKeyLight instance
     */
    EnterpriseUserDataKeyLight.create = function create(properties) {
      return new EnterpriseUserDataKeyLight(properties);
    };

    /**
     * Encodes the specified EnterpriseUserDataKeyLight message. Does not implicitly {@link Enterprise.EnterpriseUserDataKeyLight.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeyLight} message EnterpriseUserDataKeyLight message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeyLight.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (
        message.userEncryptedDataKey != null &&
        Object.hasOwnProperty.call(message, "userEncryptedDataKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.userEncryptedDataKey);
      if (message.keyTypeId != null && Object.hasOwnProperty.call(message, "keyTypeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.keyTypeId);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserDataKeyLight message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKeyLight.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeyLight} message EnterpriseUserDataKeyLight message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeyLight.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserDataKeyLight message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserDataKeyLight} EnterpriseUserDataKeyLight
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeyLight.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserDataKeyLight();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.userEncryptedDataKey = reader.bytes();
            break;
          }
          case 3: {
            message.keyTypeId = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserDataKeyLight message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserDataKeyLight} EnterpriseUserDataKeyLight
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeyLight.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserDataKeyLight message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserDataKeyLight.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        if (
          !(
            (message.userEncryptedDataKey &&
              typeof message.userEncryptedDataKey.length === "number") ||
            $util.isString(message.userEncryptedDataKey)
          )
        )
          return "userEncryptedDataKey: buffer expected";
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        if (!$util.isInteger(message.keyTypeId)) return "keyTypeId: integer expected";
      return null;
    };

    /**
     * Creates an EnterpriseUserDataKeyLight message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserDataKeyLight} EnterpriseUserDataKeyLight
     */
    EnterpriseUserDataKeyLight.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserDataKeyLight) return object;
      let message = new $root.Enterprise.EnterpriseUserDataKeyLight();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.userEncryptedDataKey != null)
        if (typeof object.userEncryptedDataKey === "string")
          $util.base64.decode(
            object.userEncryptedDataKey,
            (message.userEncryptedDataKey = $util.newBuffer(
              $util.base64.length(object.userEncryptedDataKey),
            )),
            0,
          );
        else if (object.userEncryptedDataKey.length >= 0)
          message.userEncryptedDataKey = object.userEncryptedDataKey;
      if (object.keyTypeId != null) message.keyTypeId = object.keyTypeId | 0;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserDataKeyLight message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {Enterprise.EnterpriseUserDataKeyLight} message EnterpriseUserDataKeyLight
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserDataKeyLight.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.userEncryptedDataKey = "";
        else {
          object.userEncryptedDataKey = [];
          if (options.bytes !== Array)
            object.userEncryptedDataKey = $util.newBuffer(object.userEncryptedDataKey);
        }
        object.keyTypeId = 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
        object.userEncryptedDataKey =
          options.bytes === String
            ? $util.base64.encode(
                message.userEncryptedDataKey,
                0,
                message.userEncryptedDataKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.userEncryptedDataKey)
              : message.userEncryptedDataKey;
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        object.keyTypeId = message.keyTypeId;
      return object;
    };

    /**
     * Converts this EnterpriseUserDataKeyLight to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserDataKeyLight.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserDataKeyLight
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserDataKeyLight
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserDataKeyLight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserDataKeyLight";
    };

    return EnterpriseUserDataKeyLight;
  })();

  Enterprise.EnterpriseUserDataKeysByNode = (function () {
    /**
     * Properties of an EnterpriseUserDataKeysByNode.
     * @memberof Enterprise
     * @interface IEnterpriseUserDataKeysByNode
     * @property {number|Long|null} [nodeId] EnterpriseUserDataKeysByNode nodeId
     * @property {Array.<Enterprise.IEnterpriseUserDataKeyLight>|null} [keys] EnterpriseUserDataKeysByNode keys
     */

    /**
     * Constructs a new EnterpriseUserDataKeysByNode.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserDataKeysByNode.
     * @implements IEnterpriseUserDataKeysByNode
     * @constructor
     * @param {Enterprise.IEnterpriseUserDataKeysByNode=} [properties] Properties to set
     */
    function EnterpriseUserDataKeysByNode(properties) {
      this.keys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserDataKeysByNode nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @instance
     */
    EnterpriseUserDataKeysByNode.prototype.nodeId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUserDataKeysByNode keys.
     * @member {Array.<Enterprise.IEnterpriseUserDataKeyLight>} keys
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @instance
     */
    EnterpriseUserDataKeysByNode.prototype.keys = $util.emptyArray;

    /**
     * Creates a new EnterpriseUserDataKeysByNode instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNode=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserDataKeysByNode} EnterpriseUserDataKeysByNode instance
     */
    EnterpriseUserDataKeysByNode.create = function create(properties) {
      return new EnterpriseUserDataKeysByNode(properties);
    };

    /**
     * Encodes the specified EnterpriseUserDataKeysByNode message. Does not implicitly {@link Enterprise.EnterpriseUserDataKeysByNode.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNode} message EnterpriseUserDataKeysByNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeysByNode.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.nodeId);
      if (message.keys != null && message.keys.length)
        for (let i = 0; i < message.keys.length; ++i)
          $root.Enterprise.EnterpriseUserDataKeyLight.encode(
            message.keys[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserDataKeysByNode message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKeysByNode.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNode} message EnterpriseUserDataKeysByNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeysByNode.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserDataKeysByNode message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserDataKeysByNode} EnterpriseUserDataKeysByNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeysByNode.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserDataKeysByNode();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.nodeId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.keys && message.keys.length)) message.keys = [];
            message.keys.push(
              $root.Enterprise.EnterpriseUserDataKeyLight.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserDataKeysByNode message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserDataKeysByNode} EnterpriseUserDataKeysByNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeysByNode.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserDataKeysByNode message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserDataKeysByNode.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.keys != null && message.hasOwnProperty("keys")) {
        if (!Array.isArray(message.keys)) return "keys: array expected";
        for (let i = 0; i < message.keys.length; ++i) {
          let error = $root.Enterprise.EnterpriseUserDataKeyLight.verify(message.keys[i]);
          if (error) return "keys." + error;
        }
      }
      return null;
    };

    /**
     * Creates an EnterpriseUserDataKeysByNode message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserDataKeysByNode} EnterpriseUserDataKeysByNode
     */
    EnterpriseUserDataKeysByNode.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserDataKeysByNode) return object;
      let message = new $root.Enterprise.EnterpriseUserDataKeysByNode();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.keys) {
        if (!Array.isArray(object.keys))
          throw TypeError(".Enterprise.EnterpriseUserDataKeysByNode.keys: array expected");
        message.keys = [];
        for (let i = 0; i < object.keys.length; ++i) {
          if (typeof object.keys[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseUserDataKeysByNode.keys: object expected");
          message.keys[i] = $root.Enterprise.EnterpriseUserDataKeyLight.fromObject(object.keys[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserDataKeysByNode message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {Enterprise.EnterpriseUserDataKeysByNode} message EnterpriseUserDataKeysByNode
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserDataKeysByNode.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.keys = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.keys && message.keys.length) {
        object.keys = [];
        for (let j = 0; j < message.keys.length; ++j)
          object.keys[j] = $root.Enterprise.EnterpriseUserDataKeyLight.toObject(
            message.keys[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this EnterpriseUserDataKeysByNode to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserDataKeysByNode.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserDataKeysByNode
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserDataKeysByNode
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserDataKeysByNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserDataKeysByNode";
    };

    return EnterpriseUserDataKeysByNode;
  })();

  Enterprise.EnterpriseUserDataKeysByNodeResponse = (function () {
    /**
     * Properties of an EnterpriseUserDataKeysByNodeResponse.
     * @memberof Enterprise
     * @interface IEnterpriseUserDataKeysByNodeResponse
     * @property {Array.<Enterprise.IEnterpriseUserDataKeysByNode>|null} [keys] EnterpriseUserDataKeysByNodeResponse keys
     */

    /**
     * Constructs a new EnterpriseUserDataKeysByNodeResponse.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUserDataKeysByNodeResponse.
     * @implements IEnterpriseUserDataKeysByNodeResponse
     * @constructor
     * @param {Enterprise.IEnterpriseUserDataKeysByNodeResponse=} [properties] Properties to set
     */
    function EnterpriseUserDataKeysByNodeResponse(properties) {
      this.keys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUserDataKeysByNodeResponse keys.
     * @member {Array.<Enterprise.IEnterpriseUserDataKeysByNode>} keys
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @instance
     */
    EnterpriseUserDataKeysByNodeResponse.prototype.keys = $util.emptyArray;

    /**
     * Creates a new EnterpriseUserDataKeysByNodeResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNodeResponse=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUserDataKeysByNodeResponse} EnterpriseUserDataKeysByNodeResponse instance
     */
    EnterpriseUserDataKeysByNodeResponse.create = function create(properties) {
      return new EnterpriseUserDataKeysByNodeResponse(properties);
    };

    /**
     * Encodes the specified EnterpriseUserDataKeysByNodeResponse message. Does not implicitly {@link Enterprise.EnterpriseUserDataKeysByNodeResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNodeResponse} message EnterpriseUserDataKeysByNodeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeysByNodeResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.keys != null && message.keys.length)
        for (let i = 0; i < message.keys.length; ++i)
          $root.Enterprise.EnterpriseUserDataKeysByNode.encode(
            message.keys[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUserDataKeysByNodeResponse message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKeysByNodeResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Enterprise.IEnterpriseUserDataKeysByNodeResponse} message EnterpriseUserDataKeysByNodeResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUserDataKeysByNodeResponse.encodeDelimited = function encodeDelimited(
      message,
      writer,
    ) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUserDataKeysByNodeResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUserDataKeysByNodeResponse} EnterpriseUserDataKeysByNodeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeysByNodeResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUserDataKeysByNodeResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.keys && message.keys.length)) message.keys = [];
            message.keys.push(
              $root.Enterprise.EnterpriseUserDataKeysByNode.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUserDataKeysByNodeResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUserDataKeysByNodeResponse} EnterpriseUserDataKeysByNodeResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUserDataKeysByNodeResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUserDataKeysByNodeResponse message.
     * @function verify
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUserDataKeysByNodeResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.keys != null && message.hasOwnProperty("keys")) {
        if (!Array.isArray(message.keys)) return "keys: array expected";
        for (let i = 0; i < message.keys.length; ++i) {
          let error = $root.Enterprise.EnterpriseUserDataKeysByNode.verify(message.keys[i]);
          if (error) return "keys." + error;
        }
      }
      return null;
    };

    /**
     * Creates an EnterpriseUserDataKeysByNodeResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUserDataKeysByNodeResponse} EnterpriseUserDataKeysByNodeResponse
     */
    EnterpriseUserDataKeysByNodeResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUserDataKeysByNodeResponse) return object;
      let message = new $root.Enterprise.EnterpriseUserDataKeysByNodeResponse();
      if (object.keys) {
        if (!Array.isArray(object.keys))
          throw TypeError(".Enterprise.EnterpriseUserDataKeysByNodeResponse.keys: array expected");
        message.keys = [];
        for (let i = 0; i < object.keys.length; ++i) {
          if (typeof object.keys[i] !== "object")
            throw TypeError(
              ".Enterprise.EnterpriseUserDataKeysByNodeResponse.keys: object expected",
            );
          message.keys[i] = $root.Enterprise.EnterpriseUserDataKeysByNode.fromObject(
            object.keys[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUserDataKeysByNodeResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {Enterprise.EnterpriseUserDataKeysByNodeResponse} message EnterpriseUserDataKeysByNodeResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUserDataKeysByNodeResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.keys = [];
      if (message.keys && message.keys.length) {
        object.keys = [];
        for (let j = 0; j < message.keys.length; ++j)
          object.keys[j] = $root.Enterprise.EnterpriseUserDataKeysByNode.toObject(
            message.keys[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this EnterpriseUserDataKeysByNodeResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUserDataKeysByNodeResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUserDataKeysByNodeResponse
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUserDataKeysByNodeResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUserDataKeysByNodeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUserDataKeysByNodeResponse";
    };

    return EnterpriseUserDataKeysByNodeResponse;
  })();

  Enterprise.EnterpriseDataRequest = (function () {
    /**
     * Properties of an EnterpriseDataRequest.
     * @memberof Enterprise
     * @interface IEnterpriseDataRequest
     * @property {Uint8Array|null} [continuationToken] EnterpriseDataRequest continuationToken
     */

    /**
     * Constructs a new EnterpriseDataRequest.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseDataRequest.
     * @implements IEnterpriseDataRequest
     * @constructor
     * @param {Enterprise.IEnterpriseDataRequest=} [properties] Properties to set
     */
    function EnterpriseDataRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseDataRequest continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.EnterpriseDataRequest
     * @instance
     */
    EnterpriseDataRequest.prototype.continuationToken = $util.newBuffer([]);

    /**
     * Creates a new EnterpriseDataRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Enterprise.IEnterpriseDataRequest=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseDataRequest} EnterpriseDataRequest instance
     */
    EnterpriseDataRequest.create = function create(properties) {
      return new EnterpriseDataRequest(properties);
    };

    /**
     * Encodes the specified EnterpriseDataRequest message. Does not implicitly {@link Enterprise.EnterpriseDataRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Enterprise.IEnterpriseDataRequest} message EnterpriseDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseDataRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.continuationToken);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseDataRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseDataRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Enterprise.IEnterpriseDataRequest} message EnterpriseDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseDataRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseDataRequest} EnterpriseDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseDataRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseDataRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.continuationToken = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseDataRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseDataRequest} EnterpriseDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseDataRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseDataRequest message.
     * @function verify
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseDataRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      return null;
    };

    /**
     * Creates an EnterpriseDataRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseDataRequest} EnterpriseDataRequest
     */
    EnterpriseDataRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseDataRequest) return object;
      let message = new $root.Enterprise.EnterpriseDataRequest();
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseDataRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {Enterprise.EnterpriseDataRequest} message EnterpriseDataRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseDataRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      return object;
    };

    /**
     * Converts this EnterpriseDataRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseDataRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseDataRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseDataRequest
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseDataRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseDataRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseDataRequest";
    };

    return EnterpriseDataRequest;
  })();

  Enterprise.SpecialProvisioning = (function () {
    /**
     * Properties of a SpecialProvisioning.
     * @memberof Enterprise
     * @interface ISpecialProvisioning
     * @property {string|null} [url] SpecialProvisioning url
     * @property {string|null} [name] SpecialProvisioning name
     */

    /**
     * Constructs a new SpecialProvisioning.
     * @memberof Enterprise
     * @classdesc Represents a SpecialProvisioning.
     * @implements ISpecialProvisioning
     * @constructor
     * @param {Enterprise.ISpecialProvisioning=} [properties] Properties to set
     */
    function SpecialProvisioning(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SpecialProvisioning url.
     * @member {string} url
     * @memberof Enterprise.SpecialProvisioning
     * @instance
     */
    SpecialProvisioning.prototype.url = "";

    /**
     * SpecialProvisioning name.
     * @member {string} name
     * @memberof Enterprise.SpecialProvisioning
     * @instance
     */
    SpecialProvisioning.prototype.name = "";

    /**
     * Creates a new SpecialProvisioning instance using the specified properties.
     * @function create
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Enterprise.ISpecialProvisioning=} [properties] Properties to set
     * @returns {Enterprise.SpecialProvisioning} SpecialProvisioning instance
     */
    SpecialProvisioning.create = function create(properties) {
      return new SpecialProvisioning(properties);
    };

    /**
     * Encodes the specified SpecialProvisioning message. Does not implicitly {@link Enterprise.SpecialProvisioning.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Enterprise.ISpecialProvisioning} message SpecialProvisioning message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SpecialProvisioning.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.url != null && Object.hasOwnProperty.call(message, "url"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.url);
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
      return writer;
    };

    /**
     * Encodes the specified SpecialProvisioning message, length delimited. Does not implicitly {@link Enterprise.SpecialProvisioning.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Enterprise.ISpecialProvisioning} message SpecialProvisioning message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SpecialProvisioning.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SpecialProvisioning message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SpecialProvisioning} SpecialProvisioning
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SpecialProvisioning.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SpecialProvisioning();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.url = reader.string();
            break;
          }
          case 2: {
            message.name = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SpecialProvisioning message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SpecialProvisioning} SpecialProvisioning
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SpecialProvisioning.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SpecialProvisioning message.
     * @function verify
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SpecialProvisioning.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.url != null && message.hasOwnProperty("url"))
        if (!$util.isString(message.url)) return "url: string expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      return null;
    };

    /**
     * Creates a SpecialProvisioning message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SpecialProvisioning} SpecialProvisioning
     */
    SpecialProvisioning.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SpecialProvisioning) return object;
      let message = new $root.Enterprise.SpecialProvisioning();
      if (object.url != null) message.url = String(object.url);
      if (object.name != null) message.name = String(object.name);
      return message;
    };

    /**
     * Creates a plain object from a SpecialProvisioning message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {Enterprise.SpecialProvisioning} message SpecialProvisioning
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SpecialProvisioning.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.url = "";
        object.name = "";
      }
      if (message.url != null && message.hasOwnProperty("url")) object.url = message.url;
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      return object;
    };

    /**
     * Converts this SpecialProvisioning to JSON.
     * @function toJSON
     * @memberof Enterprise.SpecialProvisioning
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SpecialProvisioning.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SpecialProvisioning
     * @function getTypeUrl
     * @memberof Enterprise.SpecialProvisioning
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SpecialProvisioning.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SpecialProvisioning";
    };

    return SpecialProvisioning;
  })();

  Enterprise.GeneralDataEntity = (function () {
    /**
     * Properties of a GeneralDataEntity.
     * @memberof Enterprise
     * @interface IGeneralDataEntity
     * @property {string|null} [enterpriseName] GeneralDataEntity enterpriseName
     * @property {boolean|null} [restrictVisibility] GeneralDataEntity restrictVisibility
     * @property {Enterprise.ISpecialProvisioning|null} [specialProvisioning] GeneralDataEntity specialProvisioning
     * @property {Enterprise.IUserPrivilege|null} [userPrivilege] GeneralDataEntity userPrivilege
     * @property {boolean|null} [distributor] GeneralDataEntity distributor
     * @property {boolean|null} [forbidAccountTransfer] GeneralDataEntity forbidAccountTransfer
     * @property {boolean|null} [showUserOnboard] GeneralDataEntity showUserOnboard
     */

    /**
     * Constructs a new GeneralDataEntity.
     * @memberof Enterprise
     * @classdesc Represents a GeneralDataEntity.
     * @implements IGeneralDataEntity
     * @constructor
     * @param {Enterprise.IGeneralDataEntity=} [properties] Properties to set
     */
    function GeneralDataEntity(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GeneralDataEntity enterpriseName.
     * @member {string} enterpriseName
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.enterpriseName = "";

    /**
     * GeneralDataEntity restrictVisibility.
     * @member {boolean} restrictVisibility
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.restrictVisibility = false;

    /**
     * GeneralDataEntity specialProvisioning.
     * @member {Enterprise.ISpecialProvisioning|null|undefined} specialProvisioning
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.specialProvisioning = null;

    /**
     * GeneralDataEntity userPrivilege.
     * @member {Enterprise.IUserPrivilege|null|undefined} userPrivilege
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.userPrivilege = null;

    /**
     * GeneralDataEntity distributor.
     * @member {boolean} distributor
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.distributor = false;

    /**
     * GeneralDataEntity forbidAccountTransfer.
     * @member {boolean} forbidAccountTransfer
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.forbidAccountTransfer = false;

    /**
     * GeneralDataEntity showUserOnboard.
     * @member {boolean} showUserOnboard
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     */
    GeneralDataEntity.prototype.showUserOnboard = false;

    /**
     * Creates a new GeneralDataEntity instance using the specified properties.
     * @function create
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Enterprise.IGeneralDataEntity=} [properties] Properties to set
     * @returns {Enterprise.GeneralDataEntity} GeneralDataEntity instance
     */
    GeneralDataEntity.create = function create(properties) {
      return new GeneralDataEntity(properties);
    };

    /**
     * Encodes the specified GeneralDataEntity message. Does not implicitly {@link Enterprise.GeneralDataEntity.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Enterprise.IGeneralDataEntity} message GeneralDataEntity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GeneralDataEntity.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseName != null && Object.hasOwnProperty.call(message, "enterpriseName"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.enterpriseName);
      if (
        message.restrictVisibility != null &&
        Object.hasOwnProperty.call(message, "restrictVisibility")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.restrictVisibility);
      if (
        message.specialProvisioning != null &&
        Object.hasOwnProperty.call(message, "specialProvisioning")
      )
        $root.Enterprise.SpecialProvisioning.encode(
          message.specialProvisioning,
          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
        ).ldelim();
      if (message.userPrivilege != null && Object.hasOwnProperty.call(message, "userPrivilege"))
        $root.Enterprise.UserPrivilege.encode(
          message.userPrivilege,
          writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
        ).ldelim();
      if (message.distributor != null && Object.hasOwnProperty.call(message, "distributor"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.distributor);
      if (
        message.forbidAccountTransfer != null &&
        Object.hasOwnProperty.call(message, "forbidAccountTransfer")
      )
        writer.uint32(/* id 9, wireType 0 =*/ 72).bool(message.forbidAccountTransfer);
      if (message.showUserOnboard != null && Object.hasOwnProperty.call(message, "showUserOnboard"))
        writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.showUserOnboard);
      return writer;
    };

    /**
     * Encodes the specified GeneralDataEntity message, length delimited. Does not implicitly {@link Enterprise.GeneralDataEntity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Enterprise.IGeneralDataEntity} message GeneralDataEntity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GeneralDataEntity.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GeneralDataEntity message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GeneralDataEntity} GeneralDataEntity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GeneralDataEntity.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GeneralDataEntity();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseName = reader.string();
            break;
          }
          case 2: {
            message.restrictVisibility = reader.bool();
            break;
          }
          case 4: {
            message.specialProvisioning = $root.Enterprise.SpecialProvisioning.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 7: {
            message.userPrivilege = $root.Enterprise.UserPrivilege.decode(reader, reader.uint32());
            break;
          }
          case 8: {
            message.distributor = reader.bool();
            break;
          }
          case 9: {
            message.forbidAccountTransfer = reader.bool();
            break;
          }
          case 10: {
            message.showUserOnboard = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GeneralDataEntity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GeneralDataEntity} GeneralDataEntity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GeneralDataEntity.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GeneralDataEntity message.
     * @function verify
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GeneralDataEntity.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        if (!$util.isString(message.enterpriseName)) return "enterpriseName: string expected";
      if (message.restrictVisibility != null && message.hasOwnProperty("restrictVisibility"))
        if (typeof message.restrictVisibility !== "boolean")
          return "restrictVisibility: boolean expected";
      if (message.specialProvisioning != null && message.hasOwnProperty("specialProvisioning")) {
        let error = $root.Enterprise.SpecialProvisioning.verify(message.specialProvisioning);
        if (error) return "specialProvisioning." + error;
      }
      if (message.userPrivilege != null && message.hasOwnProperty("userPrivilege")) {
        let error = $root.Enterprise.UserPrivilege.verify(message.userPrivilege);
        if (error) return "userPrivilege." + error;
      }
      if (message.distributor != null && message.hasOwnProperty("distributor"))
        if (typeof message.distributor !== "boolean") return "distributor: boolean expected";
      if (message.forbidAccountTransfer != null && message.hasOwnProperty("forbidAccountTransfer"))
        if (typeof message.forbidAccountTransfer !== "boolean")
          return "forbidAccountTransfer: boolean expected";
      if (message.showUserOnboard != null && message.hasOwnProperty("showUserOnboard"))
        if (typeof message.showUserOnboard !== "boolean")
          return "showUserOnboard: boolean expected";
      return null;
    };

    /**
     * Creates a GeneralDataEntity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GeneralDataEntity} GeneralDataEntity
     */
    GeneralDataEntity.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GeneralDataEntity) return object;
      let message = new $root.Enterprise.GeneralDataEntity();
      if (object.enterpriseName != null) message.enterpriseName = String(object.enterpriseName);
      if (object.restrictVisibility != null)
        message.restrictVisibility = Boolean(object.restrictVisibility);
      if (object.specialProvisioning != null) {
        if (typeof object.specialProvisioning !== "object")
          throw TypeError(".Enterprise.GeneralDataEntity.specialProvisioning: object expected");
        message.specialProvisioning = $root.Enterprise.SpecialProvisioning.fromObject(
          object.specialProvisioning,
        );
      }
      if (object.userPrivilege != null) {
        if (typeof object.userPrivilege !== "object")
          throw TypeError(".Enterprise.GeneralDataEntity.userPrivilege: object expected");
        message.userPrivilege = $root.Enterprise.UserPrivilege.fromObject(object.userPrivilege);
      }
      if (object.distributor != null) message.distributor = Boolean(object.distributor);
      if (object.forbidAccountTransfer != null)
        message.forbidAccountTransfer = Boolean(object.forbidAccountTransfer);
      if (object.showUserOnboard != null) message.showUserOnboard = Boolean(object.showUserOnboard);
      return message;
    };

    /**
     * Creates a plain object from a GeneralDataEntity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {Enterprise.GeneralDataEntity} message GeneralDataEntity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GeneralDataEntity.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.enterpriseName = "";
        object.restrictVisibility = false;
        object.specialProvisioning = null;
        object.userPrivilege = null;
        object.distributor = false;
        object.forbidAccountTransfer = false;
        object.showUserOnboard = false;
      }
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        object.enterpriseName = message.enterpriseName;
      if (message.restrictVisibility != null && message.hasOwnProperty("restrictVisibility"))
        object.restrictVisibility = message.restrictVisibility;
      if (message.specialProvisioning != null && message.hasOwnProperty("specialProvisioning"))
        object.specialProvisioning = $root.Enterprise.SpecialProvisioning.toObject(
          message.specialProvisioning,
          options,
        );
      if (message.userPrivilege != null && message.hasOwnProperty("userPrivilege"))
        object.userPrivilege = $root.Enterprise.UserPrivilege.toObject(
          message.userPrivilege,
          options,
        );
      if (message.distributor != null && message.hasOwnProperty("distributor"))
        object.distributor = message.distributor;
      if (message.forbidAccountTransfer != null && message.hasOwnProperty("forbidAccountTransfer"))
        object.forbidAccountTransfer = message.forbidAccountTransfer;
      if (message.showUserOnboard != null && message.hasOwnProperty("showUserOnboard"))
        object.showUserOnboard = message.showUserOnboard;
      return object;
    };

    /**
     * Converts this GeneralDataEntity to JSON.
     * @function toJSON
     * @memberof Enterprise.GeneralDataEntity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GeneralDataEntity.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GeneralDataEntity
     * @function getTypeUrl
     * @memberof Enterprise.GeneralDataEntity
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GeneralDataEntity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GeneralDataEntity";
    };

    return GeneralDataEntity;
  })();

  Enterprise.Node = (function () {
    /**
     * Properties of a Node.
     * @memberof Enterprise
     * @interface INode
     * @property {number|Long|null} [nodeId] Node nodeId
     * @property {number|Long|null} [parentId] Node parentId
     * @property {number|Long|null} [bridgeId] Node bridgeId
     * @property {number|Long|null} [scimId] Node scimId
     * @property {number|Long|null} [licenseId] Node licenseId
     * @property {string|null} [encryptedData] Node encryptedData
     * @property {boolean|null} [duoEnabled] Node duoEnabled
     * @property {boolean|null} [rsaEnabled] Node rsaEnabled
     * @property {number|Long|null} [ssoServiceProviderId] Node ssoServiceProviderId
     * @property {boolean|null} [restrictVisibility] Node restrictVisibility
     * @property {Array.<number|Long>|null} [ssoServiceProviderIds] Node ssoServiceProviderIds
     */

    /**
     * Constructs a new Node.
     * @memberof Enterprise
     * @classdesc Represents a Node.
     * @implements INode
     * @constructor
     * @param {Enterprise.INode=} [properties] Properties to set
     */
    function Node(properties) {
      this.ssoServiceProviderIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Node nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node parentId.
     * @member {number|Long} parentId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.parentId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node bridgeId.
     * @member {number|Long} bridgeId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.bridgeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node scimId.
     * @member {number|Long} scimId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.scimId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node licenseId.
     * @member {number|Long} licenseId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.licenseId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.encryptedData = "";

    /**
     * Node duoEnabled.
     * @member {boolean} duoEnabled
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.duoEnabled = false;

    /**
     * Node rsaEnabled.
     * @member {boolean} rsaEnabled
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.rsaEnabled = false;

    /**
     * Node ssoServiceProviderId.
     * @member {number|Long} ssoServiceProviderId
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Node restrictVisibility.
     * @member {boolean} restrictVisibility
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.restrictVisibility = false;

    /**
     * Node ssoServiceProviderIds.
     * @member {Array.<number|Long>} ssoServiceProviderIds
     * @memberof Enterprise.Node
     * @instance
     */
    Node.prototype.ssoServiceProviderIds = $util.emptyArray;

    /**
     * Creates a new Node instance using the specified properties.
     * @function create
     * @memberof Enterprise.Node
     * @static
     * @param {Enterprise.INode=} [properties] Properties to set
     * @returns {Enterprise.Node} Node instance
     */
    Node.create = function create(properties) {
      return new Node(properties);
    };

    /**
     * Encodes the specified Node message. Does not implicitly {@link Enterprise.Node.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Node
     * @static
     * @param {Enterprise.INode} message Node message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Node.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.nodeId);
      if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.parentId);
      if (message.bridgeId != null && Object.hasOwnProperty.call(message, "bridgeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.bridgeId);
      if (message.scimId != null && Object.hasOwnProperty.call(message, "scimId"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.scimId);
      if (message.licenseId != null && Object.hasOwnProperty.call(message, "licenseId"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.licenseId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.encryptedData);
      if (message.duoEnabled != null && Object.hasOwnProperty.call(message, "duoEnabled"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.duoEnabled);
      if (message.rsaEnabled != null && Object.hasOwnProperty.call(message, "rsaEnabled"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.rsaEnabled);
      if (
        message.ssoServiceProviderId != null &&
        Object.hasOwnProperty.call(message, "ssoServiceProviderId")
      )
        writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.ssoServiceProviderId);
      if (
        message.restrictVisibility != null &&
        Object.hasOwnProperty.call(message, "restrictVisibility")
      )
        writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.restrictVisibility);
      if (message.ssoServiceProviderIds != null && message.ssoServiceProviderIds.length) {
        writer.uint32(/* id 11, wireType 2 =*/ 90).fork();
        for (let i = 0; i < message.ssoServiceProviderIds.length; ++i)
          writer.int64(message.ssoServiceProviderIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified Node message, length delimited. Does not implicitly {@link Enterprise.Node.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Node
     * @static
     * @param {Enterprise.INode} message Node message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Node.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Node message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Node
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Node} Node
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Node.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Node();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.nodeId = reader.int64();
            break;
          }
          case 2: {
            message.parentId = reader.int64();
            break;
          }
          case 3: {
            message.bridgeId = reader.int64();
            break;
          }
          case 4: {
            message.scimId = reader.int64();
            break;
          }
          case 5: {
            message.licenseId = reader.int64();
            break;
          }
          case 6: {
            message.encryptedData = reader.string();
            break;
          }
          case 7: {
            message.duoEnabled = reader.bool();
            break;
          }
          case 8: {
            message.rsaEnabled = reader.bool();
            break;
          }
          case 9: {
            message.ssoServiceProviderId = reader.int64();
            break;
          }
          case 10: {
            message.restrictVisibility = reader.bool();
            break;
          }
          case 11: {
            if (!(message.ssoServiceProviderIds && message.ssoServiceProviderIds.length))
              message.ssoServiceProviderIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.ssoServiceProviderIds.push(reader.int64());
            } else message.ssoServiceProviderIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Node message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Node
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Node} Node
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Node.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Node message.
     * @function verify
     * @memberof Enterprise.Node
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Node.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.parentId != null && message.hasOwnProperty("parentId"))
        if (
          !$util.isInteger(message.parentId) &&
          !(
            message.parentId &&
            $util.isInteger(message.parentId.low) &&
            $util.isInteger(message.parentId.high)
          )
        )
          return "parentId: integer|Long expected";
      if (message.bridgeId != null && message.hasOwnProperty("bridgeId"))
        if (
          !$util.isInteger(message.bridgeId) &&
          !(
            message.bridgeId &&
            $util.isInteger(message.bridgeId.low) &&
            $util.isInteger(message.bridgeId.high)
          )
        )
          return "bridgeId: integer|Long expected";
      if (message.scimId != null && message.hasOwnProperty("scimId"))
        if (
          !$util.isInteger(message.scimId) &&
          !(
            message.scimId &&
            $util.isInteger(message.scimId.low) &&
            $util.isInteger(message.scimId.high)
          )
        )
          return "scimId: integer|Long expected";
      if (message.licenseId != null && message.hasOwnProperty("licenseId"))
        if (
          !$util.isInteger(message.licenseId) &&
          !(
            message.licenseId &&
            $util.isInteger(message.licenseId.low) &&
            $util.isInteger(message.licenseId.high)
          )
        )
          return "licenseId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.duoEnabled != null && message.hasOwnProperty("duoEnabled"))
        if (typeof message.duoEnabled !== "boolean") return "duoEnabled: boolean expected";
      if (message.rsaEnabled != null && message.hasOwnProperty("rsaEnabled"))
        if (typeof message.rsaEnabled !== "boolean") return "rsaEnabled: boolean expected";
      if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
        if (
          !$util.isInteger(message.ssoServiceProviderId) &&
          !(
            message.ssoServiceProviderId &&
            $util.isInteger(message.ssoServiceProviderId.low) &&
            $util.isInteger(message.ssoServiceProviderId.high)
          )
        )
          return "ssoServiceProviderId: integer|Long expected";
      if (message.restrictVisibility != null && message.hasOwnProperty("restrictVisibility"))
        if (typeof message.restrictVisibility !== "boolean")
          return "restrictVisibility: boolean expected";
      if (
        message.ssoServiceProviderIds != null &&
        message.hasOwnProperty("ssoServiceProviderIds")
      ) {
        if (!Array.isArray(message.ssoServiceProviderIds))
          return "ssoServiceProviderIds: array expected";
        for (let i = 0; i < message.ssoServiceProviderIds.length; ++i)
          if (
            !$util.isInteger(message.ssoServiceProviderIds[i]) &&
            !(
              message.ssoServiceProviderIds[i] &&
              $util.isInteger(message.ssoServiceProviderIds[i].low) &&
              $util.isInteger(message.ssoServiceProviderIds[i].high)
            )
          )
            return "ssoServiceProviderIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a Node message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Node
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Node} Node
     */
    Node.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Node) return object;
      let message = new $root.Enterprise.Node();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.parentId != null)
        if ($util.Long) (message.parentId = $util.Long.fromValue(object.parentId)).unsigned = false;
        else if (typeof object.parentId === "string")
          message.parentId = parseInt(object.parentId, 10);
        else if (typeof object.parentId === "number") message.parentId = object.parentId;
        else if (typeof object.parentId === "object")
          message.parentId = new $util.LongBits(
            object.parentId.low >>> 0,
            object.parentId.high >>> 0,
          ).toNumber();
      if (object.bridgeId != null)
        if ($util.Long) (message.bridgeId = $util.Long.fromValue(object.bridgeId)).unsigned = false;
        else if (typeof object.bridgeId === "string")
          message.bridgeId = parseInt(object.bridgeId, 10);
        else if (typeof object.bridgeId === "number") message.bridgeId = object.bridgeId;
        else if (typeof object.bridgeId === "object")
          message.bridgeId = new $util.LongBits(
            object.bridgeId.low >>> 0,
            object.bridgeId.high >>> 0,
          ).toNumber();
      if (object.scimId != null)
        if ($util.Long) (message.scimId = $util.Long.fromValue(object.scimId)).unsigned = false;
        else if (typeof object.scimId === "string") message.scimId = parseInt(object.scimId, 10);
        else if (typeof object.scimId === "number") message.scimId = object.scimId;
        else if (typeof object.scimId === "object")
          message.scimId = new $util.LongBits(
            object.scimId.low >>> 0,
            object.scimId.high >>> 0,
          ).toNumber();
      if (object.licenseId != null)
        if ($util.Long)
          (message.licenseId = $util.Long.fromValue(object.licenseId)).unsigned = false;
        else if (typeof object.licenseId === "string")
          message.licenseId = parseInt(object.licenseId, 10);
        else if (typeof object.licenseId === "number") message.licenseId = object.licenseId;
        else if (typeof object.licenseId === "object")
          message.licenseId = new $util.LongBits(
            object.licenseId.low >>> 0,
            object.licenseId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      if (object.duoEnabled != null) message.duoEnabled = Boolean(object.duoEnabled);
      if (object.rsaEnabled != null) message.rsaEnabled = Boolean(object.rsaEnabled);
      if (object.ssoServiceProviderId != null)
        if ($util.Long)
          (message.ssoServiceProviderId = $util.Long.fromValue(
            object.ssoServiceProviderId,
          )).unsigned = false;
        else if (typeof object.ssoServiceProviderId === "string")
          message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
        else if (typeof object.ssoServiceProviderId === "number")
          message.ssoServiceProviderId = object.ssoServiceProviderId;
        else if (typeof object.ssoServiceProviderId === "object")
          message.ssoServiceProviderId = new $util.LongBits(
            object.ssoServiceProviderId.low >>> 0,
            object.ssoServiceProviderId.high >>> 0,
          ).toNumber();
      if (object.restrictVisibility != null)
        message.restrictVisibility = Boolean(object.restrictVisibility);
      if (object.ssoServiceProviderIds) {
        if (!Array.isArray(object.ssoServiceProviderIds))
          throw TypeError(".Enterprise.Node.ssoServiceProviderIds: array expected");
        message.ssoServiceProviderIds = [];
        for (let i = 0; i < object.ssoServiceProviderIds.length; ++i)
          if ($util.Long)
            (message.ssoServiceProviderIds[i] = $util.Long.fromValue(
              object.ssoServiceProviderIds[i],
            )).unsigned = false;
          else if (typeof object.ssoServiceProviderIds[i] === "string")
            message.ssoServiceProviderIds[i] = parseInt(object.ssoServiceProviderIds[i], 10);
          else if (typeof object.ssoServiceProviderIds[i] === "number")
            message.ssoServiceProviderIds[i] = object.ssoServiceProviderIds[i];
          else if (typeof object.ssoServiceProviderIds[i] === "object")
            message.ssoServiceProviderIds[i] = new $util.LongBits(
              object.ssoServiceProviderIds[i].low >>> 0,
              object.ssoServiceProviderIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a Node message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Node
     * @static
     * @param {Enterprise.Node} message Node
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Node.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.ssoServiceProviderIds = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.parentId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.parentId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.bridgeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.bridgeId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.scimId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.scimId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.licenseId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.licenseId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
        object.duoEnabled = false;
        object.rsaEnabled = false;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.ssoServiceProviderId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.ssoServiceProviderId = options.longs === String ? "0" : 0;
        object.restrictVisibility = false;
      }
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.parentId != null && message.hasOwnProperty("parentId"))
        if (typeof message.parentId === "number")
          object.parentId = options.longs === String ? String(message.parentId) : message.parentId;
        else
          object.parentId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.parentId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.parentId.low >>> 0,
                    message.parentId.high >>> 0,
                  ).toNumber()
                : message.parentId;
      if (message.bridgeId != null && message.hasOwnProperty("bridgeId"))
        if (typeof message.bridgeId === "number")
          object.bridgeId = options.longs === String ? String(message.bridgeId) : message.bridgeId;
        else
          object.bridgeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.bridgeId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.bridgeId.low >>> 0,
                    message.bridgeId.high >>> 0,
                  ).toNumber()
                : message.bridgeId;
      if (message.scimId != null && message.hasOwnProperty("scimId"))
        if (typeof message.scimId === "number")
          object.scimId = options.longs === String ? String(message.scimId) : message.scimId;
        else
          object.scimId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.scimId)
              : options.longs === Number
                ? new $util.LongBits(message.scimId.low >>> 0, message.scimId.high >>> 0).toNumber()
                : message.scimId;
      if (message.licenseId != null && message.hasOwnProperty("licenseId"))
        if (typeof message.licenseId === "number")
          object.licenseId =
            options.longs === String ? String(message.licenseId) : message.licenseId;
        else
          object.licenseId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.licenseId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.licenseId.low >>> 0,
                    message.licenseId.high >>> 0,
                  ).toNumber()
                : message.licenseId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.duoEnabled != null && message.hasOwnProperty("duoEnabled"))
        object.duoEnabled = message.duoEnabled;
      if (message.rsaEnabled != null && message.hasOwnProperty("rsaEnabled"))
        object.rsaEnabled = message.rsaEnabled;
      if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
        if (typeof message.ssoServiceProviderId === "number")
          object.ssoServiceProviderId =
            options.longs === String
              ? String(message.ssoServiceProviderId)
              : message.ssoServiceProviderId;
        else
          object.ssoServiceProviderId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.ssoServiceProviderId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.ssoServiceProviderId.low >>> 0,
                    message.ssoServiceProviderId.high >>> 0,
                  ).toNumber()
                : message.ssoServiceProviderId;
      if (message.restrictVisibility != null && message.hasOwnProperty("restrictVisibility"))
        object.restrictVisibility = message.restrictVisibility;
      if (message.ssoServiceProviderIds && message.ssoServiceProviderIds.length) {
        object.ssoServiceProviderIds = [];
        for (let j = 0; j < message.ssoServiceProviderIds.length; ++j)
          if (typeof message.ssoServiceProviderIds[j] === "number")
            object.ssoServiceProviderIds[j] =
              options.longs === String
                ? String(message.ssoServiceProviderIds[j])
                : message.ssoServiceProviderIds[j];
          else
            object.ssoServiceProviderIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.ssoServiceProviderIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.ssoServiceProviderIds[j].low >>> 0,
                      message.ssoServiceProviderIds[j].high >>> 0,
                    ).toNumber()
                  : message.ssoServiceProviderIds[j];
      }
      return object;
    };

    /**
     * Converts this Node to JSON.
     * @function toJSON
     * @memberof Enterprise.Node
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Node.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Node
     * @function getTypeUrl
     * @memberof Enterprise.Node
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Node.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Node";
    };

    return Node;
  })();

  Enterprise.Role = (function () {
    /**
     * Properties of a Role.
     * @memberof Enterprise
     * @interface IRole
     * @property {number|Long|null} [roleId] Role roleId
     * @property {number|Long|null} [nodeId] Role nodeId
     * @property {string|null} [encryptedData] Role encryptedData
     * @property {string|null} [keyType] Role keyType
     * @property {boolean|null} [visibleBelow] Role visibleBelow
     * @property {boolean|null} [newUserInherit] Role newUserInherit
     * @property {string|null} [roleType] Role roleType
     */

    /**
     * Constructs a new Role.
     * @memberof Enterprise
     * @classdesc Represents a Role.
     * @implements IRole
     * @constructor
     * @param {Enterprise.IRole=} [properties] Properties to set
     */
    function Role(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Role roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Role nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Role encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.encryptedData = "";

    /**
     * Role keyType.
     * @member {string} keyType
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.keyType = "";

    /**
     * Role visibleBelow.
     * @member {boolean} visibleBelow
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.visibleBelow = false;

    /**
     * Role newUserInherit.
     * @member {boolean} newUserInherit
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.newUserInherit = false;

    /**
     * Role roleType.
     * @member {string} roleType
     * @memberof Enterprise.Role
     * @instance
     */
    Role.prototype.roleType = "";

    /**
     * Creates a new Role instance using the specified properties.
     * @function create
     * @memberof Enterprise.Role
     * @static
     * @param {Enterprise.IRole=} [properties] Properties to set
     * @returns {Enterprise.Role} Role instance
     */
    Role.create = function create(properties) {
      return new Role(properties);
    };

    /**
     * Encodes the specified Role message. Does not implicitly {@link Enterprise.Role.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Role
     * @static
     * @param {Enterprise.IRole} message Role message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Role.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.keyType);
      if (message.visibleBelow != null && Object.hasOwnProperty.call(message, "visibleBelow"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.visibleBelow);
      if (message.newUserInherit != null && Object.hasOwnProperty.call(message, "newUserInherit"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.newUserInherit);
      if (message.roleType != null && Object.hasOwnProperty.call(message, "roleType"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.roleType);
      return writer;
    };

    /**
     * Encodes the specified Role message, length delimited. Does not implicitly {@link Enterprise.Role.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Role
     * @static
     * @param {Enterprise.IRole} message Role message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Role.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Role message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Role
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Role} Role
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Role.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Role();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedData = reader.string();
            break;
          }
          case 4: {
            message.keyType = reader.string();
            break;
          }
          case 5: {
            message.visibleBelow = reader.bool();
            break;
          }
          case 6: {
            message.newUserInherit = reader.bool();
            break;
          }
          case 7: {
            message.roleType = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Role message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Role
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Role} Role
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Role.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Role message.
     * @function verify
     * @memberof Enterprise.Role
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Role.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        if (!$util.isString(message.keyType)) return "keyType: string expected";
      if (message.visibleBelow != null && message.hasOwnProperty("visibleBelow"))
        if (typeof message.visibleBelow !== "boolean") return "visibleBelow: boolean expected";
      if (message.newUserInherit != null && message.hasOwnProperty("newUserInherit"))
        if (typeof message.newUserInherit !== "boolean") return "newUserInherit: boolean expected";
      if (message.roleType != null && message.hasOwnProperty("roleType"))
        if (!$util.isString(message.roleType)) return "roleType: string expected";
      return null;
    };

    /**
     * Creates a Role message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Role
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Role} Role
     */
    Role.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Role) return object;
      let message = new $root.Enterprise.Role();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      if (object.keyType != null) message.keyType = String(object.keyType);
      if (object.visibleBelow != null) message.visibleBelow = Boolean(object.visibleBelow);
      if (object.newUserInherit != null) message.newUserInherit = Boolean(object.newUserInherit);
      if (object.roleType != null) message.roleType = String(object.roleType);
      return message;
    };

    /**
     * Creates a plain object from a Role message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Role
     * @static
     * @param {Enterprise.Role} message Role
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Role.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
        object.keyType = "";
        object.visibleBelow = false;
        object.newUserInherit = false;
        object.roleType = "";
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType = message.keyType;
      if (message.visibleBelow != null && message.hasOwnProperty("visibleBelow"))
        object.visibleBelow = message.visibleBelow;
      if (message.newUserInherit != null && message.hasOwnProperty("newUserInherit"))
        object.newUserInherit = message.newUserInherit;
      if (message.roleType != null && message.hasOwnProperty("roleType"))
        object.roleType = message.roleType;
      return object;
    };

    /**
     * Converts this Role to JSON.
     * @function toJSON
     * @memberof Enterprise.Role
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Role.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Role
     * @function getTypeUrl
     * @memberof Enterprise.Role
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Role";
    };

    return Role;
  })();

  Enterprise.User = (function () {
    /**
     * Properties of a User.
     * @memberof Enterprise
     * @interface IUser
     * @property {number|Long|null} [enterpriseUserId] User enterpriseUserId
     * @property {number|Long|null} [nodeId] User nodeId
     * @property {string|null} [encryptedData] User encryptedData
     * @property {string|null} [keyType] User keyType
     * @property {string|null} [username] User username
     * @property {string|null} [status] User status
     * @property {number|null} [lock] User lock
     * @property {number|null} [userId] User userId
     * @property {number|Long|null} [accountShareExpiration] User accountShareExpiration
     * @property {string|null} [fullName] User fullName
     * @property {string|null} [jobTitle] User jobTitle
     * @property {boolean|null} [tfaEnabled] User tfaEnabled
     * @property {Enterprise.TransferAcceptanceStatus|null} [transferAcceptanceStatus] User transferAcceptanceStatus
     */

    /**
     * Constructs a new User.
     * @memberof Enterprise
     * @classdesc Represents a User.
     * @implements IUser
     * @constructor
     * @param {Enterprise.IUser=} [properties] Properties to set
     */
    function User(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * User enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * User nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * User encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.encryptedData = "";

    /**
     * User keyType.
     * @member {string} keyType
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.keyType = "";

    /**
     * User username.
     * @member {string} username
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.username = "";

    /**
     * User status.
     * @member {string} status
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.status = "";

    /**
     * User lock.
     * @member {number} lock
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.lock = 0;

    /**
     * User userId.
     * @member {number} userId
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.userId = 0;

    /**
     * User accountShareExpiration.
     * @member {number|Long} accountShareExpiration
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.accountShareExpiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * User fullName.
     * @member {string} fullName
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.fullName = "";

    /**
     * User jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.jobTitle = "";

    /**
     * User tfaEnabled.
     * @member {boolean} tfaEnabled
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.tfaEnabled = false;

    /**
     * User transferAcceptanceStatus.
     * @member {Enterprise.TransferAcceptanceStatus} transferAcceptanceStatus
     * @memberof Enterprise.User
     * @instance
     */
    User.prototype.transferAcceptanceStatus = 0;

    /**
     * Creates a new User instance using the specified properties.
     * @function create
     * @memberof Enterprise.User
     * @static
     * @param {Enterprise.IUser=} [properties] Properties to set
     * @returns {Enterprise.User} User instance
     */
    User.create = function create(properties) {
      return new User(properties);
    };

    /**
     * Encodes the specified User message. Does not implicitly {@link Enterprise.User.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.User
     * @static
     * @param {Enterprise.IUser} message User message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    User.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.keyType);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.username);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.status);
      if (message.lock != null && Object.hasOwnProperty.call(message, "lock"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.lock);
      if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.userId);
      if (
        message.accountShareExpiration != null &&
        Object.hasOwnProperty.call(message, "accountShareExpiration")
      )
        writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.accountShareExpiration);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.jobTitle);
      if (message.tfaEnabled != null && Object.hasOwnProperty.call(message, "tfaEnabled"))
        writer.uint32(/* id 12, wireType 0 =*/ 96).bool(message.tfaEnabled);
      if (
        message.transferAcceptanceStatus != null &&
        Object.hasOwnProperty.call(message, "transferAcceptanceStatus")
      )
        writer.uint32(/* id 13, wireType 0 =*/ 104).int32(message.transferAcceptanceStatus);
      return writer;
    };

    /**
     * Encodes the specified User message, length delimited. Does not implicitly {@link Enterprise.User.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.User
     * @static
     * @param {Enterprise.IUser} message User message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    User.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a User message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.User
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.User} User
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    User.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.User();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedData = reader.string();
            break;
          }
          case 4: {
            message.keyType = reader.string();
            break;
          }
          case 5: {
            message.username = reader.string();
            break;
          }
          case 6: {
            message.status = reader.string();
            break;
          }
          case 7: {
            message.lock = reader.int32();
            break;
          }
          case 8: {
            message.userId = reader.int32();
            break;
          }
          case 9: {
            message.accountShareExpiration = reader.int64();
            break;
          }
          case 10: {
            message.fullName = reader.string();
            break;
          }
          case 11: {
            message.jobTitle = reader.string();
            break;
          }
          case 12: {
            message.tfaEnabled = reader.bool();
            break;
          }
          case 13: {
            message.transferAcceptanceStatus = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a User message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.User
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.User} User
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    User.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a User message.
     * @function verify
     * @memberof Enterprise.User
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    User.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        if (!$util.isString(message.keyType)) return "keyType: string expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      if (message.status != null && message.hasOwnProperty("status"))
        if (!$util.isString(message.status)) return "status: string expected";
      if (message.lock != null && message.hasOwnProperty("lock"))
        if (!$util.isInteger(message.lock)) return "lock: integer expected";
      if (message.userId != null && message.hasOwnProperty("userId"))
        if (!$util.isInteger(message.userId)) return "userId: integer expected";
      if (
        message.accountShareExpiration != null &&
        message.hasOwnProperty("accountShareExpiration")
      )
        if (
          !$util.isInteger(message.accountShareExpiration) &&
          !(
            message.accountShareExpiration &&
            $util.isInteger(message.accountShareExpiration.low) &&
            $util.isInteger(message.accountShareExpiration.high)
          )
        )
          return "accountShareExpiration: integer|Long expected";
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.tfaEnabled != null && message.hasOwnProperty("tfaEnabled"))
        if (typeof message.tfaEnabled !== "boolean") return "tfaEnabled: boolean expected";
      if (
        message.transferAcceptanceStatus != null &&
        message.hasOwnProperty("transferAcceptanceStatus")
      )
        switch (message.transferAcceptanceStatus) {
          default:
            return "transferAcceptanceStatus: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a User message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.User
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.User} User
     */
    User.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.User) return object;
      let message = new $root.Enterprise.User();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      if (object.keyType != null) message.keyType = String(object.keyType);
      if (object.username != null) message.username = String(object.username);
      if (object.status != null) message.status = String(object.status);
      if (object.lock != null) message.lock = object.lock | 0;
      if (object.userId != null) message.userId = object.userId | 0;
      if (object.accountShareExpiration != null)
        if ($util.Long)
          (message.accountShareExpiration = $util.Long.fromValue(
            object.accountShareExpiration,
          )).unsigned = false;
        else if (typeof object.accountShareExpiration === "string")
          message.accountShareExpiration = parseInt(object.accountShareExpiration, 10);
        else if (typeof object.accountShareExpiration === "number")
          message.accountShareExpiration = object.accountShareExpiration;
        else if (typeof object.accountShareExpiration === "object")
          message.accountShareExpiration = new $util.LongBits(
            object.accountShareExpiration.low >>> 0,
            object.accountShareExpiration.high >>> 0,
          ).toNumber();
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.tfaEnabled != null) message.tfaEnabled = Boolean(object.tfaEnabled);
      switch (object.transferAcceptanceStatus) {
        default:
          if (typeof object.transferAcceptanceStatus === "number") {
            message.transferAcceptanceStatus = object.transferAcceptanceStatus;
            break;
          }
          break;
        case "UNDEFINED":
        case 0:
          message.transferAcceptanceStatus = 0;
          break;
        case "NOT_REQUIRED":
        case 1:
          message.transferAcceptanceStatus = 1;
          break;
        case "NOT_ACCEPTED":
        case 2:
          message.transferAcceptanceStatus = 2;
          break;
        case "PARTIALLY_ACCEPTED":
        case 3:
          message.transferAcceptanceStatus = 3;
          break;
        case "ACCEPTED":
        case 4:
          message.transferAcceptanceStatus = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a User message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.User
     * @static
     * @param {Enterprise.User} message User
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    User.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
        object.keyType = "";
        object.username = "";
        object.status = "";
        object.lock = 0;
        object.userId = 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.accountShareExpiration =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.accountShareExpiration = options.longs === String ? "0" : 0;
        object.fullName = "";
        object.jobTitle = "";
        object.tfaEnabled = false;
        object.transferAcceptanceStatus = options.enums === String ? "UNDEFINED" : 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType = message.keyType;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status = message.status;
      if (message.lock != null && message.hasOwnProperty("lock")) object.lock = message.lock;
      if (message.userId != null && message.hasOwnProperty("userId"))
        object.userId = message.userId;
      if (
        message.accountShareExpiration != null &&
        message.hasOwnProperty("accountShareExpiration")
      )
        if (typeof message.accountShareExpiration === "number")
          object.accountShareExpiration =
            options.longs === String
              ? String(message.accountShareExpiration)
              : message.accountShareExpiration;
        else
          object.accountShareExpiration =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.accountShareExpiration)
              : options.longs === Number
                ? new $util.LongBits(
                    message.accountShareExpiration.low >>> 0,
                    message.accountShareExpiration.high >>> 0,
                  ).toNumber()
                : message.accountShareExpiration;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.tfaEnabled != null && message.hasOwnProperty("tfaEnabled"))
        object.tfaEnabled = message.tfaEnabled;
      if (
        message.transferAcceptanceStatus != null &&
        message.hasOwnProperty("transferAcceptanceStatus")
      )
        object.transferAcceptanceStatus =
          options.enums === String
            ? $root.Enterprise.TransferAcceptanceStatus[message.transferAcceptanceStatus] ===
              undefined
              ? message.transferAcceptanceStatus
              : $root.Enterprise.TransferAcceptanceStatus[message.transferAcceptanceStatus]
            : message.transferAcceptanceStatus;
      return object;
    };

    /**
     * Converts this User to JSON.
     * @function toJSON
     * @memberof Enterprise.User
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    User.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for User
     * @function getTypeUrl
     * @memberof Enterprise.User
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.User";
    };

    return User;
  })();

  Enterprise.UserAlias = (function () {
    /**
     * Properties of a UserAlias.
     * @memberof Enterprise
     * @interface IUserAlias
     * @property {number|Long|null} [enterpriseUserId] UserAlias enterpriseUserId
     * @property {string|null} [username] UserAlias username
     */

    /**
     * Constructs a new UserAlias.
     * @memberof Enterprise
     * @classdesc Represents a UserAlias.
     * @implements IUserAlias
     * @constructor
     * @param {Enterprise.IUserAlias=} [properties] Properties to set
     */
    function UserAlias(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserAlias enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserAlias
     * @instance
     */
    UserAlias.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserAlias username.
     * @member {string} username
     * @memberof Enterprise.UserAlias
     * @instance
     */
    UserAlias.prototype.username = "";

    /**
     * Creates a new UserAlias instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Enterprise.IUserAlias=} [properties] Properties to set
     * @returns {Enterprise.UserAlias} UserAlias instance
     */
    UserAlias.create = function create(properties) {
      return new UserAlias(properties);
    };

    /**
     * Encodes the specified UserAlias message. Does not implicitly {@link Enterprise.UserAlias.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Enterprise.IUserAlias} message UserAlias message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserAlias.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.username);
      return writer;
    };

    /**
     * Encodes the specified UserAlias message, length delimited. Does not implicitly {@link Enterprise.UserAlias.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Enterprise.IUserAlias} message UserAlias message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserAlias.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserAlias message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserAlias
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserAlias} UserAlias
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserAlias.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserAlias();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.username = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserAlias message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserAlias
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserAlias} UserAlias
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserAlias.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserAlias message.
     * @function verify
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserAlias.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      return null;
    };

    /**
     * Creates a UserAlias message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserAlias} UserAlias
     */
    UserAlias.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserAlias) return object;
      let message = new $root.Enterprise.UserAlias();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.username != null) message.username = String(object.username);
      return message;
    };

    /**
     * Creates a plain object from a UserAlias message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserAlias
     * @static
     * @param {Enterprise.UserAlias} message UserAlias
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserAlias.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.username = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      return object;
    };

    /**
     * Converts this UserAlias to JSON.
     * @function toJSON
     * @memberof Enterprise.UserAlias
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserAlias.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserAlias
     * @function getTypeUrl
     * @memberof Enterprise.UserAlias
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserAlias.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserAlias";
    };

    return UserAlias;
  })();

  Enterprise.ComplianceReportMetaData = (function () {
    /**
     * Properties of a ComplianceReportMetaData.
     * @memberof Enterprise
     * @interface IComplianceReportMetaData
     * @property {Uint8Array|null} [reportUid] ComplianceReportMetaData reportUid
     * @property {number|Long|null} [nodeId] ComplianceReportMetaData nodeId
     * @property {string|null} [reportName] ComplianceReportMetaData reportName
     * @property {number|Long|null} [dateGenerated] ComplianceReportMetaData dateGenerated
     * @property {string|null} [runByName] ComplianceReportMetaData runByName
     * @property {number|null} [numberOfOwners] ComplianceReportMetaData numberOfOwners
     * @property {number|null} [numberOfRecords] ComplianceReportMetaData numberOfRecords
     */

    /**
     * Constructs a new ComplianceReportMetaData.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportMetaData.
     * @implements IComplianceReportMetaData
     * @constructor
     * @param {Enterprise.IComplianceReportMetaData=} [properties] Properties to set
     */
    function ComplianceReportMetaData(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportMetaData reportUid.
     * @member {Uint8Array} reportUid
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.reportUid = $util.newBuffer([]);

    /**
     * ComplianceReportMetaData nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ComplianceReportMetaData reportName.
     * @member {string} reportName
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.reportName = "";

    /**
     * ComplianceReportMetaData dateGenerated.
     * @member {number|Long} dateGenerated
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.dateGenerated = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ComplianceReportMetaData runByName.
     * @member {string} runByName
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.runByName = "";

    /**
     * ComplianceReportMetaData numberOfOwners.
     * @member {number} numberOfOwners
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.numberOfOwners = 0;

    /**
     * ComplianceReportMetaData numberOfRecords.
     * @member {number} numberOfRecords
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     */
    ComplianceReportMetaData.prototype.numberOfRecords = 0;

    /**
     * Creates a new ComplianceReportMetaData instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Enterprise.IComplianceReportMetaData=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportMetaData} ComplianceReportMetaData instance
     */
    ComplianceReportMetaData.create = function create(properties) {
      return new ComplianceReportMetaData(properties);
    };

    /**
     * Encodes the specified ComplianceReportMetaData message. Does not implicitly {@link Enterprise.ComplianceReportMetaData.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Enterprise.IComplianceReportMetaData} message ComplianceReportMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportMetaData.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.reportUid != null && Object.hasOwnProperty.call(message, "reportUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.reportUid);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.reportName != null && Object.hasOwnProperty.call(message, "reportName"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.reportName);
      if (message.dateGenerated != null && Object.hasOwnProperty.call(message, "dateGenerated"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.dateGenerated);
      if (message.runByName != null && Object.hasOwnProperty.call(message, "runByName"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.runByName);
      if (message.numberOfOwners != null && Object.hasOwnProperty.call(message, "numberOfOwners"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.numberOfOwners);
      if (message.numberOfRecords != null && Object.hasOwnProperty.call(message, "numberOfRecords"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.numberOfRecords);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportMetaData message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportMetaData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Enterprise.IComplianceReportMetaData} message ComplianceReportMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportMetaData.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportMetaData message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportMetaData} ComplianceReportMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportMetaData.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportMetaData();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.reportUid = reader.bytes();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.reportName = reader.string();
            break;
          }
          case 4: {
            message.dateGenerated = reader.int64();
            break;
          }
          case 5: {
            message.runByName = reader.string();
            break;
          }
          case 7: {
            message.numberOfOwners = reader.int32();
            break;
          }
          case 8: {
            message.numberOfRecords = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportMetaData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportMetaData} ComplianceReportMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportMetaData.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportMetaData message.
     * @function verify
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportMetaData.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        if (
          !(
            (message.reportUid && typeof message.reportUid.length === "number") ||
            $util.isString(message.reportUid)
          )
        )
          return "reportUid: buffer expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        if (!$util.isString(message.reportName)) return "reportName: string expected";
      if (message.dateGenerated != null && message.hasOwnProperty("dateGenerated"))
        if (
          !$util.isInteger(message.dateGenerated) &&
          !(
            message.dateGenerated &&
            $util.isInteger(message.dateGenerated.low) &&
            $util.isInteger(message.dateGenerated.high)
          )
        )
          return "dateGenerated: integer|Long expected";
      if (message.runByName != null && message.hasOwnProperty("runByName"))
        if (!$util.isString(message.runByName)) return "runByName: string expected";
      if (message.numberOfOwners != null && message.hasOwnProperty("numberOfOwners"))
        if (!$util.isInteger(message.numberOfOwners)) return "numberOfOwners: integer expected";
      if (message.numberOfRecords != null && message.hasOwnProperty("numberOfRecords"))
        if (!$util.isInteger(message.numberOfRecords)) return "numberOfRecords: integer expected";
      return null;
    };

    /**
     * Creates a ComplianceReportMetaData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportMetaData} ComplianceReportMetaData
     */
    ComplianceReportMetaData.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportMetaData) return object;
      let message = new $root.Enterprise.ComplianceReportMetaData();
      if (object.reportUid != null)
        if (typeof object.reportUid === "string")
          $util.base64.decode(
            object.reportUid,
            (message.reportUid = $util.newBuffer($util.base64.length(object.reportUid))),
            0,
          );
        else if (object.reportUid.length >= 0) message.reportUid = object.reportUid;
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.reportName != null) message.reportName = String(object.reportName);
      if (object.dateGenerated != null)
        if ($util.Long)
          (message.dateGenerated = $util.Long.fromValue(object.dateGenerated)).unsigned = false;
        else if (typeof object.dateGenerated === "string")
          message.dateGenerated = parseInt(object.dateGenerated, 10);
        else if (typeof object.dateGenerated === "number")
          message.dateGenerated = object.dateGenerated;
        else if (typeof object.dateGenerated === "object")
          message.dateGenerated = new $util.LongBits(
            object.dateGenerated.low >>> 0,
            object.dateGenerated.high >>> 0,
          ).toNumber();
      if (object.runByName != null) message.runByName = String(object.runByName);
      if (object.numberOfOwners != null) message.numberOfOwners = object.numberOfOwners | 0;
      if (object.numberOfRecords != null) message.numberOfRecords = object.numberOfRecords | 0;
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportMetaData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {Enterprise.ComplianceReportMetaData} message ComplianceReportMetaData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportMetaData.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.reportUid = "";
        else {
          object.reportUid = [];
          if (options.bytes !== Array) object.reportUid = $util.newBuffer(object.reportUid);
        }
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.reportName = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.dateGenerated =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.dateGenerated = options.longs === String ? "0" : 0;
        object.runByName = "";
        object.numberOfOwners = 0;
        object.numberOfRecords = 0;
      }
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        object.reportUid =
          options.bytes === String
            ? $util.base64.encode(message.reportUid, 0, message.reportUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.reportUid)
              : message.reportUid;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        object.reportName = message.reportName;
      if (message.dateGenerated != null && message.hasOwnProperty("dateGenerated"))
        if (typeof message.dateGenerated === "number")
          object.dateGenerated =
            options.longs === String ? String(message.dateGenerated) : message.dateGenerated;
        else
          object.dateGenerated =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.dateGenerated)
              : options.longs === Number
                ? new $util.LongBits(
                    message.dateGenerated.low >>> 0,
                    message.dateGenerated.high >>> 0,
                  ).toNumber()
                : message.dateGenerated;
      if (message.runByName != null && message.hasOwnProperty("runByName"))
        object.runByName = message.runByName;
      if (message.numberOfOwners != null && message.hasOwnProperty("numberOfOwners"))
        object.numberOfOwners = message.numberOfOwners;
      if (message.numberOfRecords != null && message.hasOwnProperty("numberOfRecords"))
        object.numberOfRecords = message.numberOfRecords;
      return object;
    };

    /**
     * Converts this ComplianceReportMetaData to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportMetaData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportMetaData.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportMetaData
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportMetaData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportMetaData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportMetaData";
    };

    return ComplianceReportMetaData;
  })();

  Enterprise.ManagedNode = (function () {
    /**
     * Properties of a ManagedNode.
     * @memberof Enterprise
     * @interface IManagedNode
     * @property {number|Long|null} [roleId] ManagedNode roleId
     * @property {number|Long|null} [managedNodeId] ManagedNode managedNodeId
     * @property {boolean|null} [cascadeNodeManagement] ManagedNode cascadeNodeManagement
     */

    /**
     * Constructs a new ManagedNode.
     * @memberof Enterprise
     * @classdesc Represents a ManagedNode.
     * @implements IManagedNode
     * @constructor
     * @param {Enterprise.IManagedNode=} [properties] Properties to set
     */
    function ManagedNode(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ManagedNode roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.ManagedNode
     * @instance
     */
    ManagedNode.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ManagedNode managedNodeId.
     * @member {number|Long} managedNodeId
     * @memberof Enterprise.ManagedNode
     * @instance
     */
    ManagedNode.prototype.managedNodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ManagedNode cascadeNodeManagement.
     * @member {boolean} cascadeNodeManagement
     * @memberof Enterprise.ManagedNode
     * @instance
     */
    ManagedNode.prototype.cascadeNodeManagement = false;

    /**
     * Creates a new ManagedNode instance using the specified properties.
     * @function create
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Enterprise.IManagedNode=} [properties] Properties to set
     * @returns {Enterprise.ManagedNode} ManagedNode instance
     */
    ManagedNode.create = function create(properties) {
      return new ManagedNode(properties);
    };

    /**
     * Encodes the specified ManagedNode message. Does not implicitly {@link Enterprise.ManagedNode.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Enterprise.IManagedNode} message ManagedNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ManagedNode.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.managedNodeId != null && Object.hasOwnProperty.call(message, "managedNodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.managedNodeId);
      if (
        message.cascadeNodeManagement != null &&
        Object.hasOwnProperty.call(message, "cascadeNodeManagement")
      )
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.cascadeNodeManagement);
      return writer;
    };

    /**
     * Encodes the specified ManagedNode message, length delimited. Does not implicitly {@link Enterprise.ManagedNode.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Enterprise.IManagedNode} message ManagedNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ManagedNode.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ManagedNode message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ManagedNode} ManagedNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ManagedNode.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ManagedNode();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.managedNodeId = reader.int64();
            break;
          }
          case 3: {
            message.cascadeNodeManagement = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ManagedNode message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ManagedNode} ManagedNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ManagedNode.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ManagedNode message.
     * @function verify
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ManagedNode.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.managedNodeId != null && message.hasOwnProperty("managedNodeId"))
        if (
          !$util.isInteger(message.managedNodeId) &&
          !(
            message.managedNodeId &&
            $util.isInteger(message.managedNodeId.low) &&
            $util.isInteger(message.managedNodeId.high)
          )
        )
          return "managedNodeId: integer|Long expected";
      if (message.cascadeNodeManagement != null && message.hasOwnProperty("cascadeNodeManagement"))
        if (typeof message.cascadeNodeManagement !== "boolean")
          return "cascadeNodeManagement: boolean expected";
      return null;
    };

    /**
     * Creates a ManagedNode message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ManagedNode} ManagedNode
     */
    ManagedNode.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ManagedNode) return object;
      let message = new $root.Enterprise.ManagedNode();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.managedNodeId != null)
        if ($util.Long)
          (message.managedNodeId = $util.Long.fromValue(object.managedNodeId)).unsigned = false;
        else if (typeof object.managedNodeId === "string")
          message.managedNodeId = parseInt(object.managedNodeId, 10);
        else if (typeof object.managedNodeId === "number")
          message.managedNodeId = object.managedNodeId;
        else if (typeof object.managedNodeId === "object")
          message.managedNodeId = new $util.LongBits(
            object.managedNodeId.low >>> 0,
            object.managedNodeId.high >>> 0,
          ).toNumber();
      if (object.cascadeNodeManagement != null)
        message.cascadeNodeManagement = Boolean(object.cascadeNodeManagement);
      return message;
    };

    /**
     * Creates a plain object from a ManagedNode message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {Enterprise.ManagedNode} message ManagedNode
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ManagedNode.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.managedNodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.managedNodeId = options.longs === String ? "0" : 0;
        object.cascadeNodeManagement = false;
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.managedNodeId != null && message.hasOwnProperty("managedNodeId"))
        if (typeof message.managedNodeId === "number")
          object.managedNodeId =
            options.longs === String ? String(message.managedNodeId) : message.managedNodeId;
        else
          object.managedNodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.managedNodeId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.managedNodeId.low >>> 0,
                    message.managedNodeId.high >>> 0,
                  ).toNumber()
                : message.managedNodeId;
      if (message.cascadeNodeManagement != null && message.hasOwnProperty("cascadeNodeManagement"))
        object.cascadeNodeManagement = message.cascadeNodeManagement;
      return object;
    };

    /**
     * Converts this ManagedNode to JSON.
     * @function toJSON
     * @memberof Enterprise.ManagedNode
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ManagedNode.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ManagedNode
     * @function getTypeUrl
     * @memberof Enterprise.ManagedNode
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ManagedNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ManagedNode";
    };

    return ManagedNode;
  })();

  Enterprise.UserManagedNode = (function () {
    /**
     * Properties of a UserManagedNode.
     * @memberof Enterprise
     * @interface IUserManagedNode
     * @property {number|Long|null} [nodeId] UserManagedNode nodeId
     * @property {boolean|null} [cascadeNodeManagement] UserManagedNode cascadeNodeManagement
     * @property {Array.<string>|null} [privileges] UserManagedNode privileges
     */

    /**
     * Constructs a new UserManagedNode.
     * @memberof Enterprise
     * @classdesc Represents a UserManagedNode.
     * @implements IUserManagedNode
     * @constructor
     * @param {Enterprise.IUserManagedNode=} [properties] Properties to set
     */
    function UserManagedNode(properties) {
      this.privileges = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserManagedNode nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.UserManagedNode
     * @instance
     */
    UserManagedNode.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserManagedNode cascadeNodeManagement.
     * @member {boolean} cascadeNodeManagement
     * @memberof Enterprise.UserManagedNode
     * @instance
     */
    UserManagedNode.prototype.cascadeNodeManagement = false;

    /**
     * UserManagedNode privileges.
     * @member {Array.<string>} privileges
     * @memberof Enterprise.UserManagedNode
     * @instance
     */
    UserManagedNode.prototype.privileges = $util.emptyArray;

    /**
     * Creates a new UserManagedNode instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Enterprise.IUserManagedNode=} [properties] Properties to set
     * @returns {Enterprise.UserManagedNode} UserManagedNode instance
     */
    UserManagedNode.create = function create(properties) {
      return new UserManagedNode(properties);
    };

    /**
     * Encodes the specified UserManagedNode message. Does not implicitly {@link Enterprise.UserManagedNode.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Enterprise.IUserManagedNode} message UserManagedNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserManagedNode.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.nodeId);
      if (
        message.cascadeNodeManagement != null &&
        Object.hasOwnProperty.call(message, "cascadeNodeManagement")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.cascadeNodeManagement);
      if (message.privileges != null && message.privileges.length)
        for (let i = 0; i < message.privileges.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.privileges[i]);
      return writer;
    };

    /**
     * Encodes the specified UserManagedNode message, length delimited. Does not implicitly {@link Enterprise.UserManagedNode.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Enterprise.IUserManagedNode} message UserManagedNode message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserManagedNode.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserManagedNode message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserManagedNode} UserManagedNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserManagedNode.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserManagedNode();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.nodeId = reader.int64();
            break;
          }
          case 2: {
            message.cascadeNodeManagement = reader.bool();
            break;
          }
          case 3: {
            if (!(message.privileges && message.privileges.length)) message.privileges = [];
            message.privileges.push(reader.string());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserManagedNode message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserManagedNode} UserManagedNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserManagedNode.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserManagedNode message.
     * @function verify
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserManagedNode.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.cascadeNodeManagement != null && message.hasOwnProperty("cascadeNodeManagement"))
        if (typeof message.cascadeNodeManagement !== "boolean")
          return "cascadeNodeManagement: boolean expected";
      if (message.privileges != null && message.hasOwnProperty("privileges")) {
        if (!Array.isArray(message.privileges)) return "privileges: array expected";
        for (let i = 0; i < message.privileges.length; ++i)
          if (!$util.isString(message.privileges[i])) return "privileges: string[] expected";
      }
      return null;
    };

    /**
     * Creates a UserManagedNode message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserManagedNode} UserManagedNode
     */
    UserManagedNode.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserManagedNode) return object;
      let message = new $root.Enterprise.UserManagedNode();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.cascadeNodeManagement != null)
        message.cascadeNodeManagement = Boolean(object.cascadeNodeManagement);
      if (object.privileges) {
        if (!Array.isArray(object.privileges))
          throw TypeError(".Enterprise.UserManagedNode.privileges: array expected");
        message.privileges = [];
        for (let i = 0; i < object.privileges.length; ++i)
          message.privileges[i] = String(object.privileges[i]);
      }
      return message;
    };

    /**
     * Creates a plain object from a UserManagedNode message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {Enterprise.UserManagedNode} message UserManagedNode
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserManagedNode.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.privileges = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.cascadeNodeManagement = false;
      }
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.cascadeNodeManagement != null && message.hasOwnProperty("cascadeNodeManagement"))
        object.cascadeNodeManagement = message.cascadeNodeManagement;
      if (message.privileges && message.privileges.length) {
        object.privileges = [];
        for (let j = 0; j < message.privileges.length; ++j)
          object.privileges[j] = message.privileges[j];
      }
      return object;
    };

    /**
     * Converts this UserManagedNode to JSON.
     * @function toJSON
     * @memberof Enterprise.UserManagedNode
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserManagedNode.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserManagedNode
     * @function getTypeUrl
     * @memberof Enterprise.UserManagedNode
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserManagedNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserManagedNode";
    };

    return UserManagedNode;
  })();

  Enterprise.UserPrivilege = (function () {
    /**
     * Properties of a UserPrivilege.
     * @memberof Enterprise
     * @interface IUserPrivilege
     * @property {Array.<Enterprise.IUserManagedNode>|null} [userManagedNodes] UserPrivilege userManagedNodes
     * @property {number|Long|null} [enterpriseUserId] UserPrivilege enterpriseUserId
     * @property {string|null} [encryptedData] UserPrivilege encryptedData
     */

    /**
     * Constructs a new UserPrivilege.
     * @memberof Enterprise
     * @classdesc Represents a UserPrivilege.
     * @implements IUserPrivilege
     * @constructor
     * @param {Enterprise.IUserPrivilege=} [properties] Properties to set
     */
    function UserPrivilege(properties) {
      this.userManagedNodes = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserPrivilege userManagedNodes.
     * @member {Array.<Enterprise.IUserManagedNode>} userManagedNodes
     * @memberof Enterprise.UserPrivilege
     * @instance
     */
    UserPrivilege.prototype.userManagedNodes = $util.emptyArray;

    /**
     * UserPrivilege enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserPrivilege
     * @instance
     */
    UserPrivilege.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserPrivilege encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.UserPrivilege
     * @instance
     */
    UserPrivilege.prototype.encryptedData = "";

    /**
     * Creates a new UserPrivilege instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Enterprise.IUserPrivilege=} [properties] Properties to set
     * @returns {Enterprise.UserPrivilege} UserPrivilege instance
     */
    UserPrivilege.create = function create(properties) {
      return new UserPrivilege(properties);
    };

    /**
     * Encodes the specified UserPrivilege message. Does not implicitly {@link Enterprise.UserPrivilege.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Enterprise.IUserPrivilege} message UserPrivilege message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserPrivilege.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userManagedNodes != null && message.userManagedNodes.length)
        for (let i = 0; i < message.userManagedNodes.length; ++i)
          $root.Enterprise.UserManagedNode.encode(
            message.userManagedNodes[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.encryptedData);
      return writer;
    };

    /**
     * Encodes the specified UserPrivilege message, length delimited. Does not implicitly {@link Enterprise.UserPrivilege.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Enterprise.IUserPrivilege} message UserPrivilege message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserPrivilege.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserPrivilege message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserPrivilege} UserPrivilege
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserPrivilege.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserPrivilege();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.userManagedNodes && message.userManagedNodes.length))
              message.userManagedNodes = [];
            message.userManagedNodes.push(
              $root.Enterprise.UserManagedNode.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedData = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserPrivilege message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserPrivilege} UserPrivilege
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserPrivilege.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserPrivilege message.
     * @function verify
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserPrivilege.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userManagedNodes != null && message.hasOwnProperty("userManagedNodes")) {
        if (!Array.isArray(message.userManagedNodes)) return "userManagedNodes: array expected";
        for (let i = 0; i < message.userManagedNodes.length; ++i) {
          let error = $root.Enterprise.UserManagedNode.verify(message.userManagedNodes[i]);
          if (error) return "userManagedNodes." + error;
        }
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      return null;
    };

    /**
     * Creates a UserPrivilege message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserPrivilege} UserPrivilege
     */
    UserPrivilege.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserPrivilege) return object;
      let message = new $root.Enterprise.UserPrivilege();
      if (object.userManagedNodes) {
        if (!Array.isArray(object.userManagedNodes))
          throw TypeError(".Enterprise.UserPrivilege.userManagedNodes: array expected");
        message.userManagedNodes = [];
        for (let i = 0; i < object.userManagedNodes.length; ++i) {
          if (typeof object.userManagedNodes[i] !== "object")
            throw TypeError(".Enterprise.UserPrivilege.userManagedNodes: object expected");
          message.userManagedNodes[i] = $root.Enterprise.UserManagedNode.fromObject(
            object.userManagedNodes[i],
          );
        }
      }
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      return message;
    };

    /**
     * Creates a plain object from a UserPrivilege message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {Enterprise.UserPrivilege} message UserPrivilege
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserPrivilege.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.userManagedNodes = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
      }
      if (message.userManagedNodes && message.userManagedNodes.length) {
        object.userManagedNodes = [];
        for (let j = 0; j < message.userManagedNodes.length; ++j)
          object.userManagedNodes[j] = $root.Enterprise.UserManagedNode.toObject(
            message.userManagedNodes[j],
            options,
          );
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      return object;
    };

    /**
     * Converts this UserPrivilege to JSON.
     * @function toJSON
     * @memberof Enterprise.UserPrivilege
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserPrivilege.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserPrivilege
     * @function getTypeUrl
     * @memberof Enterprise.UserPrivilege
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserPrivilege.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserPrivilege";
    };

    return UserPrivilege;
  })();

  Enterprise.RoleUser = (function () {
    /**
     * Properties of a RoleUser.
     * @memberof Enterprise
     * @interface IRoleUser
     * @property {number|Long|null} [roleId] RoleUser roleId
     * @property {number|Long|null} [enterpriseUserId] RoleUser enterpriseUserId
     */

    /**
     * Constructs a new RoleUser.
     * @memberof Enterprise
     * @classdesc Represents a RoleUser.
     * @implements IRoleUser
     * @constructor
     * @param {Enterprise.IRoleUser=} [properties] Properties to set
     */
    function RoleUser(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleUser roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleUser
     * @instance
     */
    RoleUser.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleUser enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.RoleUser
     * @instance
     */
    RoleUser.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Creates a new RoleUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Enterprise.IRoleUser=} [properties] Properties to set
     * @returns {Enterprise.RoleUser} RoleUser instance
     */
    RoleUser.create = function create(properties) {
      return new RoleUser(properties);
    };

    /**
     * Encodes the specified RoleUser message. Does not implicitly {@link Enterprise.RoleUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Enterprise.IRoleUser} message RoleUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      return writer;
    };

    /**
     * Encodes the specified RoleUser message, length delimited. Does not implicitly {@link Enterprise.RoleUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Enterprise.IRoleUser} message RoleUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleUser} RoleUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleUser} RoleUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleUser message.
     * @function verify
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      return null;
    };

    /**
     * Creates a RoleUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleUser} RoleUser
     */
    RoleUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleUser) return object;
      let message = new $root.Enterprise.RoleUser();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      return message;
    };

    /**
     * Creates a plain object from a RoleUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleUser
     * @static
     * @param {Enterprise.RoleUser} message RoleUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      return object;
    };

    /**
     * Converts this RoleUser to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleUser
     * @function getTypeUrl
     * @memberof Enterprise.RoleUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleUser";
    };

    return RoleUser;
  })();

  Enterprise.RolePrivilege = (function () {
    /**
     * Properties of a RolePrivilege.
     * @memberof Enterprise
     * @interface IRolePrivilege
     * @property {number|Long|null} [managedNodeId] RolePrivilege managedNodeId
     * @property {number|Long|null} [roleId] RolePrivilege roleId
     * @property {string|null} [privilegeType] RolePrivilege privilegeType
     */

    /**
     * Constructs a new RolePrivilege.
     * @memberof Enterprise
     * @classdesc Represents a RolePrivilege.
     * @implements IRolePrivilege
     * @constructor
     * @param {Enterprise.IRolePrivilege=} [properties] Properties to set
     */
    function RolePrivilege(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RolePrivilege managedNodeId.
     * @member {number|Long} managedNodeId
     * @memberof Enterprise.RolePrivilege
     * @instance
     */
    RolePrivilege.prototype.managedNodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RolePrivilege roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RolePrivilege
     * @instance
     */
    RolePrivilege.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RolePrivilege privilegeType.
     * @member {string} privilegeType
     * @memberof Enterprise.RolePrivilege
     * @instance
     */
    RolePrivilege.prototype.privilegeType = "";

    /**
     * Creates a new RolePrivilege instance using the specified properties.
     * @function create
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Enterprise.IRolePrivilege=} [properties] Properties to set
     * @returns {Enterprise.RolePrivilege} RolePrivilege instance
     */
    RolePrivilege.create = function create(properties) {
      return new RolePrivilege(properties);
    };

    /**
     * Encodes the specified RolePrivilege message. Does not implicitly {@link Enterprise.RolePrivilege.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Enterprise.IRolePrivilege} message RolePrivilege message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RolePrivilege.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.managedNodeId != null && Object.hasOwnProperty.call(message, "managedNodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.managedNodeId);
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.roleId);
      if (message.privilegeType != null && Object.hasOwnProperty.call(message, "privilegeType"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.privilegeType);
      return writer;
    };

    /**
     * Encodes the specified RolePrivilege message, length delimited. Does not implicitly {@link Enterprise.RolePrivilege.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Enterprise.IRolePrivilege} message RolePrivilege message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RolePrivilege.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RolePrivilege message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RolePrivilege} RolePrivilege
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RolePrivilege.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RolePrivilege();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.managedNodeId = reader.int64();
            break;
          }
          case 2: {
            message.roleId = reader.int64();
            break;
          }
          case 3: {
            message.privilegeType = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RolePrivilege message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RolePrivilege} RolePrivilege
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RolePrivilege.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RolePrivilege message.
     * @function verify
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RolePrivilege.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.managedNodeId != null && message.hasOwnProperty("managedNodeId"))
        if (
          !$util.isInteger(message.managedNodeId) &&
          !(
            message.managedNodeId &&
            $util.isInteger(message.managedNodeId.low) &&
            $util.isInteger(message.managedNodeId.high)
          )
        )
          return "managedNodeId: integer|Long expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.privilegeType != null && message.hasOwnProperty("privilegeType"))
        if (!$util.isString(message.privilegeType)) return "privilegeType: string expected";
      return null;
    };

    /**
     * Creates a RolePrivilege message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RolePrivilege} RolePrivilege
     */
    RolePrivilege.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RolePrivilege) return object;
      let message = new $root.Enterprise.RolePrivilege();
      if (object.managedNodeId != null)
        if ($util.Long)
          (message.managedNodeId = $util.Long.fromValue(object.managedNodeId)).unsigned = false;
        else if (typeof object.managedNodeId === "string")
          message.managedNodeId = parseInt(object.managedNodeId, 10);
        else if (typeof object.managedNodeId === "number")
          message.managedNodeId = object.managedNodeId;
        else if (typeof object.managedNodeId === "object")
          message.managedNodeId = new $util.LongBits(
            object.managedNodeId.low >>> 0,
            object.managedNodeId.high >>> 0,
          ).toNumber();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.privilegeType != null) message.privilegeType = String(object.privilegeType);
      return message;
    };

    /**
     * Creates a plain object from a RolePrivilege message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {Enterprise.RolePrivilege} message RolePrivilege
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RolePrivilege.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.managedNodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.managedNodeId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        object.privilegeType = "";
      }
      if (message.managedNodeId != null && message.hasOwnProperty("managedNodeId"))
        if (typeof message.managedNodeId === "number")
          object.managedNodeId =
            options.longs === String ? String(message.managedNodeId) : message.managedNodeId;
        else
          object.managedNodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.managedNodeId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.managedNodeId.low >>> 0,
                    message.managedNodeId.high >>> 0,
                  ).toNumber()
                : message.managedNodeId;
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.privilegeType != null && message.hasOwnProperty("privilegeType"))
        object.privilegeType = message.privilegeType;
      return object;
    };

    /**
     * Converts this RolePrivilege to JSON.
     * @function toJSON
     * @memberof Enterprise.RolePrivilege
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RolePrivilege.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RolePrivilege
     * @function getTypeUrl
     * @memberof Enterprise.RolePrivilege
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RolePrivilege.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RolePrivilege";
    };

    return RolePrivilege;
  })();

  Enterprise.RoleEnforcement = (function () {
    /**
     * Properties of a RoleEnforcement.
     * @memberof Enterprise
     * @interface IRoleEnforcement
     * @property {number|Long|null} [roleId] RoleEnforcement roleId
     * @property {string|null} [enforcementType] RoleEnforcement enforcementType
     * @property {string|null} [value] RoleEnforcement value
     */

    /**
     * Constructs a new RoleEnforcement.
     * @memberof Enterprise
     * @classdesc Represents a RoleEnforcement.
     * @implements IRoleEnforcement
     * @constructor
     * @param {Enterprise.IRoleEnforcement=} [properties] Properties to set
     */
    function RoleEnforcement(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleEnforcement roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleEnforcement
     * @instance
     */
    RoleEnforcement.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleEnforcement enforcementType.
     * @member {string} enforcementType
     * @memberof Enterprise.RoleEnforcement
     * @instance
     */
    RoleEnforcement.prototype.enforcementType = "";

    /**
     * RoleEnforcement value.
     * @member {string} value
     * @memberof Enterprise.RoleEnforcement
     * @instance
     */
    RoleEnforcement.prototype.value = "";

    /**
     * Creates a new RoleEnforcement instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Enterprise.IRoleEnforcement=} [properties] Properties to set
     * @returns {Enterprise.RoleEnforcement} RoleEnforcement instance
     */
    RoleEnforcement.create = function create(properties) {
      return new RoleEnforcement(properties);
    };

    /**
     * Encodes the specified RoleEnforcement message. Does not implicitly {@link Enterprise.RoleEnforcement.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Enterprise.IRoleEnforcement} message RoleEnforcement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleEnforcement.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.enforcementType != null && Object.hasOwnProperty.call(message, "enforcementType"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.enforcementType);
      if (message.value != null && Object.hasOwnProperty.call(message, "value"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.value);
      return writer;
    };

    /**
     * Encodes the specified RoleEnforcement message, length delimited. Does not implicitly {@link Enterprise.RoleEnforcement.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Enterprise.IRoleEnforcement} message RoleEnforcement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleEnforcement.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleEnforcement message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleEnforcement} RoleEnforcement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleEnforcement.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleEnforcement();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.enforcementType = reader.string();
            break;
          }
          case 3: {
            message.value = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleEnforcement message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleEnforcement} RoleEnforcement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleEnforcement.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleEnforcement message.
     * @function verify
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleEnforcement.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.enforcementType != null && message.hasOwnProperty("enforcementType"))
        if (!$util.isString(message.enforcementType)) return "enforcementType: string expected";
      if (message.value != null && message.hasOwnProperty("value"))
        if (!$util.isString(message.value)) return "value: string expected";
      return null;
    };

    /**
     * Creates a RoleEnforcement message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleEnforcement} RoleEnforcement
     */
    RoleEnforcement.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleEnforcement) return object;
      let message = new $root.Enterprise.RoleEnforcement();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.enforcementType != null) message.enforcementType = String(object.enforcementType);
      if (object.value != null) message.value = String(object.value);
      return message;
    };

    /**
     * Creates a plain object from a RoleEnforcement message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {Enterprise.RoleEnforcement} message RoleEnforcement
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleEnforcement.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        object.enforcementType = "";
        object.value = "";
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.enforcementType != null && message.hasOwnProperty("enforcementType"))
        object.enforcementType = message.enforcementType;
      if (message.value != null && message.hasOwnProperty("value")) object.value = message.value;
      return object;
    };

    /**
     * Converts this RoleEnforcement to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleEnforcement
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleEnforcement.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleEnforcement
     * @function getTypeUrl
     * @memberof Enterprise.RoleEnforcement
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleEnforcement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleEnforcement";
    };

    return RoleEnforcement;
  })();

  Enterprise.Team = (function () {
    /**
     * Properties of a Team.
     * @memberof Enterprise
     * @interface ITeam
     * @property {Uint8Array|null} [teamUid] Team teamUid
     * @property {string|null} [name] Team name
     * @property {number|Long|null} [nodeId] Team nodeId
     * @property {boolean|null} [restrictEdit] Team restrictEdit
     * @property {boolean|null} [restrictShare] Team restrictShare
     * @property {boolean|null} [restrictView] Team restrictView
     * @property {string|null} [encryptedData] Team encryptedData
     * @property {string|null} [encryptedTeamKey] Team encryptedTeamKey
     */

    /**
     * Constructs a new Team.
     * @memberof Enterprise
     * @classdesc Represents a Team.
     * @implements ITeam
     * @constructor
     * @param {Enterprise.ITeam=} [properties] Properties to set
     */
    function Team(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Team teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.teamUid = $util.newBuffer([]);

    /**
     * Team name.
     * @member {string} name
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.name = "";

    /**
     * Team nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Team restrictEdit.
     * @member {boolean} restrictEdit
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.restrictEdit = false;

    /**
     * Team restrictShare.
     * @member {boolean} restrictShare
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.restrictShare = false;

    /**
     * Team restrictView.
     * @member {boolean} restrictView
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.restrictView = false;

    /**
     * Team encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.encryptedData = "";

    /**
     * Team encryptedTeamKey.
     * @member {string} encryptedTeamKey
     * @memberof Enterprise.Team
     * @instance
     */
    Team.prototype.encryptedTeamKey = "";

    /**
     * Creates a new Team instance using the specified properties.
     * @function create
     * @memberof Enterprise.Team
     * @static
     * @param {Enterprise.ITeam=} [properties] Properties to set
     * @returns {Enterprise.Team} Team instance
     */
    Team.create = function create(properties) {
      return new Team(properties);
    };

    /**
     * Encodes the specified Team message. Does not implicitly {@link Enterprise.Team.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Team
     * @static
     * @param {Enterprise.ITeam} message Team message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Team.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.nodeId);
      if (message.restrictEdit != null && Object.hasOwnProperty.call(message, "restrictEdit"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.restrictEdit);
      if (message.restrictShare != null && Object.hasOwnProperty.call(message, "restrictShare"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.restrictShare);
      if (message.restrictView != null && Object.hasOwnProperty.call(message, "restrictView"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.restrictView);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.encryptedData);
      if (
        message.encryptedTeamKey != null &&
        Object.hasOwnProperty.call(message, "encryptedTeamKey")
      )
        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.encryptedTeamKey);
      return writer;
    };

    /**
     * Encodes the specified Team message, length delimited. Does not implicitly {@link Enterprise.Team.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Team
     * @static
     * @param {Enterprise.ITeam} message Team message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Team.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Team message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Team
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Team} Team
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Team.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Team();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            message.name = reader.string();
            break;
          }
          case 3: {
            message.nodeId = reader.int64();
            break;
          }
          case 4: {
            message.restrictEdit = reader.bool();
            break;
          }
          case 5: {
            message.restrictShare = reader.bool();
            break;
          }
          case 6: {
            message.restrictView = reader.bool();
            break;
          }
          case 7: {
            message.encryptedData = reader.string();
            break;
          }
          case 8: {
            message.encryptedTeamKey = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Team message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Team
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Team} Team
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Team.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Team message.
     * @function verify
     * @memberof Enterprise.Team
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Team.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.restrictEdit != null && message.hasOwnProperty("restrictEdit"))
        if (typeof message.restrictEdit !== "boolean") return "restrictEdit: boolean expected";
      if (message.restrictShare != null && message.hasOwnProperty("restrictShare"))
        if (typeof message.restrictShare !== "boolean") return "restrictShare: boolean expected";
      if (message.restrictView != null && message.hasOwnProperty("restrictView"))
        if (typeof message.restrictView !== "boolean") return "restrictView: boolean expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
        if (!$util.isString(message.encryptedTeamKey)) return "encryptedTeamKey: string expected";
      return null;
    };

    /**
     * Creates a Team message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Team
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Team} Team
     */
    Team.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Team) return object;
      let message = new $root.Enterprise.Team();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.name != null) message.name = String(object.name);
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.restrictEdit != null) message.restrictEdit = Boolean(object.restrictEdit);
      if (object.restrictShare != null) message.restrictShare = Boolean(object.restrictShare);
      if (object.restrictView != null) message.restrictView = Boolean(object.restrictView);
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      if (object.encryptedTeamKey != null)
        message.encryptedTeamKey = String(object.encryptedTeamKey);
      return message;
    };

    /**
     * Creates a plain object from a Team message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Team
     * @static
     * @param {Enterprise.Team} message Team
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Team.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        object.name = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.restrictEdit = false;
        object.restrictShare = false;
        object.restrictView = false;
        object.encryptedData = "";
        object.encryptedTeamKey = "";
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.restrictEdit != null && message.hasOwnProperty("restrictEdit"))
        object.restrictEdit = message.restrictEdit;
      if (message.restrictShare != null && message.hasOwnProperty("restrictShare"))
        object.restrictShare = message.restrictShare;
      if (message.restrictView != null && message.hasOwnProperty("restrictView"))
        object.restrictView = message.restrictView;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
        object.encryptedTeamKey = message.encryptedTeamKey;
      return object;
    };

    /**
     * Converts this Team to JSON.
     * @function toJSON
     * @memberof Enterprise.Team
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Team.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Team
     * @function getTypeUrl
     * @memberof Enterprise.Team
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Team.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Team";
    };

    return Team;
  })();

  Enterprise.TeamUser = (function () {
    /**
     * Properties of a TeamUser.
     * @memberof Enterprise
     * @interface ITeamUser
     * @property {Uint8Array|null} [teamUid] TeamUser teamUid
     * @property {number|Long|null} [enterpriseUserId] TeamUser enterpriseUserId
     * @property {string|null} [userType] TeamUser userType
     */

    /**
     * Constructs a new TeamUser.
     * @memberof Enterprise
     * @classdesc Represents a TeamUser.
     * @implements ITeamUser
     * @constructor
     * @param {Enterprise.ITeamUser=} [properties] Properties to set
     */
    function TeamUser(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamUser teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.TeamUser
     * @instance
     */
    TeamUser.prototype.teamUid = $util.newBuffer([]);

    /**
     * TeamUser enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.TeamUser
     * @instance
     */
    TeamUser.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * TeamUser userType.
     * @member {string} userType
     * @memberof Enterprise.TeamUser
     * @instance
     */
    TeamUser.prototype.userType = "";

    /**
     * Creates a new TeamUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Enterprise.ITeamUser=} [properties] Properties to set
     * @returns {Enterprise.TeamUser} TeamUser instance
     */
    TeamUser.create = function create(properties) {
      return new TeamUser(properties);
    };

    /**
     * Encodes the specified TeamUser message. Does not implicitly {@link Enterprise.TeamUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Enterprise.ITeamUser} message TeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.userType);
      return writer;
    };

    /**
     * Encodes the specified TeamUser message, length delimited. Does not implicitly {@link Enterprise.TeamUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Enterprise.ITeamUser} message TeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamUser} TeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 3: {
            message.userType = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamUser} TeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamUser message.
     * @function verify
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.userType != null && message.hasOwnProperty("userType"))
        if (!$util.isString(message.userType)) return "userType: string expected";
      return null;
    };

    /**
     * Creates a TeamUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamUser} TeamUser
     */
    TeamUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamUser) return object;
      let message = new $root.Enterprise.TeamUser();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.userType != null) message.userType = String(object.userType);
      return message;
    };

    /**
     * Creates a plain object from a TeamUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamUser
     * @static
     * @param {Enterprise.TeamUser} message TeamUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.userType = "";
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.userType != null && message.hasOwnProperty("userType"))
        object.userType = message.userType;
      return object;
    };

    /**
     * Converts this TeamUser to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamUser
     * @function getTypeUrl
     * @memberof Enterprise.TeamUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamUser";
    };

    return TeamUser;
  })();

  Enterprise.GetDistributorInfoResponse = (function () {
    /**
     * Properties of a GetDistributorInfoResponse.
     * @memberof Enterprise
     * @interface IGetDistributorInfoResponse
     * @property {Array.<Enterprise.IDistributor>|null} [distributors] GetDistributorInfoResponse distributors
     */

    /**
     * Constructs a new GetDistributorInfoResponse.
     * @memberof Enterprise
     * @classdesc Represents a GetDistributorInfoResponse.
     * @implements IGetDistributorInfoResponse
     * @constructor
     * @param {Enterprise.IGetDistributorInfoResponse=} [properties] Properties to set
     */
    function GetDistributorInfoResponse(properties) {
      this.distributors = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetDistributorInfoResponse distributors.
     * @member {Array.<Enterprise.IDistributor>} distributors
     * @memberof Enterprise.GetDistributorInfoResponse
     * @instance
     */
    GetDistributorInfoResponse.prototype.distributors = $util.emptyArray;

    /**
     * Creates a new GetDistributorInfoResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Enterprise.IGetDistributorInfoResponse=} [properties] Properties to set
     * @returns {Enterprise.GetDistributorInfoResponse} GetDistributorInfoResponse instance
     */
    GetDistributorInfoResponse.create = function create(properties) {
      return new GetDistributorInfoResponse(properties);
    };

    /**
     * Encodes the specified GetDistributorInfoResponse message. Does not implicitly {@link Enterprise.GetDistributorInfoResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Enterprise.IGetDistributorInfoResponse} message GetDistributorInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetDistributorInfoResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.distributors != null && message.distributors.length)
        for (let i = 0; i < message.distributors.length; ++i)
          $root.Enterprise.Distributor.encode(
            message.distributors[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified GetDistributorInfoResponse message, length delimited. Does not implicitly {@link Enterprise.GetDistributorInfoResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Enterprise.IGetDistributorInfoResponse} message GetDistributorInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetDistributorInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetDistributorInfoResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetDistributorInfoResponse} GetDistributorInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetDistributorInfoResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetDistributorInfoResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.distributors && message.distributors.length)) message.distributors = [];
            message.distributors.push($root.Enterprise.Distributor.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetDistributorInfoResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetDistributorInfoResponse} GetDistributorInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetDistributorInfoResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetDistributorInfoResponse message.
     * @function verify
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetDistributorInfoResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.distributors != null && message.hasOwnProperty("distributors")) {
        if (!Array.isArray(message.distributors)) return "distributors: array expected";
        for (let i = 0; i < message.distributors.length; ++i) {
          let error = $root.Enterprise.Distributor.verify(message.distributors[i]);
          if (error) return "distributors." + error;
        }
      }
      return null;
    };

    /**
     * Creates a GetDistributorInfoResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetDistributorInfoResponse} GetDistributorInfoResponse
     */
    GetDistributorInfoResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetDistributorInfoResponse) return object;
      let message = new $root.Enterprise.GetDistributorInfoResponse();
      if (object.distributors) {
        if (!Array.isArray(object.distributors))
          throw TypeError(".Enterprise.GetDistributorInfoResponse.distributors: array expected");
        message.distributors = [];
        for (let i = 0; i < object.distributors.length; ++i) {
          if (typeof object.distributors[i] !== "object")
            throw TypeError(".Enterprise.GetDistributorInfoResponse.distributors: object expected");
          message.distributors[i] = $root.Enterprise.Distributor.fromObject(object.distributors[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a GetDistributorInfoResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {Enterprise.GetDistributorInfoResponse} message GetDistributorInfoResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetDistributorInfoResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.distributors = [];
      if (message.distributors && message.distributors.length) {
        object.distributors = [];
        for (let j = 0; j < message.distributors.length; ++j)
          object.distributors[j] = $root.Enterprise.Distributor.toObject(
            message.distributors[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this GetDistributorInfoResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.GetDistributorInfoResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetDistributorInfoResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetDistributorInfoResponse
     * @function getTypeUrl
     * @memberof Enterprise.GetDistributorInfoResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetDistributorInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetDistributorInfoResponse";
    };

    return GetDistributorInfoResponse;
  })();

  Enterprise.Distributor = (function () {
    /**
     * Properties of a Distributor.
     * @memberof Enterprise
     * @interface IDistributor
     * @property {string|null} [name] Distributor name
     * @property {Array.<Enterprise.IMspInfo>|null} [mspInfos] Distributor mspInfos
     */

    /**
     * Constructs a new Distributor.
     * @memberof Enterprise
     * @classdesc Represents a Distributor.
     * @implements IDistributor
     * @constructor
     * @param {Enterprise.IDistributor=} [properties] Properties to set
     */
    function Distributor(properties) {
      this.mspInfos = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Distributor name.
     * @member {string} name
     * @memberof Enterprise.Distributor
     * @instance
     */
    Distributor.prototype.name = "";

    /**
     * Distributor mspInfos.
     * @member {Array.<Enterprise.IMspInfo>} mspInfos
     * @memberof Enterprise.Distributor
     * @instance
     */
    Distributor.prototype.mspInfos = $util.emptyArray;

    /**
     * Creates a new Distributor instance using the specified properties.
     * @function create
     * @memberof Enterprise.Distributor
     * @static
     * @param {Enterprise.IDistributor=} [properties] Properties to set
     * @returns {Enterprise.Distributor} Distributor instance
     */
    Distributor.create = function create(properties) {
      return new Distributor(properties);
    };

    /**
     * Encodes the specified Distributor message. Does not implicitly {@link Enterprise.Distributor.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Distributor
     * @static
     * @param {Enterprise.IDistributor} message Distributor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Distributor.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
      if (message.mspInfos != null && message.mspInfos.length)
        for (let i = 0; i < message.mspInfos.length; ++i)
          $root.Enterprise.MspInfo.encode(
            message.mspInfos[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified Distributor message, length delimited. Does not implicitly {@link Enterprise.Distributor.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Distributor
     * @static
     * @param {Enterprise.IDistributor} message Distributor message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Distributor.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Distributor message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Distributor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Distributor} Distributor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Distributor.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Distributor();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.name = reader.string();
            break;
          }
          case 2: {
            if (!(message.mspInfos && message.mspInfos.length)) message.mspInfos = [];
            message.mspInfos.push($root.Enterprise.MspInfo.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Distributor message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Distributor
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Distributor} Distributor
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Distributor.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Distributor message.
     * @function verify
     * @memberof Enterprise.Distributor
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Distributor.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.mspInfos != null && message.hasOwnProperty("mspInfos")) {
        if (!Array.isArray(message.mspInfos)) return "mspInfos: array expected";
        for (let i = 0; i < message.mspInfos.length; ++i) {
          let error = $root.Enterprise.MspInfo.verify(message.mspInfos[i]);
          if (error) return "mspInfos." + error;
        }
      }
      return null;
    };

    /**
     * Creates a Distributor message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Distributor
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Distributor} Distributor
     */
    Distributor.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Distributor) return object;
      let message = new $root.Enterprise.Distributor();
      if (object.name != null) message.name = String(object.name);
      if (object.mspInfos) {
        if (!Array.isArray(object.mspInfos))
          throw TypeError(".Enterprise.Distributor.mspInfos: array expected");
        message.mspInfos = [];
        for (let i = 0; i < object.mspInfos.length; ++i) {
          if (typeof object.mspInfos[i] !== "object")
            throw TypeError(".Enterprise.Distributor.mspInfos: object expected");
          message.mspInfos[i] = $root.Enterprise.MspInfo.fromObject(object.mspInfos[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a Distributor message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Distributor
     * @static
     * @param {Enterprise.Distributor} message Distributor
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Distributor.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.mspInfos = [];
      if (options.defaults) object.name = "";
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.mspInfos && message.mspInfos.length) {
        object.mspInfos = [];
        for (let j = 0; j < message.mspInfos.length; ++j)
          object.mspInfos[j] = $root.Enterprise.MspInfo.toObject(message.mspInfos[j], options);
      }
      return object;
    };

    /**
     * Converts this Distributor to JSON.
     * @function toJSON
     * @memberof Enterprise.Distributor
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Distributor.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Distributor
     * @function getTypeUrl
     * @memberof Enterprise.Distributor
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Distributor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Distributor";
    };

    return Distributor;
  })();

  Enterprise.MspInfo = (function () {
    /**
     * Properties of a MspInfo.
     * @memberof Enterprise
     * @interface IMspInfo
     * @property {number|null} [enterpriseId] MspInfo enterpriseId
     * @property {string|null} [enterpriseName] MspInfo enterpriseName
     * @property {number|null} [allocatedLicenses] MspInfo allocatedLicenses
     * @property {Array.<string>|null} [allowedMcProducts] MspInfo allowedMcProducts
     * @property {Array.<string>|null} [allowedAddOns] MspInfo allowedAddOns
     * @property {string|null} [maxFilePlanType] MspInfo maxFilePlanType
     * @property {Array.<Enterprise.IManagedCompany>|null} [managedCompanies] MspInfo managedCompanies
     * @property {boolean|null} [allowUnlimitedLicenses] MspInfo allowUnlimitedLicenses
     * @property {Array.<Enterprise.ILicenseAddOn>|null} [addOns] MspInfo addOns
     */

    /**
     * Constructs a new MspInfo.
     * @memberof Enterprise
     * @classdesc Represents a MspInfo.
     * @implements IMspInfo
     * @constructor
     * @param {Enterprise.IMspInfo=} [properties] Properties to set
     */
    function MspInfo(properties) {
      this.allowedMcProducts = [];
      this.allowedAddOns = [];
      this.managedCompanies = [];
      this.addOns = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MspInfo enterpriseId.
     * @member {number} enterpriseId
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.enterpriseId = 0;

    /**
     * MspInfo enterpriseName.
     * @member {string} enterpriseName
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.enterpriseName = "";

    /**
     * MspInfo allocatedLicenses.
     * @member {number} allocatedLicenses
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.allocatedLicenses = 0;

    /**
     * MspInfo allowedMcProducts.
     * @member {Array.<string>} allowedMcProducts
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.allowedMcProducts = $util.emptyArray;

    /**
     * MspInfo allowedAddOns.
     * @member {Array.<string>} allowedAddOns
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.allowedAddOns = $util.emptyArray;

    /**
     * MspInfo maxFilePlanType.
     * @member {string} maxFilePlanType
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.maxFilePlanType = "";

    /**
     * MspInfo managedCompanies.
     * @member {Array.<Enterprise.IManagedCompany>} managedCompanies
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.managedCompanies = $util.emptyArray;

    /**
     * MspInfo allowUnlimitedLicenses.
     * @member {boolean} allowUnlimitedLicenses
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.allowUnlimitedLicenses = false;

    /**
     * MspInfo addOns.
     * @member {Array.<Enterprise.ILicenseAddOn>} addOns
     * @memberof Enterprise.MspInfo
     * @instance
     */
    MspInfo.prototype.addOns = $util.emptyArray;

    /**
     * Creates a new MspInfo instance using the specified properties.
     * @function create
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Enterprise.IMspInfo=} [properties] Properties to set
     * @returns {Enterprise.MspInfo} MspInfo instance
     */
    MspInfo.create = function create(properties) {
      return new MspInfo(properties);
    };

    /**
     * Encodes the specified MspInfo message. Does not implicitly {@link Enterprise.MspInfo.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Enterprise.IMspInfo} message MspInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MspInfo.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseId != null && Object.hasOwnProperty.call(message, "enterpriseId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.enterpriseId);
      if (message.enterpriseName != null && Object.hasOwnProperty.call(message, "enterpriseName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.enterpriseName);
      if (
        message.allocatedLicenses != null &&
        Object.hasOwnProperty.call(message, "allocatedLicenses")
      )
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.allocatedLicenses);
      if (message.allowedMcProducts != null && message.allowedMcProducts.length)
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.allowedMcProducts[i]);
      if (message.allowedAddOns != null && message.allowedAddOns.length)
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.allowedAddOns[i]);
      if (message.maxFilePlanType != null && Object.hasOwnProperty.call(message, "maxFilePlanType"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.maxFilePlanType);
      if (message.managedCompanies != null && message.managedCompanies.length)
        for (let i = 0; i < message.managedCompanies.length; ++i)
          $root.Enterprise.ManagedCompany.encode(
            message.managedCompanies[i],
            writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
          ).ldelim();
      if (
        message.allowUnlimitedLicenses != null &&
        Object.hasOwnProperty.call(message, "allowUnlimitedLicenses")
      )
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.allowUnlimitedLicenses);
      if (message.addOns != null && message.addOns.length)
        for (let i = 0; i < message.addOns.length; ++i)
          $root.Enterprise.LicenseAddOn.encode(
            message.addOns[i],
            writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified MspInfo message, length delimited. Does not implicitly {@link Enterprise.MspInfo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Enterprise.IMspInfo} message MspInfo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MspInfo.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MspInfo message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MspInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MspInfo} MspInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MspInfo.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MspInfo();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseId = reader.int32();
            break;
          }
          case 2: {
            message.enterpriseName = reader.string();
            break;
          }
          case 3: {
            message.allocatedLicenses = reader.int32();
            break;
          }
          case 4: {
            if (!(message.allowedMcProducts && message.allowedMcProducts.length))
              message.allowedMcProducts = [];
            message.allowedMcProducts.push(reader.string());
            break;
          }
          case 5: {
            if (!(message.allowedAddOns && message.allowedAddOns.length))
              message.allowedAddOns = [];
            message.allowedAddOns.push(reader.string());
            break;
          }
          case 6: {
            message.maxFilePlanType = reader.string();
            break;
          }
          case 7: {
            if (!(message.managedCompanies && message.managedCompanies.length))
              message.managedCompanies = [];
            message.managedCompanies.push(
              $root.Enterprise.ManagedCompany.decode(reader, reader.uint32()),
            );
            break;
          }
          case 8: {
            message.allowUnlimitedLicenses = reader.bool();
            break;
          }
          case 9: {
            if (!(message.addOns && message.addOns.length)) message.addOns = [];
            message.addOns.push($root.Enterprise.LicenseAddOn.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MspInfo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MspInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MspInfo} MspInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MspInfo.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MspInfo message.
     * @function verify
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MspInfo.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
        if (!$util.isInteger(message.enterpriseId)) return "enterpriseId: integer expected";
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        if (!$util.isString(message.enterpriseName)) return "enterpriseName: string expected";
      if (message.allocatedLicenses != null && message.hasOwnProperty("allocatedLicenses"))
        if (!$util.isInteger(message.allocatedLicenses))
          return "allocatedLicenses: integer expected";
      if (message.allowedMcProducts != null && message.hasOwnProperty("allowedMcProducts")) {
        if (!Array.isArray(message.allowedMcProducts)) return "allowedMcProducts: array expected";
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          if (!$util.isString(message.allowedMcProducts[i]))
            return "allowedMcProducts: string[] expected";
      }
      if (message.allowedAddOns != null && message.hasOwnProperty("allowedAddOns")) {
        if (!Array.isArray(message.allowedAddOns)) return "allowedAddOns: array expected";
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          if (!$util.isString(message.allowedAddOns[i])) return "allowedAddOns: string[] expected";
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        if (!$util.isString(message.maxFilePlanType)) return "maxFilePlanType: string expected";
      if (message.managedCompanies != null && message.hasOwnProperty("managedCompanies")) {
        if (!Array.isArray(message.managedCompanies)) return "managedCompanies: array expected";
        for (let i = 0; i < message.managedCompanies.length; ++i) {
          let error = $root.Enterprise.ManagedCompany.verify(message.managedCompanies[i]);
          if (error) return "managedCompanies." + error;
        }
      }
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        if (typeof message.allowUnlimitedLicenses !== "boolean")
          return "allowUnlimitedLicenses: boolean expected";
      if (message.addOns != null && message.hasOwnProperty("addOns")) {
        if (!Array.isArray(message.addOns)) return "addOns: array expected";
        for (let i = 0; i < message.addOns.length; ++i) {
          let error = $root.Enterprise.LicenseAddOn.verify(message.addOns[i]);
          if (error) return "addOns." + error;
        }
      }
      return null;
    };

    /**
     * Creates a MspInfo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MspInfo} MspInfo
     */
    MspInfo.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MspInfo) return object;
      let message = new $root.Enterprise.MspInfo();
      if (object.enterpriseId != null) message.enterpriseId = object.enterpriseId | 0;
      if (object.enterpriseName != null) message.enterpriseName = String(object.enterpriseName);
      if (object.allocatedLicenses != null)
        message.allocatedLicenses = object.allocatedLicenses | 0;
      if (object.allowedMcProducts) {
        if (!Array.isArray(object.allowedMcProducts))
          throw TypeError(".Enterprise.MspInfo.allowedMcProducts: array expected");
        message.allowedMcProducts = [];
        for (let i = 0; i < object.allowedMcProducts.length; ++i)
          message.allowedMcProducts[i] = String(object.allowedMcProducts[i]);
      }
      if (object.allowedAddOns) {
        if (!Array.isArray(object.allowedAddOns))
          throw TypeError(".Enterprise.MspInfo.allowedAddOns: array expected");
        message.allowedAddOns = [];
        for (let i = 0; i < object.allowedAddOns.length; ++i)
          message.allowedAddOns[i] = String(object.allowedAddOns[i]);
      }
      if (object.maxFilePlanType != null) message.maxFilePlanType = String(object.maxFilePlanType);
      if (object.managedCompanies) {
        if (!Array.isArray(object.managedCompanies))
          throw TypeError(".Enterprise.MspInfo.managedCompanies: array expected");
        message.managedCompanies = [];
        for (let i = 0; i < object.managedCompanies.length; ++i) {
          if (typeof object.managedCompanies[i] !== "object")
            throw TypeError(".Enterprise.MspInfo.managedCompanies: object expected");
          message.managedCompanies[i] = $root.Enterprise.ManagedCompany.fromObject(
            object.managedCompanies[i],
          );
        }
      }
      if (object.allowUnlimitedLicenses != null)
        message.allowUnlimitedLicenses = Boolean(object.allowUnlimitedLicenses);
      if (object.addOns) {
        if (!Array.isArray(object.addOns))
          throw TypeError(".Enterprise.MspInfo.addOns: array expected");
        message.addOns = [];
        for (let i = 0; i < object.addOns.length; ++i) {
          if (typeof object.addOns[i] !== "object")
            throw TypeError(".Enterprise.MspInfo.addOns: object expected");
          message.addOns[i] = $root.Enterprise.LicenseAddOn.fromObject(object.addOns[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a MspInfo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MspInfo
     * @static
     * @param {Enterprise.MspInfo} message MspInfo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MspInfo.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.allowedMcProducts = [];
        object.allowedAddOns = [];
        object.managedCompanies = [];
        object.addOns = [];
      }
      if (options.defaults) {
        object.enterpriseId = 0;
        object.enterpriseName = "";
        object.allocatedLicenses = 0;
        object.maxFilePlanType = "";
        object.allowUnlimitedLicenses = false;
      }
      if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
        object.enterpriseId = message.enterpriseId;
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        object.enterpriseName = message.enterpriseName;
      if (message.allocatedLicenses != null && message.hasOwnProperty("allocatedLicenses"))
        object.allocatedLicenses = message.allocatedLicenses;
      if (message.allowedMcProducts && message.allowedMcProducts.length) {
        object.allowedMcProducts = [];
        for (let j = 0; j < message.allowedMcProducts.length; ++j)
          object.allowedMcProducts[j] = message.allowedMcProducts[j];
      }
      if (message.allowedAddOns && message.allowedAddOns.length) {
        object.allowedAddOns = [];
        for (let j = 0; j < message.allowedAddOns.length; ++j)
          object.allowedAddOns[j] = message.allowedAddOns[j];
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        object.maxFilePlanType = message.maxFilePlanType;
      if (message.managedCompanies && message.managedCompanies.length) {
        object.managedCompanies = [];
        for (let j = 0; j < message.managedCompanies.length; ++j)
          object.managedCompanies[j] = $root.Enterprise.ManagedCompany.toObject(
            message.managedCompanies[j],
            options,
          );
      }
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        object.allowUnlimitedLicenses = message.allowUnlimitedLicenses;
      if (message.addOns && message.addOns.length) {
        object.addOns = [];
        for (let j = 0; j < message.addOns.length; ++j)
          object.addOns[j] = $root.Enterprise.LicenseAddOn.toObject(message.addOns[j], options);
      }
      return object;
    };

    /**
     * Converts this MspInfo to JSON.
     * @function toJSON
     * @memberof Enterprise.MspInfo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MspInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MspInfo
     * @function getTypeUrl
     * @memberof Enterprise.MspInfo
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MspInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MspInfo";
    };

    return MspInfo;
  })();

  Enterprise.ManagedCompany = (function () {
    /**
     * Properties of a ManagedCompany.
     * @memberof Enterprise
     * @interface IManagedCompany
     * @property {number|null} [mcEnterpriseId] ManagedCompany mcEnterpriseId
     * @property {string|null} [mcEnterpriseName] ManagedCompany mcEnterpriseName
     * @property {number|Long|null} [mspNodeId] ManagedCompany mspNodeId
     * @property {number|null} [numberOfSeats] ManagedCompany numberOfSeats
     * @property {number|null} [numberOfUsers] ManagedCompany numberOfUsers
     * @property {string|null} [productId] ManagedCompany productId
     * @property {boolean|null} [isExpired] ManagedCompany isExpired
     * @property {string|null} [treeKey] ManagedCompany treeKey
     * @property {number|Long|null} [treeKeyRole] ManagedCompany treeKeyRole
     * @property {string|null} [filePlanType] ManagedCompany filePlanType
     * @property {Array.<Enterprise.ILicenseAddOn>|null} [addOns] ManagedCompany addOns
     */

    /**
     * Constructs a new ManagedCompany.
     * @memberof Enterprise
     * @classdesc Represents a ManagedCompany.
     * @implements IManagedCompany
     * @constructor
     * @param {Enterprise.IManagedCompany=} [properties] Properties to set
     */
    function ManagedCompany(properties) {
      this.addOns = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ManagedCompany mcEnterpriseId.
     * @member {number} mcEnterpriseId
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.mcEnterpriseId = 0;

    /**
     * ManagedCompany mcEnterpriseName.
     * @member {string} mcEnterpriseName
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.mcEnterpriseName = "";

    /**
     * ManagedCompany mspNodeId.
     * @member {number|Long} mspNodeId
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.mspNodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ManagedCompany numberOfSeats.
     * @member {number} numberOfSeats
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.numberOfSeats = 0;

    /**
     * ManagedCompany numberOfUsers.
     * @member {number} numberOfUsers
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.numberOfUsers = 0;

    /**
     * ManagedCompany productId.
     * @member {string} productId
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.productId = "";

    /**
     * ManagedCompany isExpired.
     * @member {boolean} isExpired
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.isExpired = false;

    /**
     * ManagedCompany treeKey.
     * @member {string} treeKey
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.treeKey = "";

    /**
     * ManagedCompany treeKeyRole.
     * @member {number|Long} treeKeyRole
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.treeKeyRole = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ManagedCompany filePlanType.
     * @member {string} filePlanType
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.filePlanType = "";

    /**
     * ManagedCompany addOns.
     * @member {Array.<Enterprise.ILicenseAddOn>} addOns
     * @memberof Enterprise.ManagedCompany
     * @instance
     */
    ManagedCompany.prototype.addOns = $util.emptyArray;

    /**
     * Creates a new ManagedCompany instance using the specified properties.
     * @function create
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Enterprise.IManagedCompany=} [properties] Properties to set
     * @returns {Enterprise.ManagedCompany} ManagedCompany instance
     */
    ManagedCompany.create = function create(properties) {
      return new ManagedCompany(properties);
    };

    /**
     * Encodes the specified ManagedCompany message. Does not implicitly {@link Enterprise.ManagedCompany.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Enterprise.IManagedCompany} message ManagedCompany message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ManagedCompany.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.mcEnterpriseId != null && Object.hasOwnProperty.call(message, "mcEnterpriseId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mcEnterpriseId);
      if (
        message.mcEnterpriseName != null &&
        Object.hasOwnProperty.call(message, "mcEnterpriseName")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.mcEnterpriseName);
      if (message.mspNodeId != null && Object.hasOwnProperty.call(message, "mspNodeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.mspNodeId);
      if (message.numberOfSeats != null && Object.hasOwnProperty.call(message, "numberOfSeats"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.numberOfSeats);
      if (message.numberOfUsers != null && Object.hasOwnProperty.call(message, "numberOfUsers"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.numberOfUsers);
      if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.productId);
      if (message.isExpired != null && Object.hasOwnProperty.call(message, "isExpired"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.isExpired);
      if (message.treeKey != null && Object.hasOwnProperty.call(message, "treeKey"))
        writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.treeKey);
      if (message.treeKeyRole != null && Object.hasOwnProperty.call(message, "treeKeyRole"))
        writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.treeKeyRole);
      if (message.filePlanType != null && Object.hasOwnProperty.call(message, "filePlanType"))
        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.filePlanType);
      if (message.addOns != null && message.addOns.length)
        for (let i = 0; i < message.addOns.length; ++i)
          $root.Enterprise.LicenseAddOn.encode(
            message.addOns[i],
            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified ManagedCompany message, length delimited. Does not implicitly {@link Enterprise.ManagedCompany.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Enterprise.IManagedCompany} message ManagedCompany message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ManagedCompany.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ManagedCompany message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ManagedCompany} ManagedCompany
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ManagedCompany.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ManagedCompany();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.mcEnterpriseId = reader.int32();
            break;
          }
          case 2: {
            message.mcEnterpriseName = reader.string();
            break;
          }
          case 3: {
            message.mspNodeId = reader.int64();
            break;
          }
          case 4: {
            message.numberOfSeats = reader.int32();
            break;
          }
          case 5: {
            message.numberOfUsers = reader.int32();
            break;
          }
          case 6: {
            message.productId = reader.string();
            break;
          }
          case 7: {
            message.isExpired = reader.bool();
            break;
          }
          case 8: {
            message.treeKey = reader.string();
            break;
          }
          case 9: {
            message.treeKeyRole = reader.int64();
            break;
          }
          case 10: {
            message.filePlanType = reader.string();
            break;
          }
          case 11: {
            if (!(message.addOns && message.addOns.length)) message.addOns = [];
            message.addOns.push($root.Enterprise.LicenseAddOn.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ManagedCompany message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ManagedCompany} ManagedCompany
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ManagedCompany.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ManagedCompany message.
     * @function verify
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ManagedCompany.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
        if (!$util.isInteger(message.mcEnterpriseId)) return "mcEnterpriseId: integer expected";
      if (message.mcEnterpriseName != null && message.hasOwnProperty("mcEnterpriseName"))
        if (!$util.isString(message.mcEnterpriseName)) return "mcEnterpriseName: string expected";
      if (message.mspNodeId != null && message.hasOwnProperty("mspNodeId"))
        if (
          !$util.isInteger(message.mspNodeId) &&
          !(
            message.mspNodeId &&
            $util.isInteger(message.mspNodeId.low) &&
            $util.isInteger(message.mspNodeId.high)
          )
        )
          return "mspNodeId: integer|Long expected";
      if (message.numberOfSeats != null && message.hasOwnProperty("numberOfSeats"))
        if (!$util.isInteger(message.numberOfSeats)) return "numberOfSeats: integer expected";
      if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
        if (!$util.isInteger(message.numberOfUsers)) return "numberOfUsers: integer expected";
      if (message.productId != null && message.hasOwnProperty("productId"))
        if (!$util.isString(message.productId)) return "productId: string expected";
      if (message.isExpired != null && message.hasOwnProperty("isExpired"))
        if (typeof message.isExpired !== "boolean") return "isExpired: boolean expected";
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        if (!$util.isString(message.treeKey)) return "treeKey: string expected";
      if (message.treeKeyRole != null && message.hasOwnProperty("treeKeyRole"))
        if (
          !$util.isInteger(message.treeKeyRole) &&
          !(
            message.treeKeyRole &&
            $util.isInteger(message.treeKeyRole.low) &&
            $util.isInteger(message.treeKeyRole.high)
          )
        )
          return "treeKeyRole: integer|Long expected";
      if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
        if (!$util.isString(message.filePlanType)) return "filePlanType: string expected";
      if (message.addOns != null && message.hasOwnProperty("addOns")) {
        if (!Array.isArray(message.addOns)) return "addOns: array expected";
        for (let i = 0; i < message.addOns.length; ++i) {
          let error = $root.Enterprise.LicenseAddOn.verify(message.addOns[i]);
          if (error) return "addOns." + error;
        }
      }
      return null;
    };

    /**
     * Creates a ManagedCompany message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ManagedCompany} ManagedCompany
     */
    ManagedCompany.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ManagedCompany) return object;
      let message = new $root.Enterprise.ManagedCompany();
      if (object.mcEnterpriseId != null) message.mcEnterpriseId = object.mcEnterpriseId | 0;
      if (object.mcEnterpriseName != null)
        message.mcEnterpriseName = String(object.mcEnterpriseName);
      if (object.mspNodeId != null)
        if ($util.Long)
          (message.mspNodeId = $util.Long.fromValue(object.mspNodeId)).unsigned = false;
        else if (typeof object.mspNodeId === "string")
          message.mspNodeId = parseInt(object.mspNodeId, 10);
        else if (typeof object.mspNodeId === "number") message.mspNodeId = object.mspNodeId;
        else if (typeof object.mspNodeId === "object")
          message.mspNodeId = new $util.LongBits(
            object.mspNodeId.low >>> 0,
            object.mspNodeId.high >>> 0,
          ).toNumber();
      if (object.numberOfSeats != null) message.numberOfSeats = object.numberOfSeats | 0;
      if (object.numberOfUsers != null) message.numberOfUsers = object.numberOfUsers | 0;
      if (object.productId != null) message.productId = String(object.productId);
      if (object.isExpired != null) message.isExpired = Boolean(object.isExpired);
      if (object.treeKey != null) message.treeKey = String(object.treeKey);
      if (object.treeKeyRole != null)
        if ($util.Long)
          (message.treeKeyRole = $util.Long.fromValue(object.treeKeyRole)).unsigned = false;
        else if (typeof object.treeKeyRole === "string")
          message.treeKeyRole = parseInt(object.treeKeyRole, 10);
        else if (typeof object.treeKeyRole === "number") message.treeKeyRole = object.treeKeyRole;
        else if (typeof object.treeKeyRole === "object")
          message.treeKeyRole = new $util.LongBits(
            object.treeKeyRole.low >>> 0,
            object.treeKeyRole.high >>> 0,
          ).toNumber();
      if (object.filePlanType != null) message.filePlanType = String(object.filePlanType);
      if (object.addOns) {
        if (!Array.isArray(object.addOns))
          throw TypeError(".Enterprise.ManagedCompany.addOns: array expected");
        message.addOns = [];
        for (let i = 0; i < object.addOns.length; ++i) {
          if (typeof object.addOns[i] !== "object")
            throw TypeError(".Enterprise.ManagedCompany.addOns: object expected");
          message.addOns[i] = $root.Enterprise.LicenseAddOn.fromObject(object.addOns[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a ManagedCompany message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {Enterprise.ManagedCompany} message ManagedCompany
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ManagedCompany.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.addOns = [];
      if (options.defaults) {
        object.mcEnterpriseId = 0;
        object.mcEnterpriseName = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.mspNodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.mspNodeId = options.longs === String ? "0" : 0;
        object.numberOfSeats = 0;
        object.numberOfUsers = 0;
        object.productId = "";
        object.isExpired = false;
        object.treeKey = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.treeKeyRole =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.treeKeyRole = options.longs === String ? "0" : 0;
        object.filePlanType = "";
      }
      if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
        object.mcEnterpriseId = message.mcEnterpriseId;
      if (message.mcEnterpriseName != null && message.hasOwnProperty("mcEnterpriseName"))
        object.mcEnterpriseName = message.mcEnterpriseName;
      if (message.mspNodeId != null && message.hasOwnProperty("mspNodeId"))
        if (typeof message.mspNodeId === "number")
          object.mspNodeId =
            options.longs === String ? String(message.mspNodeId) : message.mspNodeId;
        else
          object.mspNodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.mspNodeId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.mspNodeId.low >>> 0,
                    message.mspNodeId.high >>> 0,
                  ).toNumber()
                : message.mspNodeId;
      if (message.numberOfSeats != null && message.hasOwnProperty("numberOfSeats"))
        object.numberOfSeats = message.numberOfSeats;
      if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
        object.numberOfUsers = message.numberOfUsers;
      if (message.productId != null && message.hasOwnProperty("productId"))
        object.productId = message.productId;
      if (message.isExpired != null && message.hasOwnProperty("isExpired"))
        object.isExpired = message.isExpired;
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        object.treeKey = message.treeKey;
      if (message.treeKeyRole != null && message.hasOwnProperty("treeKeyRole"))
        if (typeof message.treeKeyRole === "number")
          object.treeKeyRole =
            options.longs === String ? String(message.treeKeyRole) : message.treeKeyRole;
        else
          object.treeKeyRole =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.treeKeyRole)
              : options.longs === Number
                ? new $util.LongBits(
                    message.treeKeyRole.low >>> 0,
                    message.treeKeyRole.high >>> 0,
                  ).toNumber()
                : message.treeKeyRole;
      if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
        object.filePlanType = message.filePlanType;
      if (message.addOns && message.addOns.length) {
        object.addOns = [];
        for (let j = 0; j < message.addOns.length; ++j)
          object.addOns[j] = $root.Enterprise.LicenseAddOn.toObject(message.addOns[j], options);
      }
      return object;
    };

    /**
     * Converts this ManagedCompany to JSON.
     * @function toJSON
     * @memberof Enterprise.ManagedCompany
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ManagedCompany.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ManagedCompany
     * @function getTypeUrl
     * @memberof Enterprise.ManagedCompany
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ManagedCompany.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ManagedCompany";
    };

    return ManagedCompany;
  })();

  Enterprise.MSPPool = (function () {
    /**
     * Properties of a MSPPool.
     * @memberof Enterprise
     * @interface IMSPPool
     * @property {string|null} [productId] MSPPool productId
     * @property {number|null} [seats] MSPPool seats
     * @property {number|null} [availableSeats] MSPPool availableSeats
     * @property {number|null} [stash] MSPPool stash
     */

    /**
     * Constructs a new MSPPool.
     * @memberof Enterprise
     * @classdesc Represents a MSPPool.
     * @implements IMSPPool
     * @constructor
     * @param {Enterprise.IMSPPool=} [properties] Properties to set
     */
    function MSPPool(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MSPPool productId.
     * @member {string} productId
     * @memberof Enterprise.MSPPool
     * @instance
     */
    MSPPool.prototype.productId = "";

    /**
     * MSPPool seats.
     * @member {number} seats
     * @memberof Enterprise.MSPPool
     * @instance
     */
    MSPPool.prototype.seats = 0;

    /**
     * MSPPool availableSeats.
     * @member {number} availableSeats
     * @memberof Enterprise.MSPPool
     * @instance
     */
    MSPPool.prototype.availableSeats = 0;

    /**
     * MSPPool stash.
     * @member {number} stash
     * @memberof Enterprise.MSPPool
     * @instance
     */
    MSPPool.prototype.stash = 0;

    /**
     * Creates a new MSPPool instance using the specified properties.
     * @function create
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Enterprise.IMSPPool=} [properties] Properties to set
     * @returns {Enterprise.MSPPool} MSPPool instance
     */
    MSPPool.create = function create(properties) {
      return new MSPPool(properties);
    };

    /**
     * Encodes the specified MSPPool message. Does not implicitly {@link Enterprise.MSPPool.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Enterprise.IMSPPool} message MSPPool message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPPool.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.productId);
      if (message.seats != null && Object.hasOwnProperty.call(message, "seats"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.seats);
      if (message.availableSeats != null && Object.hasOwnProperty.call(message, "availableSeats"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.availableSeats);
      if (message.stash != null && Object.hasOwnProperty.call(message, "stash"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.stash);
      return writer;
    };

    /**
     * Encodes the specified MSPPool message, length delimited. Does not implicitly {@link Enterprise.MSPPool.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Enterprise.IMSPPool} message MSPPool message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPPool.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MSPPool message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MSPPool
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MSPPool} MSPPool
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPPool.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MSPPool();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.productId = reader.string();
            break;
          }
          case 2: {
            message.seats = reader.int32();
            break;
          }
          case 3: {
            message.availableSeats = reader.int32();
            break;
          }
          case 4: {
            message.stash = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MSPPool message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MSPPool
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MSPPool} MSPPool
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPPool.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MSPPool message.
     * @function verify
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MSPPool.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.productId != null && message.hasOwnProperty("productId"))
        if (!$util.isString(message.productId)) return "productId: string expected";
      if (message.seats != null && message.hasOwnProperty("seats"))
        if (!$util.isInteger(message.seats)) return "seats: integer expected";
      if (message.availableSeats != null && message.hasOwnProperty("availableSeats"))
        if (!$util.isInteger(message.availableSeats)) return "availableSeats: integer expected";
      if (message.stash != null && message.hasOwnProperty("stash"))
        if (!$util.isInteger(message.stash)) return "stash: integer expected";
      return null;
    };

    /**
     * Creates a MSPPool message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MSPPool} MSPPool
     */
    MSPPool.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MSPPool) return object;
      let message = new $root.Enterprise.MSPPool();
      if (object.productId != null) message.productId = String(object.productId);
      if (object.seats != null) message.seats = object.seats | 0;
      if (object.availableSeats != null) message.availableSeats = object.availableSeats | 0;
      if (object.stash != null) message.stash = object.stash | 0;
      return message;
    };

    /**
     * Creates a plain object from a MSPPool message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MSPPool
     * @static
     * @param {Enterprise.MSPPool} message MSPPool
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MSPPool.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.productId = "";
        object.seats = 0;
        object.availableSeats = 0;
        object.stash = 0;
      }
      if (message.productId != null && message.hasOwnProperty("productId"))
        object.productId = message.productId;
      if (message.seats != null && message.hasOwnProperty("seats")) object.seats = message.seats;
      if (message.availableSeats != null && message.hasOwnProperty("availableSeats"))
        object.availableSeats = message.availableSeats;
      if (message.stash != null && message.hasOwnProperty("stash")) object.stash = message.stash;
      return object;
    };

    /**
     * Converts this MSPPool to JSON.
     * @function toJSON
     * @memberof Enterprise.MSPPool
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MSPPool.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MSPPool
     * @function getTypeUrl
     * @memberof Enterprise.MSPPool
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MSPPool.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MSPPool";
    };

    return MSPPool;
  })();

  Enterprise.MSPContact = (function () {
    /**
     * Properties of a MSPContact.
     * @memberof Enterprise
     * @interface IMSPContact
     * @property {number|null} [enterpriseId] MSPContact enterpriseId
     * @property {string|null} [enterpriseName] MSPContact enterpriseName
     */

    /**
     * Constructs a new MSPContact.
     * @memberof Enterprise
     * @classdesc Represents a MSPContact.
     * @implements IMSPContact
     * @constructor
     * @param {Enterprise.IMSPContact=} [properties] Properties to set
     */
    function MSPContact(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MSPContact enterpriseId.
     * @member {number} enterpriseId
     * @memberof Enterprise.MSPContact
     * @instance
     */
    MSPContact.prototype.enterpriseId = 0;

    /**
     * MSPContact enterpriseName.
     * @member {string} enterpriseName
     * @memberof Enterprise.MSPContact
     * @instance
     */
    MSPContact.prototype.enterpriseName = "";

    /**
     * Creates a new MSPContact instance using the specified properties.
     * @function create
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Enterprise.IMSPContact=} [properties] Properties to set
     * @returns {Enterprise.MSPContact} MSPContact instance
     */
    MSPContact.create = function create(properties) {
      return new MSPContact(properties);
    };

    /**
     * Encodes the specified MSPContact message. Does not implicitly {@link Enterprise.MSPContact.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Enterprise.IMSPContact} message MSPContact message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPContact.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseId != null && Object.hasOwnProperty.call(message, "enterpriseId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.enterpriseId);
      if (message.enterpriseName != null && Object.hasOwnProperty.call(message, "enterpriseName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.enterpriseName);
      return writer;
    };

    /**
     * Encodes the specified MSPContact message, length delimited. Does not implicitly {@link Enterprise.MSPContact.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Enterprise.IMSPContact} message MSPContact message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPContact.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MSPContact message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MSPContact
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MSPContact} MSPContact
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPContact.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MSPContact();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseId = reader.int32();
            break;
          }
          case 2: {
            message.enterpriseName = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MSPContact message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MSPContact
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MSPContact} MSPContact
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPContact.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MSPContact message.
     * @function verify
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MSPContact.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
        if (!$util.isInteger(message.enterpriseId)) return "enterpriseId: integer expected";
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        if (!$util.isString(message.enterpriseName)) return "enterpriseName: string expected";
      return null;
    };

    /**
     * Creates a MSPContact message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MSPContact} MSPContact
     */
    MSPContact.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MSPContact) return object;
      let message = new $root.Enterprise.MSPContact();
      if (object.enterpriseId != null) message.enterpriseId = object.enterpriseId | 0;
      if (object.enterpriseName != null) message.enterpriseName = String(object.enterpriseName);
      return message;
    };

    /**
     * Creates a plain object from a MSPContact message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MSPContact
     * @static
     * @param {Enterprise.MSPContact} message MSPContact
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MSPContact.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.enterpriseId = 0;
        object.enterpriseName = "";
      }
      if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
        object.enterpriseId = message.enterpriseId;
      if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
        object.enterpriseName = message.enterpriseName;
      return object;
    };

    /**
     * Converts this MSPContact to JSON.
     * @function toJSON
     * @memberof Enterprise.MSPContact
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MSPContact.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MSPContact
     * @function getTypeUrl
     * @memberof Enterprise.MSPContact
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MSPContact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MSPContact";
    };

    return MSPContact;
  })();

  Enterprise.LicenseAddOn = (function () {
    /**
     * Properties of a LicenseAddOn.
     * @memberof Enterprise
     * @interface ILicenseAddOn
     * @property {string|null} [name] LicenseAddOn name
     * @property {boolean|null} [enabled] LicenseAddOn enabled
     * @property {boolean|null} [isTrial] LicenseAddOn isTrial
     * @property {number|Long|null} [expiration] LicenseAddOn expiration
     * @property {number|Long|null} [created] LicenseAddOn created
     * @property {number|null} [seats] LicenseAddOn seats
     * @property {number|Long|null} [activationTime] LicenseAddOn activationTime
     * @property {boolean|null} [includedInProduct] LicenseAddOn includedInProduct
     * @property {number|null} [apiCallCount] LicenseAddOn apiCallCount
     * @property {string|null} [tierDescription] LicenseAddOn tierDescription
     * @property {number|null} [seatsAllocated] LicenseAddOn seatsAllocated
     */

    /**
     * Constructs a new LicenseAddOn.
     * @memberof Enterprise
     * @classdesc Represents a LicenseAddOn.
     * @implements ILicenseAddOn
     * @constructor
     * @param {Enterprise.ILicenseAddOn=} [properties] Properties to set
     */
    function LicenseAddOn(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * LicenseAddOn name.
     * @member {string} name
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.name = "";

    /**
     * LicenseAddOn enabled.
     * @member {boolean} enabled
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.enabled = false;

    /**
     * LicenseAddOn isTrial.
     * @member {boolean} isTrial
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.isTrial = false;

    /**
     * LicenseAddOn expiration.
     * @member {number|Long} expiration
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * LicenseAddOn created.
     * @member {number|Long} created
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.created = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * LicenseAddOn seats.
     * @member {number} seats
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.seats = 0;

    /**
     * LicenseAddOn activationTime.
     * @member {number|Long} activationTime
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.activationTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * LicenseAddOn includedInProduct.
     * @member {boolean} includedInProduct
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.includedInProduct = false;

    /**
     * LicenseAddOn apiCallCount.
     * @member {number} apiCallCount
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.apiCallCount = 0;

    /**
     * LicenseAddOn tierDescription.
     * @member {string} tierDescription
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.tierDescription = "";

    /**
     * LicenseAddOn seatsAllocated.
     * @member {number} seatsAllocated
     * @memberof Enterprise.LicenseAddOn
     * @instance
     */
    LicenseAddOn.prototype.seatsAllocated = 0;

    /**
     * Creates a new LicenseAddOn instance using the specified properties.
     * @function create
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Enterprise.ILicenseAddOn=} [properties] Properties to set
     * @returns {Enterprise.LicenseAddOn} LicenseAddOn instance
     */
    LicenseAddOn.create = function create(properties) {
      return new LicenseAddOn(properties);
    };

    /**
     * Encodes the specified LicenseAddOn message. Does not implicitly {@link Enterprise.LicenseAddOn.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Enterprise.ILicenseAddOn} message LicenseAddOn message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicenseAddOn.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
      if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.enabled);
      if (message.isTrial != null && Object.hasOwnProperty.call(message, "isTrial"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.isTrial);
      if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.expiration);
      if (message.created != null && Object.hasOwnProperty.call(message, "created"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.created);
      if (message.seats != null && Object.hasOwnProperty.call(message, "seats"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.seats);
      if (message.activationTime != null && Object.hasOwnProperty.call(message, "activationTime"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.activationTime);
      if (
        message.includedInProduct != null &&
        Object.hasOwnProperty.call(message, "includedInProduct")
      )
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.includedInProduct);
      if (message.apiCallCount != null && Object.hasOwnProperty.call(message, "apiCallCount"))
        writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.apiCallCount);
      if (message.tierDescription != null && Object.hasOwnProperty.call(message, "tierDescription"))
        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.tierDescription);
      if (message.seatsAllocated != null && Object.hasOwnProperty.call(message, "seatsAllocated"))
        writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.seatsAllocated);
      return writer;
    };

    /**
     * Encodes the specified LicenseAddOn message, length delimited. Does not implicitly {@link Enterprise.LicenseAddOn.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Enterprise.ILicenseAddOn} message LicenseAddOn message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LicenseAddOn.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LicenseAddOn message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.LicenseAddOn} LicenseAddOn
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicenseAddOn.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.LicenseAddOn();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.name = reader.string();
            break;
          }
          case 2: {
            message.enabled = reader.bool();
            break;
          }
          case 3: {
            message.isTrial = reader.bool();
            break;
          }
          case 4: {
            message.expiration = reader.int64();
            break;
          }
          case 5: {
            message.created = reader.int64();
            break;
          }
          case 6: {
            message.seats = reader.int32();
            break;
          }
          case 7: {
            message.activationTime = reader.int64();
            break;
          }
          case 8: {
            message.includedInProduct = reader.bool();
            break;
          }
          case 9: {
            message.apiCallCount = reader.int32();
            break;
          }
          case 10: {
            message.tierDescription = reader.string();
            break;
          }
          case 11: {
            message.seatsAllocated = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a LicenseAddOn message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.LicenseAddOn} LicenseAddOn
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LicenseAddOn.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LicenseAddOn message.
     * @function verify
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LicenseAddOn.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.enabled != null && message.hasOwnProperty("enabled"))
        if (typeof message.enabled !== "boolean") return "enabled: boolean expected";
      if (message.isTrial != null && message.hasOwnProperty("isTrial"))
        if (typeof message.isTrial !== "boolean") return "isTrial: boolean expected";
      if (message.expiration != null && message.hasOwnProperty("expiration"))
        if (
          !$util.isInteger(message.expiration) &&
          !(
            message.expiration &&
            $util.isInteger(message.expiration.low) &&
            $util.isInteger(message.expiration.high)
          )
        )
          return "expiration: integer|Long expected";
      if (message.created != null && message.hasOwnProperty("created"))
        if (
          !$util.isInteger(message.created) &&
          !(
            message.created &&
            $util.isInteger(message.created.low) &&
            $util.isInteger(message.created.high)
          )
        )
          return "created: integer|Long expected";
      if (message.seats != null && message.hasOwnProperty("seats"))
        if (!$util.isInteger(message.seats)) return "seats: integer expected";
      if (message.activationTime != null && message.hasOwnProperty("activationTime"))
        if (
          !$util.isInteger(message.activationTime) &&
          !(
            message.activationTime &&
            $util.isInteger(message.activationTime.low) &&
            $util.isInteger(message.activationTime.high)
          )
        )
          return "activationTime: integer|Long expected";
      if (message.includedInProduct != null && message.hasOwnProperty("includedInProduct"))
        if (typeof message.includedInProduct !== "boolean")
          return "includedInProduct: boolean expected";
      if (message.apiCallCount != null && message.hasOwnProperty("apiCallCount"))
        if (!$util.isInteger(message.apiCallCount)) return "apiCallCount: integer expected";
      if (message.tierDescription != null && message.hasOwnProperty("tierDescription"))
        if (!$util.isString(message.tierDescription)) return "tierDescription: string expected";
      if (message.seatsAllocated != null && message.hasOwnProperty("seatsAllocated"))
        if (!$util.isInteger(message.seatsAllocated)) return "seatsAllocated: integer expected";
      return null;
    };

    /**
     * Creates a LicenseAddOn message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.LicenseAddOn} LicenseAddOn
     */
    LicenseAddOn.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.LicenseAddOn) return object;
      let message = new $root.Enterprise.LicenseAddOn();
      if (object.name != null) message.name = String(object.name);
      if (object.enabled != null) message.enabled = Boolean(object.enabled);
      if (object.isTrial != null) message.isTrial = Boolean(object.isTrial);
      if (object.expiration != null)
        if ($util.Long)
          (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
        else if (typeof object.expiration === "string")
          message.expiration = parseInt(object.expiration, 10);
        else if (typeof object.expiration === "number") message.expiration = object.expiration;
        else if (typeof object.expiration === "object")
          message.expiration = new $util.LongBits(
            object.expiration.low >>> 0,
            object.expiration.high >>> 0,
          ).toNumber();
      if (object.created != null)
        if ($util.Long) (message.created = $util.Long.fromValue(object.created)).unsigned = false;
        else if (typeof object.created === "string") message.created = parseInt(object.created, 10);
        else if (typeof object.created === "number") message.created = object.created;
        else if (typeof object.created === "object")
          message.created = new $util.LongBits(
            object.created.low >>> 0,
            object.created.high >>> 0,
          ).toNumber();
      if (object.seats != null) message.seats = object.seats | 0;
      if (object.activationTime != null)
        if ($util.Long)
          (message.activationTime = $util.Long.fromValue(object.activationTime)).unsigned = false;
        else if (typeof object.activationTime === "string")
          message.activationTime = parseInt(object.activationTime, 10);
        else if (typeof object.activationTime === "number")
          message.activationTime = object.activationTime;
        else if (typeof object.activationTime === "object")
          message.activationTime = new $util.LongBits(
            object.activationTime.low >>> 0,
            object.activationTime.high >>> 0,
          ).toNumber();
      if (object.includedInProduct != null)
        message.includedInProduct = Boolean(object.includedInProduct);
      if (object.apiCallCount != null) message.apiCallCount = object.apiCallCount | 0;
      if (object.tierDescription != null) message.tierDescription = String(object.tierDescription);
      if (object.seatsAllocated != null) message.seatsAllocated = object.seatsAllocated | 0;
      return message;
    };

    /**
     * Creates a plain object from a LicenseAddOn message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {Enterprise.LicenseAddOn} message LicenseAddOn
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LicenseAddOn.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.name = "";
        object.enabled = false;
        object.isTrial = false;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.expiration =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.expiration = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.created =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.created = options.longs === String ? "0" : 0;
        object.seats = 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.activationTime =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.activationTime = options.longs === String ? "0" : 0;
        object.includedInProduct = false;
        object.apiCallCount = 0;
        object.tierDescription = "";
        object.seatsAllocated = 0;
      }
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.enabled != null && message.hasOwnProperty("enabled"))
        object.enabled = message.enabled;
      if (message.isTrial != null && message.hasOwnProperty("isTrial"))
        object.isTrial = message.isTrial;
      if (message.expiration != null && message.hasOwnProperty("expiration"))
        if (typeof message.expiration === "number")
          object.expiration =
            options.longs === String ? String(message.expiration) : message.expiration;
        else
          object.expiration =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.expiration)
              : options.longs === Number
                ? new $util.LongBits(
                    message.expiration.low >>> 0,
                    message.expiration.high >>> 0,
                  ).toNumber()
                : message.expiration;
      if (message.created != null && message.hasOwnProperty("created"))
        if (typeof message.created === "number")
          object.created = options.longs === String ? String(message.created) : message.created;
        else
          object.created =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.created)
              : options.longs === Number
                ? new $util.LongBits(
                    message.created.low >>> 0,
                    message.created.high >>> 0,
                  ).toNumber()
                : message.created;
      if (message.seats != null && message.hasOwnProperty("seats")) object.seats = message.seats;
      if (message.activationTime != null && message.hasOwnProperty("activationTime"))
        if (typeof message.activationTime === "number")
          object.activationTime =
            options.longs === String ? String(message.activationTime) : message.activationTime;
        else
          object.activationTime =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.activationTime)
              : options.longs === Number
                ? new $util.LongBits(
                    message.activationTime.low >>> 0,
                    message.activationTime.high >>> 0,
                  ).toNumber()
                : message.activationTime;
      if (message.includedInProduct != null && message.hasOwnProperty("includedInProduct"))
        object.includedInProduct = message.includedInProduct;
      if (message.apiCallCount != null && message.hasOwnProperty("apiCallCount"))
        object.apiCallCount = message.apiCallCount;
      if (message.tierDescription != null && message.hasOwnProperty("tierDescription"))
        object.tierDescription = message.tierDescription;
      if (message.seatsAllocated != null && message.hasOwnProperty("seatsAllocated"))
        object.seatsAllocated = message.seatsAllocated;
      return object;
    };

    /**
     * Converts this LicenseAddOn to JSON.
     * @function toJSON
     * @memberof Enterprise.LicenseAddOn
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LicenseAddOn.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LicenseAddOn
     * @function getTypeUrl
     * @memberof Enterprise.LicenseAddOn
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LicenseAddOn.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.LicenseAddOn";
    };

    return LicenseAddOn;
  })();

  Enterprise.MCDefault = (function () {
    /**
     * Properties of a MCDefault.
     * @memberof Enterprise
     * @interface IMCDefault
     * @property {string|null} [mcProduct] MCDefault mcProduct
     * @property {Array.<string>|null} [addOns] MCDefault addOns
     * @property {string|null} [filePlanType] MCDefault filePlanType
     * @property {number|null} [maxLicenses] MCDefault maxLicenses
     * @property {boolean|null} [fixedMaxLicenses] MCDefault fixedMaxLicenses
     */

    /**
     * Constructs a new MCDefault.
     * @memberof Enterprise
     * @classdesc Represents a MCDefault.
     * @implements IMCDefault
     * @constructor
     * @param {Enterprise.IMCDefault=} [properties] Properties to set
     */
    function MCDefault(properties) {
      this.addOns = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MCDefault mcProduct.
     * @member {string} mcProduct
     * @memberof Enterprise.MCDefault
     * @instance
     */
    MCDefault.prototype.mcProduct = "";

    /**
     * MCDefault addOns.
     * @member {Array.<string>} addOns
     * @memberof Enterprise.MCDefault
     * @instance
     */
    MCDefault.prototype.addOns = $util.emptyArray;

    /**
     * MCDefault filePlanType.
     * @member {string} filePlanType
     * @memberof Enterprise.MCDefault
     * @instance
     */
    MCDefault.prototype.filePlanType = "";

    /**
     * MCDefault maxLicenses.
     * @member {number} maxLicenses
     * @memberof Enterprise.MCDefault
     * @instance
     */
    MCDefault.prototype.maxLicenses = 0;

    /**
     * MCDefault fixedMaxLicenses.
     * @member {boolean} fixedMaxLicenses
     * @memberof Enterprise.MCDefault
     * @instance
     */
    MCDefault.prototype.fixedMaxLicenses = false;

    /**
     * Creates a new MCDefault instance using the specified properties.
     * @function create
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Enterprise.IMCDefault=} [properties] Properties to set
     * @returns {Enterprise.MCDefault} MCDefault instance
     */
    MCDefault.create = function create(properties) {
      return new MCDefault(properties);
    };

    /**
     * Encodes the specified MCDefault message. Does not implicitly {@link Enterprise.MCDefault.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Enterprise.IMCDefault} message MCDefault message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MCDefault.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.mcProduct != null && Object.hasOwnProperty.call(message, "mcProduct"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mcProduct);
      if (message.addOns != null && message.addOns.length)
        for (let i = 0; i < message.addOns.length; ++i)
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.addOns[i]);
      if (message.filePlanType != null && Object.hasOwnProperty.call(message, "filePlanType"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.filePlanType);
      if (message.maxLicenses != null && Object.hasOwnProperty.call(message, "maxLicenses"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.maxLicenses);
      if (
        message.fixedMaxLicenses != null &&
        Object.hasOwnProperty.call(message, "fixedMaxLicenses")
      )
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.fixedMaxLicenses);
      return writer;
    };

    /**
     * Encodes the specified MCDefault message, length delimited. Does not implicitly {@link Enterprise.MCDefault.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Enterprise.IMCDefault} message MCDefault message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MCDefault.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MCDefault message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MCDefault
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MCDefault} MCDefault
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MCDefault.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MCDefault();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.mcProduct = reader.string();
            break;
          }
          case 2: {
            if (!(message.addOns && message.addOns.length)) message.addOns = [];
            message.addOns.push(reader.string());
            break;
          }
          case 3: {
            message.filePlanType = reader.string();
            break;
          }
          case 4: {
            message.maxLicenses = reader.int32();
            break;
          }
          case 5: {
            message.fixedMaxLicenses = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MCDefault message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MCDefault
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MCDefault} MCDefault
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MCDefault.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MCDefault message.
     * @function verify
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MCDefault.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.mcProduct != null && message.hasOwnProperty("mcProduct"))
        if (!$util.isString(message.mcProduct)) return "mcProduct: string expected";
      if (message.addOns != null && message.hasOwnProperty("addOns")) {
        if (!Array.isArray(message.addOns)) return "addOns: array expected";
        for (let i = 0; i < message.addOns.length; ++i)
          if (!$util.isString(message.addOns[i])) return "addOns: string[] expected";
      }
      if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
        if (!$util.isString(message.filePlanType)) return "filePlanType: string expected";
      if (message.maxLicenses != null && message.hasOwnProperty("maxLicenses"))
        if (!$util.isInteger(message.maxLicenses)) return "maxLicenses: integer expected";
      if (message.fixedMaxLicenses != null && message.hasOwnProperty("fixedMaxLicenses"))
        if (typeof message.fixedMaxLicenses !== "boolean")
          return "fixedMaxLicenses: boolean expected";
      return null;
    };

    /**
     * Creates a MCDefault message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MCDefault} MCDefault
     */
    MCDefault.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MCDefault) return object;
      let message = new $root.Enterprise.MCDefault();
      if (object.mcProduct != null) message.mcProduct = String(object.mcProduct);
      if (object.addOns) {
        if (!Array.isArray(object.addOns))
          throw TypeError(".Enterprise.MCDefault.addOns: array expected");
        message.addOns = [];
        for (let i = 0; i < object.addOns.length; ++i) message.addOns[i] = String(object.addOns[i]);
      }
      if (object.filePlanType != null) message.filePlanType = String(object.filePlanType);
      if (object.maxLicenses != null) message.maxLicenses = object.maxLicenses | 0;
      if (object.fixedMaxLicenses != null)
        message.fixedMaxLicenses = Boolean(object.fixedMaxLicenses);
      return message;
    };

    /**
     * Creates a plain object from a MCDefault message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MCDefault
     * @static
     * @param {Enterprise.MCDefault} message MCDefault
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MCDefault.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.addOns = [];
      if (options.defaults) {
        object.mcProduct = "";
        object.filePlanType = "";
        object.maxLicenses = 0;
        object.fixedMaxLicenses = false;
      }
      if (message.mcProduct != null && message.hasOwnProperty("mcProduct"))
        object.mcProduct = message.mcProduct;
      if (message.addOns && message.addOns.length) {
        object.addOns = [];
        for (let j = 0; j < message.addOns.length; ++j) object.addOns[j] = message.addOns[j];
      }
      if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
        object.filePlanType = message.filePlanType;
      if (message.maxLicenses != null && message.hasOwnProperty("maxLicenses"))
        object.maxLicenses = message.maxLicenses;
      if (message.fixedMaxLicenses != null && message.hasOwnProperty("fixedMaxLicenses"))
        object.fixedMaxLicenses = message.fixedMaxLicenses;
      return object;
    };

    /**
     * Converts this MCDefault to JSON.
     * @function toJSON
     * @memberof Enterprise.MCDefault
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MCDefault.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MCDefault
     * @function getTypeUrl
     * @memberof Enterprise.MCDefault
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MCDefault.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MCDefault";
    };

    return MCDefault;
  })();

  Enterprise.MSPPermits = (function () {
    /**
     * Properties of a MSPPermits.
     * @memberof Enterprise
     * @interface IMSPPermits
     * @property {boolean|null} [restricted] MSPPermits restricted
     * @property {number|null} [maxAllowedLicenses] MSPPermits maxAllowedLicenses
     * @property {Array.<string>|null} [allowedMcProducts] MSPPermits allowedMcProducts
     * @property {Array.<string>|null} [allowedAddOns] MSPPermits allowedAddOns
     * @property {string|null} [maxFilePlanType] MSPPermits maxFilePlanType
     * @property {boolean|null} [allowUnlimitedLicenses] MSPPermits allowUnlimitedLicenses
     * @property {Array.<Enterprise.IMCDefault>|null} [mcDefaults] MSPPermits mcDefaults
     */

    /**
     * Constructs a new MSPPermits.
     * @memberof Enterprise
     * @classdesc Represents a MSPPermits.
     * @implements IMSPPermits
     * @constructor
     * @param {Enterprise.IMSPPermits=} [properties] Properties to set
     */
    function MSPPermits(properties) {
      this.allowedMcProducts = [];
      this.allowedAddOns = [];
      this.mcDefaults = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MSPPermits restricted.
     * @member {boolean} restricted
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.restricted = false;

    /**
     * MSPPermits maxAllowedLicenses.
     * @member {number} maxAllowedLicenses
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.maxAllowedLicenses = 0;

    /**
     * MSPPermits allowedMcProducts.
     * @member {Array.<string>} allowedMcProducts
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.allowedMcProducts = $util.emptyArray;

    /**
     * MSPPermits allowedAddOns.
     * @member {Array.<string>} allowedAddOns
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.allowedAddOns = $util.emptyArray;

    /**
     * MSPPermits maxFilePlanType.
     * @member {string} maxFilePlanType
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.maxFilePlanType = "";

    /**
     * MSPPermits allowUnlimitedLicenses.
     * @member {boolean} allowUnlimitedLicenses
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.allowUnlimitedLicenses = false;

    /**
     * MSPPermits mcDefaults.
     * @member {Array.<Enterprise.IMCDefault>} mcDefaults
     * @memberof Enterprise.MSPPermits
     * @instance
     */
    MSPPermits.prototype.mcDefaults = $util.emptyArray;

    /**
     * Creates a new MSPPermits instance using the specified properties.
     * @function create
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Enterprise.IMSPPermits=} [properties] Properties to set
     * @returns {Enterprise.MSPPermits} MSPPermits instance
     */
    MSPPermits.create = function create(properties) {
      return new MSPPermits(properties);
    };

    /**
     * Encodes the specified MSPPermits message. Does not implicitly {@link Enterprise.MSPPermits.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Enterprise.IMSPPermits} message MSPPermits message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPPermits.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.restricted != null && Object.hasOwnProperty.call(message, "restricted"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.restricted);
      if (
        message.maxAllowedLicenses != null &&
        Object.hasOwnProperty.call(message, "maxAllowedLicenses")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.maxAllowedLicenses);
      if (message.allowedMcProducts != null && message.allowedMcProducts.length)
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.allowedMcProducts[i]);
      if (message.allowedAddOns != null && message.allowedAddOns.length)
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.allowedAddOns[i]);
      if (message.maxFilePlanType != null && Object.hasOwnProperty.call(message, "maxFilePlanType"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.maxFilePlanType);
      if (
        message.allowUnlimitedLicenses != null &&
        Object.hasOwnProperty.call(message, "allowUnlimitedLicenses")
      )
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.allowUnlimitedLicenses);
      if (message.mcDefaults != null && message.mcDefaults.length)
        for (let i = 0; i < message.mcDefaults.length; ++i)
          $root.Enterprise.MCDefault.encode(
            message.mcDefaults[i],
            writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified MSPPermits message, length delimited. Does not implicitly {@link Enterprise.MSPPermits.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Enterprise.IMSPPermits} message MSPPermits message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MSPPermits.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MSPPermits message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MSPPermits} MSPPermits
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPPermits.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MSPPermits();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.restricted = reader.bool();
            break;
          }
          case 2: {
            message.maxAllowedLicenses = reader.int32();
            break;
          }
          case 3: {
            if (!(message.allowedMcProducts && message.allowedMcProducts.length))
              message.allowedMcProducts = [];
            message.allowedMcProducts.push(reader.string());
            break;
          }
          case 4: {
            if (!(message.allowedAddOns && message.allowedAddOns.length))
              message.allowedAddOns = [];
            message.allowedAddOns.push(reader.string());
            break;
          }
          case 5: {
            message.maxFilePlanType = reader.string();
            break;
          }
          case 6: {
            message.allowUnlimitedLicenses = reader.bool();
            break;
          }
          case 7: {
            if (!(message.mcDefaults && message.mcDefaults.length)) message.mcDefaults = [];
            message.mcDefaults.push($root.Enterprise.MCDefault.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MSPPermits message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MSPPermits} MSPPermits
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MSPPermits.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MSPPermits message.
     * @function verify
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MSPPermits.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.restricted != null && message.hasOwnProperty("restricted"))
        if (typeof message.restricted !== "boolean") return "restricted: boolean expected";
      if (message.maxAllowedLicenses != null && message.hasOwnProperty("maxAllowedLicenses"))
        if (!$util.isInteger(message.maxAllowedLicenses))
          return "maxAllowedLicenses: integer expected";
      if (message.allowedMcProducts != null && message.hasOwnProperty("allowedMcProducts")) {
        if (!Array.isArray(message.allowedMcProducts)) return "allowedMcProducts: array expected";
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          if (!$util.isString(message.allowedMcProducts[i]))
            return "allowedMcProducts: string[] expected";
      }
      if (message.allowedAddOns != null && message.hasOwnProperty("allowedAddOns")) {
        if (!Array.isArray(message.allowedAddOns)) return "allowedAddOns: array expected";
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          if (!$util.isString(message.allowedAddOns[i])) return "allowedAddOns: string[] expected";
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        if (!$util.isString(message.maxFilePlanType)) return "maxFilePlanType: string expected";
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        if (typeof message.allowUnlimitedLicenses !== "boolean")
          return "allowUnlimitedLicenses: boolean expected";
      if (message.mcDefaults != null && message.hasOwnProperty("mcDefaults")) {
        if (!Array.isArray(message.mcDefaults)) return "mcDefaults: array expected";
        for (let i = 0; i < message.mcDefaults.length; ++i) {
          let error = $root.Enterprise.MCDefault.verify(message.mcDefaults[i]);
          if (error) return "mcDefaults." + error;
        }
      }
      return null;
    };

    /**
     * Creates a MSPPermits message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MSPPermits} MSPPermits
     */
    MSPPermits.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MSPPermits) return object;
      let message = new $root.Enterprise.MSPPermits();
      if (object.restricted != null) message.restricted = Boolean(object.restricted);
      if (object.maxAllowedLicenses != null)
        message.maxAllowedLicenses = object.maxAllowedLicenses | 0;
      if (object.allowedMcProducts) {
        if (!Array.isArray(object.allowedMcProducts))
          throw TypeError(".Enterprise.MSPPermits.allowedMcProducts: array expected");
        message.allowedMcProducts = [];
        for (let i = 0; i < object.allowedMcProducts.length; ++i)
          message.allowedMcProducts[i] = String(object.allowedMcProducts[i]);
      }
      if (object.allowedAddOns) {
        if (!Array.isArray(object.allowedAddOns))
          throw TypeError(".Enterprise.MSPPermits.allowedAddOns: array expected");
        message.allowedAddOns = [];
        for (let i = 0; i < object.allowedAddOns.length; ++i)
          message.allowedAddOns[i] = String(object.allowedAddOns[i]);
      }
      if (object.maxFilePlanType != null) message.maxFilePlanType = String(object.maxFilePlanType);
      if (object.allowUnlimitedLicenses != null)
        message.allowUnlimitedLicenses = Boolean(object.allowUnlimitedLicenses);
      if (object.mcDefaults) {
        if (!Array.isArray(object.mcDefaults))
          throw TypeError(".Enterprise.MSPPermits.mcDefaults: array expected");
        message.mcDefaults = [];
        for (let i = 0; i < object.mcDefaults.length; ++i) {
          if (typeof object.mcDefaults[i] !== "object")
            throw TypeError(".Enterprise.MSPPermits.mcDefaults: object expected");
          message.mcDefaults[i] = $root.Enterprise.MCDefault.fromObject(object.mcDefaults[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a MSPPermits message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {Enterprise.MSPPermits} message MSPPermits
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MSPPermits.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.allowedMcProducts = [];
        object.allowedAddOns = [];
        object.mcDefaults = [];
      }
      if (options.defaults) {
        object.restricted = false;
        object.maxAllowedLicenses = 0;
        object.maxFilePlanType = "";
        object.allowUnlimitedLicenses = false;
      }
      if (message.restricted != null && message.hasOwnProperty("restricted"))
        object.restricted = message.restricted;
      if (message.maxAllowedLicenses != null && message.hasOwnProperty("maxAllowedLicenses"))
        object.maxAllowedLicenses = message.maxAllowedLicenses;
      if (message.allowedMcProducts && message.allowedMcProducts.length) {
        object.allowedMcProducts = [];
        for (let j = 0; j < message.allowedMcProducts.length; ++j)
          object.allowedMcProducts[j] = message.allowedMcProducts[j];
      }
      if (message.allowedAddOns && message.allowedAddOns.length) {
        object.allowedAddOns = [];
        for (let j = 0; j < message.allowedAddOns.length; ++j)
          object.allowedAddOns[j] = message.allowedAddOns[j];
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        object.maxFilePlanType = message.maxFilePlanType;
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        object.allowUnlimitedLicenses = message.allowUnlimitedLicenses;
      if (message.mcDefaults && message.mcDefaults.length) {
        object.mcDefaults = [];
        for (let j = 0; j < message.mcDefaults.length; ++j)
          object.mcDefaults[j] = $root.Enterprise.MCDefault.toObject(
            message.mcDefaults[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this MSPPermits to JSON.
     * @function toJSON
     * @memberof Enterprise.MSPPermits
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MSPPermits.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MSPPermits
     * @function getTypeUrl
     * @memberof Enterprise.MSPPermits
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MSPPermits.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MSPPermits";
    };

    return MSPPermits;
  })();

  Enterprise.License = (function () {
    /**
     * Properties of a License.
     * @memberof Enterprise
     * @interface ILicense
     * @property {boolean|null} [paid] License paid
     * @property {number|null} [numberOfSeats] License numberOfSeats
     * @property {number|Long|null} [expiration] License expiration
     * @property {number|null} [licenseKeyId] License licenseKeyId
     * @property {number|null} [productTypeId] License productTypeId
     * @property {string|null} [name] License name
     * @property {number|Long|null} [enterpriseLicenseId] License enterpriseLicenseId
     * @property {number|null} [seatsAllocated] License seatsAllocated
     * @property {number|null} [seatsPending] License seatsPending
     * @property {number|null} [tier] License tier
     * @property {number|null} [filePlanTypeId] License filePlanTypeId
     * @property {number|Long|null} [maxBytes] License maxBytes
     * @property {number|Long|null} [storageExpiration] License storageExpiration
     * @property {string|null} [licenseStatus] License licenseStatus
     * @property {Array.<Enterprise.IMSPPool>|null} [mspPool] License mspPool
     * @property {Enterprise.IMSPContact|null} [managedBy] License managedBy
     * @property {Array.<Enterprise.ILicenseAddOn>|null} [addOns] License addOns
     * @property {number|Long|null} [nextBillingDate] License nextBillingDate
     * @property {boolean|null} [hasMSPLegacyLog] License hasMSPLegacyLog
     * @property {Enterprise.IMSPPermits|null} [mspPermits] License mspPermits
     * @property {boolean|null} [distributor] License distributor
     */

    /**
     * Constructs a new License.
     * @memberof Enterprise
     * @classdesc Represents a License.
     * @implements ILicense
     * @constructor
     * @param {Enterprise.ILicense=} [properties] Properties to set
     */
    function License(properties) {
      this.mspPool = [];
      this.addOns = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * License paid.
     * @member {boolean} paid
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.paid = false;

    /**
     * License numberOfSeats.
     * @member {number} numberOfSeats
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.numberOfSeats = 0;

    /**
     * License expiration.
     * @member {number|Long} expiration
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * License licenseKeyId.
     * @member {number} licenseKeyId
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.licenseKeyId = 0;

    /**
     * License productTypeId.
     * @member {number} productTypeId
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.productTypeId = 0;

    /**
     * License name.
     * @member {string} name
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.name = "";

    /**
     * License enterpriseLicenseId.
     * @member {number|Long} enterpriseLicenseId
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.enterpriseLicenseId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * License seatsAllocated.
     * @member {number} seatsAllocated
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.seatsAllocated = 0;

    /**
     * License seatsPending.
     * @member {number} seatsPending
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.seatsPending = 0;

    /**
     * License tier.
     * @member {number} tier
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.tier = 0;

    /**
     * License filePlanTypeId.
     * @member {number} filePlanTypeId
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.filePlanTypeId = 0;

    /**
     * License maxBytes.
     * @member {number|Long} maxBytes
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * License storageExpiration.
     * @member {number|Long} storageExpiration
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.storageExpiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * License licenseStatus.
     * @member {string} licenseStatus
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.licenseStatus = "";

    /**
     * License mspPool.
     * @member {Array.<Enterprise.IMSPPool>} mspPool
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.mspPool = $util.emptyArray;

    /**
     * License managedBy.
     * @member {Enterprise.IMSPContact|null|undefined} managedBy
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.managedBy = null;

    /**
     * License addOns.
     * @member {Array.<Enterprise.ILicenseAddOn>} addOns
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.addOns = $util.emptyArray;

    /**
     * License nextBillingDate.
     * @member {number|Long} nextBillingDate
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.nextBillingDate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * License hasMSPLegacyLog.
     * @member {boolean} hasMSPLegacyLog
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.hasMSPLegacyLog = false;

    /**
     * License mspPermits.
     * @member {Enterprise.IMSPPermits|null|undefined} mspPermits
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.mspPermits = null;

    /**
     * License distributor.
     * @member {boolean} distributor
     * @memberof Enterprise.License
     * @instance
     */
    License.prototype.distributor = false;

    /**
     * Creates a new License instance using the specified properties.
     * @function create
     * @memberof Enterprise.License
     * @static
     * @param {Enterprise.ILicense=} [properties] Properties to set
     * @returns {Enterprise.License} License instance
     */
    License.create = function create(properties) {
      return new License(properties);
    };

    /**
     * Encodes the specified License message. Does not implicitly {@link Enterprise.License.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.License
     * @static
     * @param {Enterprise.ILicense} message License message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    License.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.paid != null && Object.hasOwnProperty.call(message, "paid"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.paid);
      if (message.numberOfSeats != null && Object.hasOwnProperty.call(message, "numberOfSeats"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.numberOfSeats);
      if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.expiration);
      if (message.licenseKeyId != null && Object.hasOwnProperty.call(message, "licenseKeyId"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.licenseKeyId);
      if (message.productTypeId != null && Object.hasOwnProperty.call(message, "productTypeId"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.productTypeId);
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.name);
      if (
        message.enterpriseLicenseId != null &&
        Object.hasOwnProperty.call(message, "enterpriseLicenseId")
      )
        writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.enterpriseLicenseId);
      if (message.seatsAllocated != null && Object.hasOwnProperty.call(message, "seatsAllocated"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.seatsAllocated);
      if (message.seatsPending != null && Object.hasOwnProperty.call(message, "seatsPending"))
        writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.seatsPending);
      if (message.tier != null && Object.hasOwnProperty.call(message, "tier"))
        writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.tier);
      if (message.filePlanTypeId != null && Object.hasOwnProperty.call(message, "filePlanTypeId"))
        writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.filePlanTypeId);
      if (message.maxBytes != null && Object.hasOwnProperty.call(message, "maxBytes"))
        writer.uint32(/* id 12, wireType 0 =*/ 96).int64(message.maxBytes);
      if (
        message.storageExpiration != null &&
        Object.hasOwnProperty.call(message, "storageExpiration")
      )
        writer.uint32(/* id 13, wireType 0 =*/ 104).int64(message.storageExpiration);
      if (message.licenseStatus != null && Object.hasOwnProperty.call(message, "licenseStatus"))
        writer.uint32(/* id 14, wireType 2 =*/ 114).string(message.licenseStatus);
      if (message.mspPool != null && message.mspPool.length)
        for (let i = 0; i < message.mspPool.length; ++i)
          $root.Enterprise.MSPPool.encode(
            message.mspPool[i],
            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),
          ).ldelim();
      if (message.managedBy != null && Object.hasOwnProperty.call(message, "managedBy"))
        $root.Enterprise.MSPContact.encode(
          message.managedBy,
          writer.uint32(/* id 16, wireType 2 =*/ 130).fork(),
        ).ldelim();
      if (message.addOns != null && message.addOns.length)
        for (let i = 0; i < message.addOns.length; ++i)
          $root.Enterprise.LicenseAddOn.encode(
            message.addOns[i],
            writer.uint32(/* id 17, wireType 2 =*/ 138).fork(),
          ).ldelim();
      if (message.nextBillingDate != null && Object.hasOwnProperty.call(message, "nextBillingDate"))
        writer.uint32(/* id 18, wireType 0 =*/ 144).int64(message.nextBillingDate);
      if (message.hasMSPLegacyLog != null && Object.hasOwnProperty.call(message, "hasMSPLegacyLog"))
        writer.uint32(/* id 19, wireType 0 =*/ 152).bool(message.hasMSPLegacyLog);
      if (message.mspPermits != null && Object.hasOwnProperty.call(message, "mspPermits"))
        $root.Enterprise.MSPPermits.encode(
          message.mspPermits,
          writer.uint32(/* id 20, wireType 2 =*/ 162).fork(),
        ).ldelim();
      if (message.distributor != null && Object.hasOwnProperty.call(message, "distributor"))
        writer.uint32(/* id 21, wireType 0 =*/ 168).bool(message.distributor);
      return writer;
    };

    /**
     * Encodes the specified License message, length delimited. Does not implicitly {@link Enterprise.License.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.License
     * @static
     * @param {Enterprise.ILicense} message License message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    License.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a License message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.License
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.License} License
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    License.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.License();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.paid = reader.bool();
            break;
          }
          case 2: {
            message.numberOfSeats = reader.int32();
            break;
          }
          case 3: {
            message.expiration = reader.int64();
            break;
          }
          case 4: {
            message.licenseKeyId = reader.int32();
            break;
          }
          case 5: {
            message.productTypeId = reader.int32();
            break;
          }
          case 6: {
            message.name = reader.string();
            break;
          }
          case 7: {
            message.enterpriseLicenseId = reader.int64();
            break;
          }
          case 8: {
            message.seatsAllocated = reader.int32();
            break;
          }
          case 9: {
            message.seatsPending = reader.int32();
            break;
          }
          case 10: {
            message.tier = reader.int32();
            break;
          }
          case 11: {
            message.filePlanTypeId = reader.int32();
            break;
          }
          case 12: {
            message.maxBytes = reader.int64();
            break;
          }
          case 13: {
            message.storageExpiration = reader.int64();
            break;
          }
          case 14: {
            message.licenseStatus = reader.string();
            break;
          }
          case 15: {
            if (!(message.mspPool && message.mspPool.length)) message.mspPool = [];
            message.mspPool.push($root.Enterprise.MSPPool.decode(reader, reader.uint32()));
            break;
          }
          case 16: {
            message.managedBy = $root.Enterprise.MSPContact.decode(reader, reader.uint32());
            break;
          }
          case 17: {
            if (!(message.addOns && message.addOns.length)) message.addOns = [];
            message.addOns.push($root.Enterprise.LicenseAddOn.decode(reader, reader.uint32()));
            break;
          }
          case 18: {
            message.nextBillingDate = reader.int64();
            break;
          }
          case 19: {
            message.hasMSPLegacyLog = reader.bool();
            break;
          }
          case 20: {
            message.mspPermits = $root.Enterprise.MSPPermits.decode(reader, reader.uint32());
            break;
          }
          case 21: {
            message.distributor = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a License message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.License
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.License} License
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    License.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a License message.
     * @function verify
     * @memberof Enterprise.License
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    License.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.paid != null && message.hasOwnProperty("paid"))
        if (typeof message.paid !== "boolean") return "paid: boolean expected";
      if (message.numberOfSeats != null && message.hasOwnProperty("numberOfSeats"))
        if (!$util.isInteger(message.numberOfSeats)) return "numberOfSeats: integer expected";
      if (message.expiration != null && message.hasOwnProperty("expiration"))
        if (
          !$util.isInteger(message.expiration) &&
          !(
            message.expiration &&
            $util.isInteger(message.expiration.low) &&
            $util.isInteger(message.expiration.high)
          )
        )
          return "expiration: integer|Long expected";
      if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
        if (!$util.isInteger(message.licenseKeyId)) return "licenseKeyId: integer expected";
      if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
        if (!$util.isInteger(message.productTypeId)) return "productTypeId: integer expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.enterpriseLicenseId != null && message.hasOwnProperty("enterpriseLicenseId"))
        if (
          !$util.isInteger(message.enterpriseLicenseId) &&
          !(
            message.enterpriseLicenseId &&
            $util.isInteger(message.enterpriseLicenseId.low) &&
            $util.isInteger(message.enterpriseLicenseId.high)
          )
        )
          return "enterpriseLicenseId: integer|Long expected";
      if (message.seatsAllocated != null && message.hasOwnProperty("seatsAllocated"))
        if (!$util.isInteger(message.seatsAllocated)) return "seatsAllocated: integer expected";
      if (message.seatsPending != null && message.hasOwnProperty("seatsPending"))
        if (!$util.isInteger(message.seatsPending)) return "seatsPending: integer expected";
      if (message.tier != null && message.hasOwnProperty("tier"))
        if (!$util.isInteger(message.tier)) return "tier: integer expected";
      if (message.filePlanTypeId != null && message.hasOwnProperty("filePlanTypeId"))
        if (!$util.isInteger(message.filePlanTypeId)) return "filePlanTypeId: integer expected";
      if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
        if (
          !$util.isInteger(message.maxBytes) &&
          !(
            message.maxBytes &&
            $util.isInteger(message.maxBytes.low) &&
            $util.isInteger(message.maxBytes.high)
          )
        )
          return "maxBytes: integer|Long expected";
      if (message.storageExpiration != null && message.hasOwnProperty("storageExpiration"))
        if (
          !$util.isInteger(message.storageExpiration) &&
          !(
            message.storageExpiration &&
            $util.isInteger(message.storageExpiration.low) &&
            $util.isInteger(message.storageExpiration.high)
          )
        )
          return "storageExpiration: integer|Long expected";
      if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
        if (!$util.isString(message.licenseStatus)) return "licenseStatus: string expected";
      if (message.mspPool != null && message.hasOwnProperty("mspPool")) {
        if (!Array.isArray(message.mspPool)) return "mspPool: array expected";
        for (let i = 0; i < message.mspPool.length; ++i) {
          let error = $root.Enterprise.MSPPool.verify(message.mspPool[i]);
          if (error) return "mspPool." + error;
        }
      }
      if (message.managedBy != null && message.hasOwnProperty("managedBy")) {
        let error = $root.Enterprise.MSPContact.verify(message.managedBy);
        if (error) return "managedBy." + error;
      }
      if (message.addOns != null && message.hasOwnProperty("addOns")) {
        if (!Array.isArray(message.addOns)) return "addOns: array expected";
        for (let i = 0; i < message.addOns.length; ++i) {
          let error = $root.Enterprise.LicenseAddOn.verify(message.addOns[i]);
          if (error) return "addOns." + error;
        }
      }
      if (message.nextBillingDate != null && message.hasOwnProperty("nextBillingDate"))
        if (
          !$util.isInteger(message.nextBillingDate) &&
          !(
            message.nextBillingDate &&
            $util.isInteger(message.nextBillingDate.low) &&
            $util.isInteger(message.nextBillingDate.high)
          )
        )
          return "nextBillingDate: integer|Long expected";
      if (message.hasMSPLegacyLog != null && message.hasOwnProperty("hasMSPLegacyLog"))
        if (typeof message.hasMSPLegacyLog !== "boolean")
          return "hasMSPLegacyLog: boolean expected";
      if (message.mspPermits != null && message.hasOwnProperty("mspPermits")) {
        let error = $root.Enterprise.MSPPermits.verify(message.mspPermits);
        if (error) return "mspPermits." + error;
      }
      if (message.distributor != null && message.hasOwnProperty("distributor"))
        if (typeof message.distributor !== "boolean") return "distributor: boolean expected";
      return null;
    };

    /**
     * Creates a License message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.License
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.License} License
     */
    License.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.License) return object;
      let message = new $root.Enterprise.License();
      if (object.paid != null) message.paid = Boolean(object.paid);
      if (object.numberOfSeats != null) message.numberOfSeats = object.numberOfSeats | 0;
      if (object.expiration != null)
        if ($util.Long)
          (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
        else if (typeof object.expiration === "string")
          message.expiration = parseInt(object.expiration, 10);
        else if (typeof object.expiration === "number") message.expiration = object.expiration;
        else if (typeof object.expiration === "object")
          message.expiration = new $util.LongBits(
            object.expiration.low >>> 0,
            object.expiration.high >>> 0,
          ).toNumber();
      if (object.licenseKeyId != null) message.licenseKeyId = object.licenseKeyId | 0;
      if (object.productTypeId != null) message.productTypeId = object.productTypeId | 0;
      if (object.name != null) message.name = String(object.name);
      if (object.enterpriseLicenseId != null)
        if ($util.Long)
          (message.enterpriseLicenseId = $util.Long.fromValue(
            object.enterpriseLicenseId,
          )).unsigned = false;
        else if (typeof object.enterpriseLicenseId === "string")
          message.enterpriseLicenseId = parseInt(object.enterpriseLicenseId, 10);
        else if (typeof object.enterpriseLicenseId === "number")
          message.enterpriseLicenseId = object.enterpriseLicenseId;
        else if (typeof object.enterpriseLicenseId === "object")
          message.enterpriseLicenseId = new $util.LongBits(
            object.enterpriseLicenseId.low >>> 0,
            object.enterpriseLicenseId.high >>> 0,
          ).toNumber();
      if (object.seatsAllocated != null) message.seatsAllocated = object.seatsAllocated | 0;
      if (object.seatsPending != null) message.seatsPending = object.seatsPending | 0;
      if (object.tier != null) message.tier = object.tier | 0;
      if (object.filePlanTypeId != null) message.filePlanTypeId = object.filePlanTypeId | 0;
      if (object.maxBytes != null)
        if ($util.Long) (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = false;
        else if (typeof object.maxBytes === "string")
          message.maxBytes = parseInt(object.maxBytes, 10);
        else if (typeof object.maxBytes === "number") message.maxBytes = object.maxBytes;
        else if (typeof object.maxBytes === "object")
          message.maxBytes = new $util.LongBits(
            object.maxBytes.low >>> 0,
            object.maxBytes.high >>> 0,
          ).toNumber();
      if (object.storageExpiration != null)
        if ($util.Long)
          (message.storageExpiration = $util.Long.fromValue(object.storageExpiration)).unsigned =
            false;
        else if (typeof object.storageExpiration === "string")
          message.storageExpiration = parseInt(object.storageExpiration, 10);
        else if (typeof object.storageExpiration === "number")
          message.storageExpiration = object.storageExpiration;
        else if (typeof object.storageExpiration === "object")
          message.storageExpiration = new $util.LongBits(
            object.storageExpiration.low >>> 0,
            object.storageExpiration.high >>> 0,
          ).toNumber();
      if (object.licenseStatus != null) message.licenseStatus = String(object.licenseStatus);
      if (object.mspPool) {
        if (!Array.isArray(object.mspPool))
          throw TypeError(".Enterprise.License.mspPool: array expected");
        message.mspPool = [];
        for (let i = 0; i < object.mspPool.length; ++i) {
          if (typeof object.mspPool[i] !== "object")
            throw TypeError(".Enterprise.License.mspPool: object expected");
          message.mspPool[i] = $root.Enterprise.MSPPool.fromObject(object.mspPool[i]);
        }
      }
      if (object.managedBy != null) {
        if (typeof object.managedBy !== "object")
          throw TypeError(".Enterprise.License.managedBy: object expected");
        message.managedBy = $root.Enterprise.MSPContact.fromObject(object.managedBy);
      }
      if (object.addOns) {
        if (!Array.isArray(object.addOns))
          throw TypeError(".Enterprise.License.addOns: array expected");
        message.addOns = [];
        for (let i = 0; i < object.addOns.length; ++i) {
          if (typeof object.addOns[i] !== "object")
            throw TypeError(".Enterprise.License.addOns: object expected");
          message.addOns[i] = $root.Enterprise.LicenseAddOn.fromObject(object.addOns[i]);
        }
      }
      if (object.nextBillingDate != null)
        if ($util.Long)
          (message.nextBillingDate = $util.Long.fromValue(object.nextBillingDate)).unsigned = false;
        else if (typeof object.nextBillingDate === "string")
          message.nextBillingDate = parseInt(object.nextBillingDate, 10);
        else if (typeof object.nextBillingDate === "number")
          message.nextBillingDate = object.nextBillingDate;
        else if (typeof object.nextBillingDate === "object")
          message.nextBillingDate = new $util.LongBits(
            object.nextBillingDate.low >>> 0,
            object.nextBillingDate.high >>> 0,
          ).toNumber();
      if (object.hasMSPLegacyLog != null) message.hasMSPLegacyLog = Boolean(object.hasMSPLegacyLog);
      if (object.mspPermits != null) {
        if (typeof object.mspPermits !== "object")
          throw TypeError(".Enterprise.License.mspPermits: object expected");
        message.mspPermits = $root.Enterprise.MSPPermits.fromObject(object.mspPermits);
      }
      if (object.distributor != null) message.distributor = Boolean(object.distributor);
      return message;
    };

    /**
     * Creates a plain object from a License message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.License
     * @static
     * @param {Enterprise.License} message License
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    License.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.mspPool = [];
        object.addOns = [];
      }
      if (options.defaults) {
        object.paid = false;
        object.numberOfSeats = 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.expiration =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.expiration = options.longs === String ? "0" : 0;
        object.licenseKeyId = 0;
        object.productTypeId = 0;
        object.name = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseLicenseId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseLicenseId = options.longs === String ? "0" : 0;
        object.seatsAllocated = 0;
        object.seatsPending = 0;
        object.tier = 0;
        object.filePlanTypeId = 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.maxBytes =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.maxBytes = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.storageExpiration =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.storageExpiration = options.longs === String ? "0" : 0;
        object.licenseStatus = "";
        object.managedBy = null;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nextBillingDate =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nextBillingDate = options.longs === String ? "0" : 0;
        object.hasMSPLegacyLog = false;
        object.mspPermits = null;
        object.distributor = false;
      }
      if (message.paid != null && message.hasOwnProperty("paid")) object.paid = message.paid;
      if (message.numberOfSeats != null && message.hasOwnProperty("numberOfSeats"))
        object.numberOfSeats = message.numberOfSeats;
      if (message.expiration != null && message.hasOwnProperty("expiration"))
        if (typeof message.expiration === "number")
          object.expiration =
            options.longs === String ? String(message.expiration) : message.expiration;
        else
          object.expiration =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.expiration)
              : options.longs === Number
                ? new $util.LongBits(
                    message.expiration.low >>> 0,
                    message.expiration.high >>> 0,
                  ).toNumber()
                : message.expiration;
      if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
        object.licenseKeyId = message.licenseKeyId;
      if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
        object.productTypeId = message.productTypeId;
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.enterpriseLicenseId != null && message.hasOwnProperty("enterpriseLicenseId"))
        if (typeof message.enterpriseLicenseId === "number")
          object.enterpriseLicenseId =
            options.longs === String
              ? String(message.enterpriseLicenseId)
              : message.enterpriseLicenseId;
        else
          object.enterpriseLicenseId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseLicenseId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseLicenseId.low >>> 0,
                    message.enterpriseLicenseId.high >>> 0,
                  ).toNumber()
                : message.enterpriseLicenseId;
      if (message.seatsAllocated != null && message.hasOwnProperty("seatsAllocated"))
        object.seatsAllocated = message.seatsAllocated;
      if (message.seatsPending != null && message.hasOwnProperty("seatsPending"))
        object.seatsPending = message.seatsPending;
      if (message.tier != null && message.hasOwnProperty("tier")) object.tier = message.tier;
      if (message.filePlanTypeId != null && message.hasOwnProperty("filePlanTypeId"))
        object.filePlanTypeId = message.filePlanTypeId;
      if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
        if (typeof message.maxBytes === "number")
          object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
        else
          object.maxBytes =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.maxBytes)
              : options.longs === Number
                ? new $util.LongBits(
                    message.maxBytes.low >>> 0,
                    message.maxBytes.high >>> 0,
                  ).toNumber()
                : message.maxBytes;
      if (message.storageExpiration != null && message.hasOwnProperty("storageExpiration"))
        if (typeof message.storageExpiration === "number")
          object.storageExpiration =
            options.longs === String
              ? String(message.storageExpiration)
              : message.storageExpiration;
        else
          object.storageExpiration =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.storageExpiration)
              : options.longs === Number
                ? new $util.LongBits(
                    message.storageExpiration.low >>> 0,
                    message.storageExpiration.high >>> 0,
                  ).toNumber()
                : message.storageExpiration;
      if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
        object.licenseStatus = message.licenseStatus;
      if (message.mspPool && message.mspPool.length) {
        object.mspPool = [];
        for (let j = 0; j < message.mspPool.length; ++j)
          object.mspPool[j] = $root.Enterprise.MSPPool.toObject(message.mspPool[j], options);
      }
      if (message.managedBy != null && message.hasOwnProperty("managedBy"))
        object.managedBy = $root.Enterprise.MSPContact.toObject(message.managedBy, options);
      if (message.addOns && message.addOns.length) {
        object.addOns = [];
        for (let j = 0; j < message.addOns.length; ++j)
          object.addOns[j] = $root.Enterprise.LicenseAddOn.toObject(message.addOns[j], options);
      }
      if (message.nextBillingDate != null && message.hasOwnProperty("nextBillingDate"))
        if (typeof message.nextBillingDate === "number")
          object.nextBillingDate =
            options.longs === String ? String(message.nextBillingDate) : message.nextBillingDate;
        else
          object.nextBillingDate =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nextBillingDate)
              : options.longs === Number
                ? new $util.LongBits(
                    message.nextBillingDate.low >>> 0,
                    message.nextBillingDate.high >>> 0,
                  ).toNumber()
                : message.nextBillingDate;
      if (message.hasMSPLegacyLog != null && message.hasOwnProperty("hasMSPLegacyLog"))
        object.hasMSPLegacyLog = message.hasMSPLegacyLog;
      if (message.mspPermits != null && message.hasOwnProperty("mspPermits"))
        object.mspPermits = $root.Enterprise.MSPPermits.toObject(message.mspPermits, options);
      if (message.distributor != null && message.hasOwnProperty("distributor"))
        object.distributor = message.distributor;
      return object;
    };

    /**
     * Converts this License to JSON.
     * @function toJSON
     * @memberof Enterprise.License
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    License.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for License
     * @function getTypeUrl
     * @memberof Enterprise.License
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    License.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.License";
    };

    return License;
  })();

  Enterprise.Bridge = (function () {
    /**
     * Properties of a Bridge.
     * @memberof Enterprise
     * @interface IBridge
     * @property {number|Long|null} [bridgeId] Bridge bridgeId
     * @property {number|Long|null} [nodeId] Bridge nodeId
     * @property {string|null} [wanIpEnforcement] Bridge wanIpEnforcement
     * @property {string|null} [lanIpEnforcement] Bridge lanIpEnforcement
     * @property {string|null} [status] Bridge status
     */

    /**
     * Constructs a new Bridge.
     * @memberof Enterprise
     * @classdesc Represents a Bridge.
     * @implements IBridge
     * @constructor
     * @param {Enterprise.IBridge=} [properties] Properties to set
     */
    function Bridge(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Bridge bridgeId.
     * @member {number|Long} bridgeId
     * @memberof Enterprise.Bridge
     * @instance
     */
    Bridge.prototype.bridgeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Bridge nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.Bridge
     * @instance
     */
    Bridge.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Bridge wanIpEnforcement.
     * @member {string} wanIpEnforcement
     * @memberof Enterprise.Bridge
     * @instance
     */
    Bridge.prototype.wanIpEnforcement = "";

    /**
     * Bridge lanIpEnforcement.
     * @member {string} lanIpEnforcement
     * @memberof Enterprise.Bridge
     * @instance
     */
    Bridge.prototype.lanIpEnforcement = "";

    /**
     * Bridge status.
     * @member {string} status
     * @memberof Enterprise.Bridge
     * @instance
     */
    Bridge.prototype.status = "";

    /**
     * Creates a new Bridge instance using the specified properties.
     * @function create
     * @memberof Enterprise.Bridge
     * @static
     * @param {Enterprise.IBridge=} [properties] Properties to set
     * @returns {Enterprise.Bridge} Bridge instance
     */
    Bridge.create = function create(properties) {
      return new Bridge(properties);
    };

    /**
     * Encodes the specified Bridge message. Does not implicitly {@link Enterprise.Bridge.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Bridge
     * @static
     * @param {Enterprise.IBridge} message Bridge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bridge.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.bridgeId != null && Object.hasOwnProperty.call(message, "bridgeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.bridgeId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (
        message.wanIpEnforcement != null &&
        Object.hasOwnProperty.call(message, "wanIpEnforcement")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.wanIpEnforcement);
      if (
        message.lanIpEnforcement != null &&
        Object.hasOwnProperty.call(message, "lanIpEnforcement")
      )
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.lanIpEnforcement);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.status);
      return writer;
    };

    /**
     * Encodes the specified Bridge message, length delimited. Does not implicitly {@link Enterprise.Bridge.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Bridge
     * @static
     * @param {Enterprise.IBridge} message Bridge message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Bridge.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Bridge message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Bridge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Bridge} Bridge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bridge.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Bridge();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.bridgeId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.wanIpEnforcement = reader.string();
            break;
          }
          case 4: {
            message.lanIpEnforcement = reader.string();
            break;
          }
          case 5: {
            message.status = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Bridge message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Bridge
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Bridge} Bridge
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Bridge.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Bridge message.
     * @function verify
     * @memberof Enterprise.Bridge
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Bridge.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.bridgeId != null && message.hasOwnProperty("bridgeId"))
        if (
          !$util.isInteger(message.bridgeId) &&
          !(
            message.bridgeId &&
            $util.isInteger(message.bridgeId.low) &&
            $util.isInteger(message.bridgeId.high)
          )
        )
          return "bridgeId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.wanIpEnforcement != null && message.hasOwnProperty("wanIpEnforcement"))
        if (!$util.isString(message.wanIpEnforcement)) return "wanIpEnforcement: string expected";
      if (message.lanIpEnforcement != null && message.hasOwnProperty("lanIpEnforcement"))
        if (!$util.isString(message.lanIpEnforcement)) return "lanIpEnforcement: string expected";
      if (message.status != null && message.hasOwnProperty("status"))
        if (!$util.isString(message.status)) return "status: string expected";
      return null;
    };

    /**
     * Creates a Bridge message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Bridge
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Bridge} Bridge
     */
    Bridge.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Bridge) return object;
      let message = new $root.Enterprise.Bridge();
      if (object.bridgeId != null)
        if ($util.Long) (message.bridgeId = $util.Long.fromValue(object.bridgeId)).unsigned = false;
        else if (typeof object.bridgeId === "string")
          message.bridgeId = parseInt(object.bridgeId, 10);
        else if (typeof object.bridgeId === "number") message.bridgeId = object.bridgeId;
        else if (typeof object.bridgeId === "object")
          message.bridgeId = new $util.LongBits(
            object.bridgeId.low >>> 0,
            object.bridgeId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.wanIpEnforcement != null)
        message.wanIpEnforcement = String(object.wanIpEnforcement);
      if (object.lanIpEnforcement != null)
        message.lanIpEnforcement = String(object.lanIpEnforcement);
      if (object.status != null) message.status = String(object.status);
      return message;
    };

    /**
     * Creates a plain object from a Bridge message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Bridge
     * @static
     * @param {Enterprise.Bridge} message Bridge
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Bridge.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.bridgeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.bridgeId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.wanIpEnforcement = "";
        object.lanIpEnforcement = "";
        object.status = "";
      }
      if (message.bridgeId != null && message.hasOwnProperty("bridgeId"))
        if (typeof message.bridgeId === "number")
          object.bridgeId = options.longs === String ? String(message.bridgeId) : message.bridgeId;
        else
          object.bridgeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.bridgeId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.bridgeId.low >>> 0,
                    message.bridgeId.high >>> 0,
                  ).toNumber()
                : message.bridgeId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.wanIpEnforcement != null && message.hasOwnProperty("wanIpEnforcement"))
        object.wanIpEnforcement = message.wanIpEnforcement;
      if (message.lanIpEnforcement != null && message.hasOwnProperty("lanIpEnforcement"))
        object.lanIpEnforcement = message.lanIpEnforcement;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status = message.status;
      return object;
    };

    /**
     * Converts this Bridge to JSON.
     * @function toJSON
     * @memberof Enterprise.Bridge
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Bridge.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Bridge
     * @function getTypeUrl
     * @memberof Enterprise.Bridge
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Bridge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Bridge";
    };

    return Bridge;
  })();

  Enterprise.Scim = (function () {
    /**
     * Properties of a Scim.
     * @memberof Enterprise
     * @interface IScim
     * @property {number|Long|null} [scimId] Scim scimId
     * @property {number|Long|null} [nodeId] Scim nodeId
     * @property {string|null} [status] Scim status
     * @property {number|Long|null} [lastSynced] Scim lastSynced
     * @property {string|null} [rolePrefix] Scim rolePrefix
     * @property {boolean|null} [uniqueGroups] Scim uniqueGroups
     */

    /**
     * Constructs a new Scim.
     * @memberof Enterprise
     * @classdesc Represents a Scim.
     * @implements IScim
     * @constructor
     * @param {Enterprise.IScim=} [properties] Properties to set
     */
    function Scim(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * Scim scimId.
     * @member {number|Long} scimId
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.scimId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Scim nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Scim status.
     * @member {string} status
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.status = "";

    /**
     * Scim lastSynced.
     * @member {number|Long} lastSynced
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.lastSynced = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Scim rolePrefix.
     * @member {string} rolePrefix
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.rolePrefix = "";

    /**
     * Scim uniqueGroups.
     * @member {boolean} uniqueGroups
     * @memberof Enterprise.Scim
     * @instance
     */
    Scim.prototype.uniqueGroups = false;

    /**
     * Creates a new Scim instance using the specified properties.
     * @function create
     * @memberof Enterprise.Scim
     * @static
     * @param {Enterprise.IScim=} [properties] Properties to set
     * @returns {Enterprise.Scim} Scim instance
     */
    Scim.create = function create(properties) {
      return new Scim(properties);
    };

    /**
     * Encodes the specified Scim message. Does not implicitly {@link Enterprise.Scim.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.Scim
     * @static
     * @param {Enterprise.IScim} message Scim message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Scim.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.scimId != null && Object.hasOwnProperty.call(message, "scimId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.scimId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.status);
      if (message.lastSynced != null && Object.hasOwnProperty.call(message, "lastSynced"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.lastSynced);
      if (message.rolePrefix != null && Object.hasOwnProperty.call(message, "rolePrefix"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.rolePrefix);
      if (message.uniqueGroups != null && Object.hasOwnProperty.call(message, "uniqueGroups"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.uniqueGroups);
      return writer;
    };

    /**
     * Encodes the specified Scim message, length delimited. Does not implicitly {@link Enterprise.Scim.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.Scim
     * @static
     * @param {Enterprise.IScim} message Scim message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Scim.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Scim message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.Scim
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.Scim} Scim
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Scim.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.Scim();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.scimId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.status = reader.string();
            break;
          }
          case 4: {
            message.lastSynced = reader.int64();
            break;
          }
          case 5: {
            message.rolePrefix = reader.string();
            break;
          }
          case 6: {
            message.uniqueGroups = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a Scim message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.Scim
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.Scim} Scim
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Scim.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Scim message.
     * @function verify
     * @memberof Enterprise.Scim
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Scim.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.scimId != null && message.hasOwnProperty("scimId"))
        if (
          !$util.isInteger(message.scimId) &&
          !(
            message.scimId &&
            $util.isInteger(message.scimId.low) &&
            $util.isInteger(message.scimId.high)
          )
        )
          return "scimId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.status != null && message.hasOwnProperty("status"))
        if (!$util.isString(message.status)) return "status: string expected";
      if (message.lastSynced != null && message.hasOwnProperty("lastSynced"))
        if (
          !$util.isInteger(message.lastSynced) &&
          !(
            message.lastSynced &&
            $util.isInteger(message.lastSynced.low) &&
            $util.isInteger(message.lastSynced.high)
          )
        )
          return "lastSynced: integer|Long expected";
      if (message.rolePrefix != null && message.hasOwnProperty("rolePrefix"))
        if (!$util.isString(message.rolePrefix)) return "rolePrefix: string expected";
      if (message.uniqueGroups != null && message.hasOwnProperty("uniqueGroups"))
        if (typeof message.uniqueGroups !== "boolean") return "uniqueGroups: boolean expected";
      return null;
    };

    /**
     * Creates a Scim message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.Scim
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.Scim} Scim
     */
    Scim.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.Scim) return object;
      let message = new $root.Enterprise.Scim();
      if (object.scimId != null)
        if ($util.Long) (message.scimId = $util.Long.fromValue(object.scimId)).unsigned = false;
        else if (typeof object.scimId === "string") message.scimId = parseInt(object.scimId, 10);
        else if (typeof object.scimId === "number") message.scimId = object.scimId;
        else if (typeof object.scimId === "object")
          message.scimId = new $util.LongBits(
            object.scimId.low >>> 0,
            object.scimId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.status != null) message.status = String(object.status);
      if (object.lastSynced != null)
        if ($util.Long)
          (message.lastSynced = $util.Long.fromValue(object.lastSynced)).unsigned = false;
        else if (typeof object.lastSynced === "string")
          message.lastSynced = parseInt(object.lastSynced, 10);
        else if (typeof object.lastSynced === "number") message.lastSynced = object.lastSynced;
        else if (typeof object.lastSynced === "object")
          message.lastSynced = new $util.LongBits(
            object.lastSynced.low >>> 0,
            object.lastSynced.high >>> 0,
          ).toNumber();
      if (object.rolePrefix != null) message.rolePrefix = String(object.rolePrefix);
      if (object.uniqueGroups != null) message.uniqueGroups = Boolean(object.uniqueGroups);
      return message;
    };

    /**
     * Creates a plain object from a Scim message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.Scim
     * @static
     * @param {Enterprise.Scim} message Scim
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Scim.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.scimId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.scimId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.status = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.lastSynced =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.lastSynced = options.longs === String ? "0" : 0;
        object.rolePrefix = "";
        object.uniqueGroups = false;
      }
      if (message.scimId != null && message.hasOwnProperty("scimId"))
        if (typeof message.scimId === "number")
          object.scimId = options.longs === String ? String(message.scimId) : message.scimId;
        else
          object.scimId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.scimId)
              : options.longs === Number
                ? new $util.LongBits(message.scimId.low >>> 0, message.scimId.high >>> 0).toNumber()
                : message.scimId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status = message.status;
      if (message.lastSynced != null && message.hasOwnProperty("lastSynced"))
        if (typeof message.lastSynced === "number")
          object.lastSynced =
            options.longs === String ? String(message.lastSynced) : message.lastSynced;
        else
          object.lastSynced =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.lastSynced)
              : options.longs === Number
                ? new $util.LongBits(
                    message.lastSynced.low >>> 0,
                    message.lastSynced.high >>> 0,
                  ).toNumber()
                : message.lastSynced;
      if (message.rolePrefix != null && message.hasOwnProperty("rolePrefix"))
        object.rolePrefix = message.rolePrefix;
      if (message.uniqueGroups != null && message.hasOwnProperty("uniqueGroups"))
        object.uniqueGroups = message.uniqueGroups;
      return object;
    };

    /**
     * Converts this Scim to JSON.
     * @function toJSON
     * @memberof Enterprise.Scim
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Scim.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Scim
     * @function getTypeUrl
     * @memberof Enterprise.Scim
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Scim.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.Scim";
    };

    return Scim;
  })();

  Enterprise.EmailProvision = (function () {
    /**
     * Properties of an EmailProvision.
     * @memberof Enterprise
     * @interface IEmailProvision
     * @property {number|null} [id] EmailProvision id
     * @property {number|Long|null} [nodeId] EmailProvision nodeId
     * @property {string|null} [domain] EmailProvision domain
     * @property {string|null} [method] EmailProvision method
     */

    /**
     * Constructs a new EmailProvision.
     * @memberof Enterprise
     * @classdesc Represents an EmailProvision.
     * @implements IEmailProvision
     * @constructor
     * @param {Enterprise.IEmailProvision=} [properties] Properties to set
     */
    function EmailProvision(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EmailProvision id.
     * @member {number} id
     * @memberof Enterprise.EmailProvision
     * @instance
     */
    EmailProvision.prototype.id = 0;

    /**
     * EmailProvision nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.EmailProvision
     * @instance
     */
    EmailProvision.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * EmailProvision domain.
     * @member {string} domain
     * @memberof Enterprise.EmailProvision
     * @instance
     */
    EmailProvision.prototype.domain = "";

    /**
     * EmailProvision method.
     * @member {string} method
     * @memberof Enterprise.EmailProvision
     * @instance
     */
    EmailProvision.prototype.method = "";

    /**
     * Creates a new EmailProvision instance using the specified properties.
     * @function create
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Enterprise.IEmailProvision=} [properties] Properties to set
     * @returns {Enterprise.EmailProvision} EmailProvision instance
     */
    EmailProvision.create = function create(properties) {
      return new EmailProvision(properties);
    };

    /**
     * Encodes the specified EmailProvision message. Does not implicitly {@link Enterprise.EmailProvision.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Enterprise.IEmailProvision} message EmailProvision message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmailProvision.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.id != null && Object.hasOwnProperty.call(message, "id"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.domain);
      if (message.method != null && Object.hasOwnProperty.call(message, "method"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.method);
      return writer;
    };

    /**
     * Encodes the specified EmailProvision message, length delimited. Does not implicitly {@link Enterprise.EmailProvision.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Enterprise.IEmailProvision} message EmailProvision message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmailProvision.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EmailProvision message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EmailProvision} EmailProvision
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmailProvision.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EmailProvision();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.id = reader.int32();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.domain = reader.string();
            break;
          }
          case 4: {
            message.method = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EmailProvision message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EmailProvision} EmailProvision
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmailProvision.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EmailProvision message.
     * @function verify
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EmailProvision.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.id != null && message.hasOwnProperty("id"))
        if (!$util.isInteger(message.id)) return "id: integer expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.domain != null && message.hasOwnProperty("domain"))
        if (!$util.isString(message.domain)) return "domain: string expected";
      if (message.method != null && message.hasOwnProperty("method"))
        if (!$util.isString(message.method)) return "method: string expected";
      return null;
    };

    /**
     * Creates an EmailProvision message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EmailProvision} EmailProvision
     */
    EmailProvision.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EmailProvision) return object;
      let message = new $root.Enterprise.EmailProvision();
      if (object.id != null) message.id = object.id | 0;
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.domain != null) message.domain = String(object.domain);
      if (object.method != null) message.method = String(object.method);
      return message;
    };

    /**
     * Creates a plain object from an EmailProvision message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {Enterprise.EmailProvision} message EmailProvision
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EmailProvision.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.id = 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.domain = "";
        object.method = "";
      }
      if (message.id != null && message.hasOwnProperty("id")) object.id = message.id;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.domain != null && message.hasOwnProperty("domain"))
        object.domain = message.domain;
      if (message.method != null && message.hasOwnProperty("method"))
        object.method = message.method;
      return object;
    };

    /**
     * Converts this EmailProvision to JSON.
     * @function toJSON
     * @memberof Enterprise.EmailProvision
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EmailProvision.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EmailProvision
     * @function getTypeUrl
     * @memberof Enterprise.EmailProvision
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EmailProvision.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EmailProvision";
    };

    return EmailProvision;
  })();

  Enterprise.QueuedTeam = (function () {
    /**
     * Properties of a QueuedTeam.
     * @memberof Enterprise
     * @interface IQueuedTeam
     * @property {Uint8Array|null} [teamUid] QueuedTeam teamUid
     * @property {string|null} [name] QueuedTeam name
     * @property {number|Long|null} [nodeId] QueuedTeam nodeId
     * @property {string|null} [encryptedData] QueuedTeam encryptedData
     */

    /**
     * Constructs a new QueuedTeam.
     * @memberof Enterprise
     * @classdesc Represents a QueuedTeam.
     * @implements IQueuedTeam
     * @constructor
     * @param {Enterprise.IQueuedTeam=} [properties] Properties to set
     */
    function QueuedTeam(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * QueuedTeam teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.QueuedTeam
     * @instance
     */
    QueuedTeam.prototype.teamUid = $util.newBuffer([]);

    /**
     * QueuedTeam name.
     * @member {string} name
     * @memberof Enterprise.QueuedTeam
     * @instance
     */
    QueuedTeam.prototype.name = "";

    /**
     * QueuedTeam nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.QueuedTeam
     * @instance
     */
    QueuedTeam.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * QueuedTeam encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.QueuedTeam
     * @instance
     */
    QueuedTeam.prototype.encryptedData = "";

    /**
     * Creates a new QueuedTeam instance using the specified properties.
     * @function create
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Enterprise.IQueuedTeam=} [properties] Properties to set
     * @returns {Enterprise.QueuedTeam} QueuedTeam instance
     */
    QueuedTeam.create = function create(properties) {
      return new QueuedTeam(properties);
    };

    /**
     * Encodes the specified QueuedTeam message. Does not implicitly {@link Enterprise.QueuedTeam.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Enterprise.IQueuedTeam} message QueuedTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueuedTeam.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.encryptedData);
      return writer;
    };

    /**
     * Encodes the specified QueuedTeam message, length delimited. Does not implicitly {@link Enterprise.QueuedTeam.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Enterprise.IQueuedTeam} message QueuedTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueuedTeam.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QueuedTeam message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.QueuedTeam} QueuedTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueuedTeam.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.QueuedTeam();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            message.name = reader.string();
            break;
          }
          case 3: {
            message.nodeId = reader.int64();
            break;
          }
          case 4: {
            message.encryptedData = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a QueuedTeam message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.QueuedTeam} QueuedTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueuedTeam.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QueuedTeam message.
     * @function verify
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QueuedTeam.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      return null;
    };

    /**
     * Creates a QueuedTeam message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.QueuedTeam} QueuedTeam
     */
    QueuedTeam.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.QueuedTeam) return object;
      let message = new $root.Enterprise.QueuedTeam();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.name != null) message.name = String(object.name);
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      return message;
    };

    /**
     * Creates a plain object from a QueuedTeam message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {Enterprise.QueuedTeam} message QueuedTeam
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QueuedTeam.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        object.name = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      return object;
    };

    /**
     * Converts this QueuedTeam to JSON.
     * @function toJSON
     * @memberof Enterprise.QueuedTeam
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QueuedTeam.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for QueuedTeam
     * @function getTypeUrl
     * @memberof Enterprise.QueuedTeam
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    QueuedTeam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.QueuedTeam";
    };

    return QueuedTeam;
  })();

  Enterprise.QueuedTeamUser = (function () {
    /**
     * Properties of a QueuedTeamUser.
     * @memberof Enterprise
     * @interface IQueuedTeamUser
     * @property {Uint8Array|null} [teamUid] QueuedTeamUser teamUid
     * @property {Array.<number|Long>|null} [users] QueuedTeamUser users
     */

    /**
     * Constructs a new QueuedTeamUser.
     * @memberof Enterprise
     * @classdesc Represents a QueuedTeamUser.
     * @implements IQueuedTeamUser
     * @constructor
     * @param {Enterprise.IQueuedTeamUser=} [properties] Properties to set
     */
    function QueuedTeamUser(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * QueuedTeamUser teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.QueuedTeamUser
     * @instance
     */
    QueuedTeamUser.prototype.teamUid = $util.newBuffer([]);

    /**
     * QueuedTeamUser users.
     * @member {Array.<number|Long>} users
     * @memberof Enterprise.QueuedTeamUser
     * @instance
     */
    QueuedTeamUser.prototype.users = $util.emptyArray;

    /**
     * Creates a new QueuedTeamUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Enterprise.IQueuedTeamUser=} [properties] Properties to set
     * @returns {Enterprise.QueuedTeamUser} QueuedTeamUser instance
     */
    QueuedTeamUser.create = function create(properties) {
      return new QueuedTeamUser(properties);
    };

    /**
     * Encodes the specified QueuedTeamUser message. Does not implicitly {@link Enterprise.QueuedTeamUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Enterprise.IQueuedTeamUser} message QueuedTeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueuedTeamUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.users != null && message.users.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.users.length; ++i) writer.int64(message.users[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified QueuedTeamUser message, length delimited. Does not implicitly {@link Enterprise.QueuedTeamUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Enterprise.IQueuedTeamUser} message QueuedTeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueuedTeamUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QueuedTeamUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.QueuedTeamUser} QueuedTeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueuedTeamUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.QueuedTeamUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.users && message.users.length)) message.users = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.users.push(reader.int64());
            } else message.users.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a QueuedTeamUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.QueuedTeamUser} QueuedTeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueuedTeamUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QueuedTeamUser message.
     * @function verify
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QueuedTeamUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i)
          if (
            !$util.isInteger(message.users[i]) &&
            !(
              message.users[i] &&
              $util.isInteger(message.users[i].low) &&
              $util.isInteger(message.users[i].high)
            )
          )
            return "users: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a QueuedTeamUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.QueuedTeamUser} QueuedTeamUser
     */
    QueuedTeamUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.QueuedTeamUser) return object;
      let message = new $root.Enterprise.QueuedTeamUser();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.QueuedTeamUser.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i)
          if ($util.Long)
            (message.users[i] = $util.Long.fromValue(object.users[i])).unsigned = false;
          else if (typeof object.users[i] === "string")
            message.users[i] = parseInt(object.users[i], 10);
          else if (typeof object.users[i] === "number") message.users[i] = object.users[i];
          else if (typeof object.users[i] === "object")
            message.users[i] = new $util.LongBits(
              object.users[i].low >>> 0,
              object.users[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a QueuedTeamUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {Enterprise.QueuedTeamUser} message QueuedTeamUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QueuedTeamUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (options.defaults)
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          if (typeof message.users[j] === "number")
            object.users[j] =
              options.longs === String ? String(message.users[j]) : message.users[j];
          else
            object.users[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.users[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.users[j].low >>> 0,
                      message.users[j].high >>> 0,
                    ).toNumber()
                  : message.users[j];
      }
      return object;
    };

    /**
     * Converts this QueuedTeamUser to JSON.
     * @function toJSON
     * @memberof Enterprise.QueuedTeamUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QueuedTeamUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for QueuedTeamUser
     * @function getTypeUrl
     * @memberof Enterprise.QueuedTeamUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    QueuedTeamUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.QueuedTeamUser";
    };

    return QueuedTeamUser;
  })();

  Enterprise.TeamsAddResult = (function () {
    /**
     * Properties of a TeamsAddResult.
     * @memberof Enterprise
     * @interface ITeamsAddResult
     * @property {Array.<Enterprise.ITeamAddResult>|null} [successfulTeamAdd] TeamsAddResult successfulTeamAdd
     * @property {Array.<Enterprise.ITeamAddResult>|null} [unsuccessfulTeamAdd] TeamsAddResult unsuccessfulTeamAdd
     * @property {string|null} [result] TeamsAddResult result
     * @property {string|null} [errorMessage] TeamsAddResult errorMessage
     */

    /**
     * Constructs a new TeamsAddResult.
     * @memberof Enterprise
     * @classdesc Represents a TeamsAddResult.
     * @implements ITeamsAddResult
     * @constructor
     * @param {Enterprise.ITeamsAddResult=} [properties] Properties to set
     */
    function TeamsAddResult(properties) {
      this.successfulTeamAdd = [];
      this.unsuccessfulTeamAdd = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsAddResult successfulTeamAdd.
     * @member {Array.<Enterprise.ITeamAddResult>} successfulTeamAdd
     * @memberof Enterprise.TeamsAddResult
     * @instance
     */
    TeamsAddResult.prototype.successfulTeamAdd = $util.emptyArray;

    /**
     * TeamsAddResult unsuccessfulTeamAdd.
     * @member {Array.<Enterprise.ITeamAddResult>} unsuccessfulTeamAdd
     * @memberof Enterprise.TeamsAddResult
     * @instance
     */
    TeamsAddResult.prototype.unsuccessfulTeamAdd = $util.emptyArray;

    /**
     * TeamsAddResult result.
     * @member {string} result
     * @memberof Enterprise.TeamsAddResult
     * @instance
     */
    TeamsAddResult.prototype.result = "";

    /**
     * TeamsAddResult errorMessage.
     * @member {string} errorMessage
     * @memberof Enterprise.TeamsAddResult
     * @instance
     */
    TeamsAddResult.prototype.errorMessage = "";

    /**
     * Creates a new TeamsAddResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Enterprise.ITeamsAddResult=} [properties] Properties to set
     * @returns {Enterprise.TeamsAddResult} TeamsAddResult instance
     */
    TeamsAddResult.create = function create(properties) {
      return new TeamsAddResult(properties);
    };

    /**
     * Encodes the specified TeamsAddResult message. Does not implicitly {@link Enterprise.TeamsAddResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Enterprise.ITeamsAddResult} message TeamsAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsAddResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.successfulTeamAdd != null && message.successfulTeamAdd.length)
        for (let i = 0; i < message.successfulTeamAdd.length; ++i)
          $root.Enterprise.TeamAddResult.encode(
            message.successfulTeamAdd[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.unsuccessfulTeamAdd != null && message.unsuccessfulTeamAdd.length)
        for (let i = 0; i < message.unsuccessfulTeamAdd.length; ++i)
          $root.Enterprise.TeamAddResult.encode(
            message.unsuccessfulTeamAdd[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.result != null && Object.hasOwnProperty.call(message, "result"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.result);
      if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.errorMessage);
      return writer;
    };

    /**
     * Encodes the specified TeamsAddResult message, length delimited. Does not implicitly {@link Enterprise.TeamsAddResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Enterprise.ITeamsAddResult} message TeamsAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsAddResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsAddResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsAddResult} TeamsAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsAddResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsAddResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.successfulTeamAdd && message.successfulTeamAdd.length))
              message.successfulTeamAdd = [];
            message.successfulTeamAdd.push(
              $root.Enterprise.TeamAddResult.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            if (!(message.unsuccessfulTeamAdd && message.unsuccessfulTeamAdd.length))
              message.unsuccessfulTeamAdd = [];
            message.unsuccessfulTeamAdd.push(
              $root.Enterprise.TeamAddResult.decode(reader, reader.uint32()),
            );
            break;
          }
          case 3: {
            message.result = reader.string();
            break;
          }
          case 4: {
            message.errorMessage = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsAddResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsAddResult} TeamsAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsAddResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsAddResult message.
     * @function verify
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsAddResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.successfulTeamAdd != null && message.hasOwnProperty("successfulTeamAdd")) {
        if (!Array.isArray(message.successfulTeamAdd)) return "successfulTeamAdd: array expected";
        for (let i = 0; i < message.successfulTeamAdd.length; ++i) {
          let error = $root.Enterprise.TeamAddResult.verify(message.successfulTeamAdd[i]);
          if (error) return "successfulTeamAdd." + error;
        }
      }
      if (message.unsuccessfulTeamAdd != null && message.hasOwnProperty("unsuccessfulTeamAdd")) {
        if (!Array.isArray(message.unsuccessfulTeamAdd))
          return "unsuccessfulTeamAdd: array expected";
        for (let i = 0; i < message.unsuccessfulTeamAdd.length; ++i) {
          let error = $root.Enterprise.TeamAddResult.verify(message.unsuccessfulTeamAdd[i]);
          if (error) return "unsuccessfulTeamAdd." + error;
        }
      }
      if (message.result != null && message.hasOwnProperty("result"))
        if (!$util.isString(message.result)) return "result: string expected";
      if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
        if (!$util.isString(message.errorMessage)) return "errorMessage: string expected";
      return null;
    };

    /**
     * Creates a TeamsAddResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsAddResult} TeamsAddResult
     */
    TeamsAddResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsAddResult) return object;
      let message = new $root.Enterprise.TeamsAddResult();
      if (object.successfulTeamAdd) {
        if (!Array.isArray(object.successfulTeamAdd))
          throw TypeError(".Enterprise.TeamsAddResult.successfulTeamAdd: array expected");
        message.successfulTeamAdd = [];
        for (let i = 0; i < object.successfulTeamAdd.length; ++i) {
          if (typeof object.successfulTeamAdd[i] !== "object")
            throw TypeError(".Enterprise.TeamsAddResult.successfulTeamAdd: object expected");
          message.successfulTeamAdd[i] = $root.Enterprise.TeamAddResult.fromObject(
            object.successfulTeamAdd[i],
          );
        }
      }
      if (object.unsuccessfulTeamAdd) {
        if (!Array.isArray(object.unsuccessfulTeamAdd))
          throw TypeError(".Enterprise.TeamsAddResult.unsuccessfulTeamAdd: array expected");
        message.unsuccessfulTeamAdd = [];
        for (let i = 0; i < object.unsuccessfulTeamAdd.length; ++i) {
          if (typeof object.unsuccessfulTeamAdd[i] !== "object")
            throw TypeError(".Enterprise.TeamsAddResult.unsuccessfulTeamAdd: object expected");
          message.unsuccessfulTeamAdd[i] = $root.Enterprise.TeamAddResult.fromObject(
            object.unsuccessfulTeamAdd[i],
          );
        }
      }
      if (object.result != null) message.result = String(object.result);
      if (object.errorMessage != null) message.errorMessage = String(object.errorMessage);
      return message;
    };

    /**
     * Creates a plain object from a TeamsAddResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {Enterprise.TeamsAddResult} message TeamsAddResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsAddResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.successfulTeamAdd = [];
        object.unsuccessfulTeamAdd = [];
      }
      if (options.defaults) {
        object.result = "";
        object.errorMessage = "";
      }
      if (message.successfulTeamAdd && message.successfulTeamAdd.length) {
        object.successfulTeamAdd = [];
        for (let j = 0; j < message.successfulTeamAdd.length; ++j)
          object.successfulTeamAdd[j] = $root.Enterprise.TeamAddResult.toObject(
            message.successfulTeamAdd[j],
            options,
          );
      }
      if (message.unsuccessfulTeamAdd && message.unsuccessfulTeamAdd.length) {
        object.unsuccessfulTeamAdd = [];
        for (let j = 0; j < message.unsuccessfulTeamAdd.length; ++j)
          object.unsuccessfulTeamAdd[j] = $root.Enterprise.TeamAddResult.toObject(
            message.unsuccessfulTeamAdd[j],
            options,
          );
      }
      if (message.result != null && message.hasOwnProperty("result"))
        object.result = message.result;
      if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
        object.errorMessage = message.errorMessage;
      return object;
    };

    /**
     * Converts this TeamsAddResult to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsAddResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsAddResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsAddResult
     * @function getTypeUrl
     * @memberof Enterprise.TeamsAddResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsAddResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsAddResult";
    };

    return TeamsAddResult;
  })();

  Enterprise.TeamAddResult = (function () {
    /**
     * Properties of a TeamAddResult.
     * @memberof Enterprise
     * @interface ITeamAddResult
     * @property {Enterprise.ITeam|null} [team] TeamAddResult team
     * @property {string|null} [result] TeamAddResult result
     * @property {string|null} [errorMessage] TeamAddResult errorMessage
     */

    /**
     * Constructs a new TeamAddResult.
     * @memberof Enterprise
     * @classdesc Represents a TeamAddResult.
     * @implements ITeamAddResult
     * @constructor
     * @param {Enterprise.ITeamAddResult=} [properties] Properties to set
     */
    function TeamAddResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamAddResult team.
     * @member {Enterprise.ITeam|null|undefined} team
     * @memberof Enterprise.TeamAddResult
     * @instance
     */
    TeamAddResult.prototype.team = null;

    /**
     * TeamAddResult result.
     * @member {string} result
     * @memberof Enterprise.TeamAddResult
     * @instance
     */
    TeamAddResult.prototype.result = "";

    /**
     * TeamAddResult errorMessage.
     * @member {string} errorMessage
     * @memberof Enterprise.TeamAddResult
     * @instance
     */
    TeamAddResult.prototype.errorMessage = "";

    /**
     * Creates a new TeamAddResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Enterprise.ITeamAddResult=} [properties] Properties to set
     * @returns {Enterprise.TeamAddResult} TeamAddResult instance
     */
    TeamAddResult.create = function create(properties) {
      return new TeamAddResult(properties);
    };

    /**
     * Encodes the specified TeamAddResult message. Does not implicitly {@link Enterprise.TeamAddResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Enterprise.ITeamAddResult} message TeamAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamAddResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.team != null && Object.hasOwnProperty.call(message, "team"))
        $root.Enterprise.Team.encode(
          message.team,
          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
        ).ldelim();
      if (message.result != null && Object.hasOwnProperty.call(message, "result"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.result);
      if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.errorMessage);
      return writer;
    };

    /**
     * Encodes the specified TeamAddResult message, length delimited. Does not implicitly {@link Enterprise.TeamAddResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Enterprise.ITeamAddResult} message TeamAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamAddResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamAddResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamAddResult} TeamAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamAddResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamAddResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.team = $root.Enterprise.Team.decode(reader, reader.uint32());
            break;
          }
          case 2: {
            message.result = reader.string();
            break;
          }
          case 3: {
            message.errorMessage = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamAddResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamAddResult} TeamAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamAddResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamAddResult message.
     * @function verify
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamAddResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.team != null && message.hasOwnProperty("team")) {
        let error = $root.Enterprise.Team.verify(message.team);
        if (error) return "team." + error;
      }
      if (message.result != null && message.hasOwnProperty("result"))
        if (!$util.isString(message.result)) return "result: string expected";
      if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
        if (!$util.isString(message.errorMessage)) return "errorMessage: string expected";
      return null;
    };

    /**
     * Creates a TeamAddResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamAddResult} TeamAddResult
     */
    TeamAddResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamAddResult) return object;
      let message = new $root.Enterprise.TeamAddResult();
      if (object.team != null) {
        if (typeof object.team !== "object")
          throw TypeError(".Enterprise.TeamAddResult.team: object expected");
        message.team = $root.Enterprise.Team.fromObject(object.team);
      }
      if (object.result != null) message.result = String(object.result);
      if (object.errorMessage != null) message.errorMessage = String(object.errorMessage);
      return message;
    };

    /**
     * Creates a plain object from a TeamAddResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {Enterprise.TeamAddResult} message TeamAddResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamAddResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.team = null;
        object.result = "";
        object.errorMessage = "";
      }
      if (message.team != null && message.hasOwnProperty("team"))
        object.team = $root.Enterprise.Team.toObject(message.team, options);
      if (message.result != null && message.hasOwnProperty("result"))
        object.result = message.result;
      if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
        object.errorMessage = message.errorMessage;
      return object;
    };

    /**
     * Converts this TeamAddResult to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamAddResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamAddResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamAddResult
     * @function getTypeUrl
     * @memberof Enterprise.TeamAddResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamAddResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamAddResult";
    };

    return TeamAddResult;
  })();

  Enterprise.SsoService = (function () {
    /**
     * Properties of a SsoService.
     * @memberof Enterprise
     * @interface ISsoService
     * @property {number|Long|null} [ssoServiceProviderId] SsoService ssoServiceProviderId
     * @property {number|Long|null} [nodeId] SsoService nodeId
     * @property {string|null} [name] SsoService name
     * @property {string|null} [spUrl] SsoService spUrl
     * @property {boolean|null} [inviteNewUsers] SsoService inviteNewUsers
     * @property {boolean|null} [active] SsoService active
     * @property {boolean|null} [isCloud] SsoService isCloud
     */

    /**
     * Constructs a new SsoService.
     * @memberof Enterprise
     * @classdesc Represents a SsoService.
     * @implements ISsoService
     * @constructor
     * @param {Enterprise.ISsoService=} [properties] Properties to set
     */
    function SsoService(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SsoService ssoServiceProviderId.
     * @member {number|Long} ssoServiceProviderId
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * SsoService nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * SsoService name.
     * @member {string} name
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.name = "";

    /**
     * SsoService spUrl.
     * @member {string} spUrl
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.spUrl = "";

    /**
     * SsoService inviteNewUsers.
     * @member {boolean} inviteNewUsers
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.inviteNewUsers = false;

    /**
     * SsoService active.
     * @member {boolean} active
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.active = false;

    /**
     * SsoService isCloud.
     * @member {boolean} isCloud
     * @memberof Enterprise.SsoService
     * @instance
     */
    SsoService.prototype.isCloud = false;

    /**
     * Creates a new SsoService instance using the specified properties.
     * @function create
     * @memberof Enterprise.SsoService
     * @static
     * @param {Enterprise.ISsoService=} [properties] Properties to set
     * @returns {Enterprise.SsoService} SsoService instance
     */
    SsoService.create = function create(properties) {
      return new SsoService(properties);
    };

    /**
     * Encodes the specified SsoService message. Does not implicitly {@link Enterprise.SsoService.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SsoService
     * @static
     * @param {Enterprise.ISsoService} message SsoService message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SsoService.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.ssoServiceProviderId != null &&
        Object.hasOwnProperty.call(message, "ssoServiceProviderId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.ssoServiceProviderId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.name != null && Object.hasOwnProperty.call(message, "name"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
      if (message.spUrl != null && Object.hasOwnProperty.call(message, "spUrl"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.spUrl);
      if (message.inviteNewUsers != null && Object.hasOwnProperty.call(message, "inviteNewUsers"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.inviteNewUsers);
      if (message.active != null && Object.hasOwnProperty.call(message, "active"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.active);
      if (message.isCloud != null && Object.hasOwnProperty.call(message, "isCloud"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.isCloud);
      return writer;
    };

    /**
     * Encodes the specified SsoService message, length delimited. Does not implicitly {@link Enterprise.SsoService.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SsoService
     * @static
     * @param {Enterprise.ISsoService} message SsoService message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SsoService.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SsoService message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SsoService
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SsoService} SsoService
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SsoService.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SsoService();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.ssoServiceProviderId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.name = reader.string();
            break;
          }
          case 4: {
            message.spUrl = reader.string();
            break;
          }
          case 5: {
            message.inviteNewUsers = reader.bool();
            break;
          }
          case 6: {
            message.active = reader.bool();
            break;
          }
          case 7: {
            message.isCloud = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SsoService message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SsoService
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SsoService} SsoService
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SsoService.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SsoService message.
     * @function verify
     * @memberof Enterprise.SsoService
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SsoService.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
        if (
          !$util.isInteger(message.ssoServiceProviderId) &&
          !(
            message.ssoServiceProviderId &&
            $util.isInteger(message.ssoServiceProviderId.low) &&
            $util.isInteger(message.ssoServiceProviderId.high)
          )
        )
          return "ssoServiceProviderId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.name != null && message.hasOwnProperty("name"))
        if (!$util.isString(message.name)) return "name: string expected";
      if (message.spUrl != null && message.hasOwnProperty("spUrl"))
        if (!$util.isString(message.spUrl)) return "spUrl: string expected";
      if (message.inviteNewUsers != null && message.hasOwnProperty("inviteNewUsers"))
        if (typeof message.inviteNewUsers !== "boolean") return "inviteNewUsers: boolean expected";
      if (message.active != null && message.hasOwnProperty("active"))
        if (typeof message.active !== "boolean") return "active: boolean expected";
      if (message.isCloud != null && message.hasOwnProperty("isCloud"))
        if (typeof message.isCloud !== "boolean") return "isCloud: boolean expected";
      return null;
    };

    /**
     * Creates a SsoService message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SsoService
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SsoService} SsoService
     */
    SsoService.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SsoService) return object;
      let message = new $root.Enterprise.SsoService();
      if (object.ssoServiceProviderId != null)
        if ($util.Long)
          (message.ssoServiceProviderId = $util.Long.fromValue(
            object.ssoServiceProviderId,
          )).unsigned = false;
        else if (typeof object.ssoServiceProviderId === "string")
          message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
        else if (typeof object.ssoServiceProviderId === "number")
          message.ssoServiceProviderId = object.ssoServiceProviderId;
        else if (typeof object.ssoServiceProviderId === "object")
          message.ssoServiceProviderId = new $util.LongBits(
            object.ssoServiceProviderId.low >>> 0,
            object.ssoServiceProviderId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.name != null) message.name = String(object.name);
      if (object.spUrl != null) message.spUrl = String(object.spUrl);
      if (object.inviteNewUsers != null) message.inviteNewUsers = Boolean(object.inviteNewUsers);
      if (object.active != null) message.active = Boolean(object.active);
      if (object.isCloud != null) message.isCloud = Boolean(object.isCloud);
      return message;
    };

    /**
     * Creates a plain object from a SsoService message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SsoService
     * @static
     * @param {Enterprise.SsoService} message SsoService
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SsoService.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.ssoServiceProviderId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.ssoServiceProviderId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.name = "";
        object.spUrl = "";
        object.inviteNewUsers = false;
        object.active = false;
        object.isCloud = false;
      }
      if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
        if (typeof message.ssoServiceProviderId === "number")
          object.ssoServiceProviderId =
            options.longs === String
              ? String(message.ssoServiceProviderId)
              : message.ssoServiceProviderId;
        else
          object.ssoServiceProviderId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.ssoServiceProviderId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.ssoServiceProviderId.low >>> 0,
                    message.ssoServiceProviderId.high >>> 0,
                  ).toNumber()
                : message.ssoServiceProviderId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.name != null && message.hasOwnProperty("name")) object.name = message.name;
      if (message.spUrl != null && message.hasOwnProperty("spUrl")) object.spUrl = message.spUrl;
      if (message.inviteNewUsers != null && message.hasOwnProperty("inviteNewUsers"))
        object.inviteNewUsers = message.inviteNewUsers;
      if (message.active != null && message.hasOwnProperty("active"))
        object.active = message.active;
      if (message.isCloud != null && message.hasOwnProperty("isCloud"))
        object.isCloud = message.isCloud;
      return object;
    };

    /**
     * Converts this SsoService to JSON.
     * @function toJSON
     * @memberof Enterprise.SsoService
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SsoService.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SsoService
     * @function getTypeUrl
     * @memberof Enterprise.SsoService
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SsoService.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SsoService";
    };

    return SsoService;
  })();

  Enterprise.ReportFilterUser = (function () {
    /**
     * Properties of a ReportFilterUser.
     * @memberof Enterprise
     * @interface IReportFilterUser
     * @property {number|null} [userId] ReportFilterUser userId
     * @property {string|null} [email] ReportFilterUser email
     */

    /**
     * Constructs a new ReportFilterUser.
     * @memberof Enterprise
     * @classdesc Represents a ReportFilterUser.
     * @implements IReportFilterUser
     * @constructor
     * @param {Enterprise.IReportFilterUser=} [properties] Properties to set
     */
    function ReportFilterUser(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReportFilterUser userId.
     * @member {number} userId
     * @memberof Enterprise.ReportFilterUser
     * @instance
     */
    ReportFilterUser.prototype.userId = 0;

    /**
     * ReportFilterUser email.
     * @member {string} email
     * @memberof Enterprise.ReportFilterUser
     * @instance
     */
    ReportFilterUser.prototype.email = "";

    /**
     * Creates a new ReportFilterUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Enterprise.IReportFilterUser=} [properties] Properties to set
     * @returns {Enterprise.ReportFilterUser} ReportFilterUser instance
     */
    ReportFilterUser.create = function create(properties) {
      return new ReportFilterUser(properties);
    };

    /**
     * Encodes the specified ReportFilterUser message. Does not implicitly {@link Enterprise.ReportFilterUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Enterprise.IReportFilterUser} message ReportFilterUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReportFilterUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.userId);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.email);
      return writer;
    };

    /**
     * Encodes the specified ReportFilterUser message, length delimited. Does not implicitly {@link Enterprise.ReportFilterUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Enterprise.IReportFilterUser} message ReportFilterUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReportFilterUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReportFilterUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ReportFilterUser} ReportFilterUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReportFilterUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ReportFilterUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.userId = reader.int32();
            break;
          }
          case 2: {
            message.email = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ReportFilterUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ReportFilterUser} ReportFilterUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReportFilterUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReportFilterUser message.
     * @function verify
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReportFilterUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userId != null && message.hasOwnProperty("userId"))
        if (!$util.isInteger(message.userId)) return "userId: integer expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      return null;
    };

    /**
     * Creates a ReportFilterUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ReportFilterUser} ReportFilterUser
     */
    ReportFilterUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ReportFilterUser) return object;
      let message = new $root.Enterprise.ReportFilterUser();
      if (object.userId != null) message.userId = object.userId | 0;
      if (object.email != null) message.email = String(object.email);
      return message;
    };

    /**
     * Creates a plain object from a ReportFilterUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {Enterprise.ReportFilterUser} message ReportFilterUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReportFilterUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.userId = 0;
        object.email = "";
      }
      if (message.userId != null && message.hasOwnProperty("userId"))
        object.userId = message.userId;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      return object;
    };

    /**
     * Converts this ReportFilterUser to JSON.
     * @function toJSON
     * @memberof Enterprise.ReportFilterUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReportFilterUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ReportFilterUser
     * @function getTypeUrl
     * @memberof Enterprise.ReportFilterUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ReportFilterUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ReportFilterUser";
    };

    return ReportFilterUser;
  })();

  Enterprise.DeviceRequestForAdminApproval = (function () {
    /**
     * Properties of a DeviceRequestForAdminApproval.
     * @memberof Enterprise
     * @interface IDeviceRequestForAdminApproval
     * @property {number|Long|null} [deviceId] DeviceRequestForAdminApproval deviceId
     * @property {number|Long|null} [enterpriseUserId] DeviceRequestForAdminApproval enterpriseUserId
     * @property {Uint8Array|null} [encryptedDeviceToken] DeviceRequestForAdminApproval encryptedDeviceToken
     * @property {Uint8Array|null} [devicePublicKey] DeviceRequestForAdminApproval devicePublicKey
     * @property {string|null} [deviceName] DeviceRequestForAdminApproval deviceName
     * @property {string|null} [clientVersion] DeviceRequestForAdminApproval clientVersion
     * @property {string|null} [deviceType] DeviceRequestForAdminApproval deviceType
     * @property {number|Long|null} [date] DeviceRequestForAdminApproval date
     * @property {string|null} [ipAddress] DeviceRequestForAdminApproval ipAddress
     * @property {string|null} [location] DeviceRequestForAdminApproval location
     * @property {string|null} [email] DeviceRequestForAdminApproval email
     * @property {Uint8Array|null} [accountUid] DeviceRequestForAdminApproval accountUid
     */

    /**
     * Constructs a new DeviceRequestForAdminApproval.
     * @memberof Enterprise
     * @classdesc Represents a DeviceRequestForAdminApproval.
     * @implements IDeviceRequestForAdminApproval
     * @constructor
     * @param {Enterprise.IDeviceRequestForAdminApproval=} [properties] Properties to set
     */
    function DeviceRequestForAdminApproval(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeviceRequestForAdminApproval deviceId.
     * @member {number|Long} deviceId
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.deviceId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * DeviceRequestForAdminApproval enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * DeviceRequestForAdminApproval encryptedDeviceToken.
     * @member {Uint8Array} encryptedDeviceToken
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.encryptedDeviceToken = $util.newBuffer([]);

    /**
     * DeviceRequestForAdminApproval devicePublicKey.
     * @member {Uint8Array} devicePublicKey
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.devicePublicKey = $util.newBuffer([]);

    /**
     * DeviceRequestForAdminApproval deviceName.
     * @member {string} deviceName
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.deviceName = "";

    /**
     * DeviceRequestForAdminApproval clientVersion.
     * @member {string} clientVersion
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.clientVersion = "";

    /**
     * DeviceRequestForAdminApproval deviceType.
     * @member {string} deviceType
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.deviceType = "";

    /**
     * DeviceRequestForAdminApproval date.
     * @member {number|Long} date
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.date = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * DeviceRequestForAdminApproval ipAddress.
     * @member {string} ipAddress
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.ipAddress = "";

    /**
     * DeviceRequestForAdminApproval location.
     * @member {string} location
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.location = "";

    /**
     * DeviceRequestForAdminApproval email.
     * @member {string} email
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.email = "";

    /**
     * DeviceRequestForAdminApproval accountUid.
     * @member {Uint8Array} accountUid
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     */
    DeviceRequestForAdminApproval.prototype.accountUid = $util.newBuffer([]);

    /**
     * Creates a new DeviceRequestForAdminApproval instance using the specified properties.
     * @function create
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Enterprise.IDeviceRequestForAdminApproval=} [properties] Properties to set
     * @returns {Enterprise.DeviceRequestForAdminApproval} DeviceRequestForAdminApproval instance
     */
    DeviceRequestForAdminApproval.create = function create(properties) {
      return new DeviceRequestForAdminApproval(properties);
    };

    /**
     * Encodes the specified DeviceRequestForAdminApproval message. Does not implicitly {@link Enterprise.DeviceRequestForAdminApproval.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Enterprise.IDeviceRequestForAdminApproval} message DeviceRequestForAdminApproval message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceRequestForAdminApproval.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.deviceId);
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.enterpriseUserId);
      if (
        message.encryptedDeviceToken != null &&
        Object.hasOwnProperty.call(message, "encryptedDeviceToken")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.encryptedDeviceToken);
      if (message.devicePublicKey != null && Object.hasOwnProperty.call(message, "devicePublicKey"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.devicePublicKey);
      if (message.deviceName != null && Object.hasOwnProperty.call(message, "deviceName"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.deviceName);
      if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.clientVersion);
      if (message.deviceType != null && Object.hasOwnProperty.call(message, "deviceType"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.deviceType);
      if (message.date != null && Object.hasOwnProperty.call(message, "date"))
        writer.uint32(/* id 8, wireType 0 =*/ 64).int64(message.date);
      if (message.ipAddress != null && Object.hasOwnProperty.call(message, "ipAddress"))
        writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.ipAddress);
      if (message.location != null && Object.hasOwnProperty.call(message, "location"))
        writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.location);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.email);
      if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
        writer.uint32(/* id 12, wireType 2 =*/ 98).bytes(message.accountUid);
      return writer;
    };

    /**
     * Encodes the specified DeviceRequestForAdminApproval message, length delimited. Does not implicitly {@link Enterprise.DeviceRequestForAdminApproval.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Enterprise.IDeviceRequestForAdminApproval} message DeviceRequestForAdminApproval message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceRequestForAdminApproval.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeviceRequestForAdminApproval message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DeviceRequestForAdminApproval} DeviceRequestForAdminApproval
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceRequestForAdminApproval.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DeviceRequestForAdminApproval();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.deviceId = reader.int64();
            break;
          }
          case 2: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedDeviceToken = reader.bytes();
            break;
          }
          case 4: {
            message.devicePublicKey = reader.bytes();
            break;
          }
          case 5: {
            message.deviceName = reader.string();
            break;
          }
          case 6: {
            message.clientVersion = reader.string();
            break;
          }
          case 7: {
            message.deviceType = reader.string();
            break;
          }
          case 8: {
            message.date = reader.int64();
            break;
          }
          case 9: {
            message.ipAddress = reader.string();
            break;
          }
          case 10: {
            message.location = reader.string();
            break;
          }
          case 11: {
            message.email = reader.string();
            break;
          }
          case 12: {
            message.accountUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DeviceRequestForAdminApproval message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DeviceRequestForAdminApproval} DeviceRequestForAdminApproval
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceRequestForAdminApproval.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeviceRequestForAdminApproval message.
     * @function verify
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeviceRequestForAdminApproval.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.deviceId != null && message.hasOwnProperty("deviceId"))
        if (
          !$util.isInteger(message.deviceId) &&
          !(
            message.deviceId &&
            $util.isInteger(message.deviceId.low) &&
            $util.isInteger(message.deviceId.high)
          )
        )
          return "deviceId: integer|Long expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        if (
          !(
            (message.encryptedDeviceToken &&
              typeof message.encryptedDeviceToken.length === "number") ||
            $util.isString(message.encryptedDeviceToken)
          )
        )
          return "encryptedDeviceToken: buffer expected";
      if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
        if (
          !(
            (message.devicePublicKey && typeof message.devicePublicKey.length === "number") ||
            $util.isString(message.devicePublicKey)
          )
        )
          return "devicePublicKey: buffer expected";
      if (message.deviceName != null && message.hasOwnProperty("deviceName"))
        if (!$util.isString(message.deviceName)) return "deviceName: string expected";
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        if (!$util.isString(message.clientVersion)) return "clientVersion: string expected";
      if (message.deviceType != null && message.hasOwnProperty("deviceType"))
        if (!$util.isString(message.deviceType)) return "deviceType: string expected";
      if (message.date != null && message.hasOwnProperty("date"))
        if (
          !$util.isInteger(message.date) &&
          !(message.date && $util.isInteger(message.date.low) && $util.isInteger(message.date.high))
        )
          return "date: integer|Long expected";
      if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
        if (!$util.isString(message.ipAddress)) return "ipAddress: string expected";
      if (message.location != null && message.hasOwnProperty("location"))
        if (!$util.isString(message.location)) return "location: string expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.accountUid != null && message.hasOwnProperty("accountUid"))
        if (
          !(
            (message.accountUid && typeof message.accountUid.length === "number") ||
            $util.isString(message.accountUid)
          )
        )
          return "accountUid: buffer expected";
      return null;
    };

    /**
     * Creates a DeviceRequestForAdminApproval message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DeviceRequestForAdminApproval} DeviceRequestForAdminApproval
     */
    DeviceRequestForAdminApproval.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DeviceRequestForAdminApproval) return object;
      let message = new $root.Enterprise.DeviceRequestForAdminApproval();
      if (object.deviceId != null)
        if ($util.Long) (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
        else if (typeof object.deviceId === "string")
          message.deviceId = parseInt(object.deviceId, 10);
        else if (typeof object.deviceId === "number") message.deviceId = object.deviceId;
        else if (typeof object.deviceId === "object")
          message.deviceId = new $util.LongBits(
            object.deviceId.low >>> 0,
            object.deviceId.high >>> 0,
          ).toNumber();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.encryptedDeviceToken != null)
        if (typeof object.encryptedDeviceToken === "string")
          $util.base64.decode(
            object.encryptedDeviceToken,
            (message.encryptedDeviceToken = $util.newBuffer(
              $util.base64.length(object.encryptedDeviceToken),
            )),
            0,
          );
        else if (object.encryptedDeviceToken.length >= 0)
          message.encryptedDeviceToken = object.encryptedDeviceToken;
      if (object.devicePublicKey != null)
        if (typeof object.devicePublicKey === "string")
          $util.base64.decode(
            object.devicePublicKey,
            (message.devicePublicKey = $util.newBuffer(
              $util.base64.length(object.devicePublicKey),
            )),
            0,
          );
        else if (object.devicePublicKey.length >= 0)
          message.devicePublicKey = object.devicePublicKey;
      if (object.deviceName != null) message.deviceName = String(object.deviceName);
      if (object.clientVersion != null) message.clientVersion = String(object.clientVersion);
      if (object.deviceType != null) message.deviceType = String(object.deviceType);
      if (object.date != null)
        if ($util.Long) (message.date = $util.Long.fromValue(object.date)).unsigned = false;
        else if (typeof object.date === "string") message.date = parseInt(object.date, 10);
        else if (typeof object.date === "number") message.date = object.date;
        else if (typeof object.date === "object")
          message.date = new $util.LongBits(
            object.date.low >>> 0,
            object.date.high >>> 0,
          ).toNumber();
      if (object.ipAddress != null) message.ipAddress = String(object.ipAddress);
      if (object.location != null) message.location = String(object.location);
      if (object.email != null) message.email = String(object.email);
      if (object.accountUid != null)
        if (typeof object.accountUid === "string")
          $util.base64.decode(
            object.accountUid,
            (message.accountUid = $util.newBuffer($util.base64.length(object.accountUid))),
            0,
          );
        else if (object.accountUid.length >= 0) message.accountUid = object.accountUid;
      return message;
    };

    /**
     * Creates a plain object from a DeviceRequestForAdminApproval message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {Enterprise.DeviceRequestForAdminApproval} message DeviceRequestForAdminApproval
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeviceRequestForAdminApproval.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.deviceId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.deviceId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedDeviceToken = "";
        else {
          object.encryptedDeviceToken = [];
          if (options.bytes !== Array)
            object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
        }
        if (options.bytes === String) object.devicePublicKey = "";
        else {
          object.devicePublicKey = [];
          if (options.bytes !== Array)
            object.devicePublicKey = $util.newBuffer(object.devicePublicKey);
        }
        object.deviceName = "";
        object.clientVersion = "";
        object.deviceType = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.date =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.date = options.longs === String ? "0" : 0;
        object.ipAddress = "";
        object.location = "";
        object.email = "";
        if (options.bytes === String) object.accountUid = "";
        else {
          object.accountUid = [];
          if (options.bytes !== Array) object.accountUid = $util.newBuffer(object.accountUid);
        }
      }
      if (message.deviceId != null && message.hasOwnProperty("deviceId"))
        if (typeof message.deviceId === "number")
          object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
        else
          object.deviceId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.deviceId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.deviceId.low >>> 0,
                    message.deviceId.high >>> 0,
                  ).toNumber()
                : message.deviceId;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        object.encryptedDeviceToken =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedDeviceToken,
                0,
                message.encryptedDeviceToken.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedDeviceToken)
              : message.encryptedDeviceToken;
      if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
        object.devicePublicKey =
          options.bytes === String
            ? $util.base64.encode(message.devicePublicKey, 0, message.devicePublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.devicePublicKey)
              : message.devicePublicKey;
      if (message.deviceName != null && message.hasOwnProperty("deviceName"))
        object.deviceName = message.deviceName;
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        object.clientVersion = message.clientVersion;
      if (message.deviceType != null && message.hasOwnProperty("deviceType"))
        object.deviceType = message.deviceType;
      if (message.date != null && message.hasOwnProperty("date"))
        if (typeof message.date === "number")
          object.date = options.longs === String ? String(message.date) : message.date;
        else
          object.date =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.date)
              : options.longs === Number
                ? new $util.LongBits(message.date.low >>> 0, message.date.high >>> 0).toNumber()
                : message.date;
      if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
        object.ipAddress = message.ipAddress;
      if (message.location != null && message.hasOwnProperty("location"))
        object.location = message.location;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.accountUid != null && message.hasOwnProperty("accountUid"))
        object.accountUid =
          options.bytes === String
            ? $util.base64.encode(message.accountUid, 0, message.accountUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.accountUid)
              : message.accountUid;
      return object;
    };

    /**
     * Converts this DeviceRequestForAdminApproval to JSON.
     * @function toJSON
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeviceRequestForAdminApproval.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DeviceRequestForAdminApproval
     * @function getTypeUrl
     * @memberof Enterprise.DeviceRequestForAdminApproval
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DeviceRequestForAdminApproval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DeviceRequestForAdminApproval";
    };

    return DeviceRequestForAdminApproval;
  })();

  Enterprise.EnterpriseData = (function () {
    /**
     * Properties of an EnterpriseData.
     * @memberof Enterprise
     * @interface IEnterpriseData
     * @property {Enterprise.EnterpriseDataEntity|null} [entity] EnterpriseData entity
     * @property {boolean|null} ["delete"] EnterpriseData delete
     * @property {Array.<Uint8Array>|null} [data] EnterpriseData data
     */

    /**
     * Constructs a new EnterpriseData.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseData.
     * @implements IEnterpriseData
     * @constructor
     * @param {Enterprise.IEnterpriseData=} [properties] Properties to set
     */
    function EnterpriseData(properties) {
      this.data = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseData entity.
     * @member {Enterprise.EnterpriseDataEntity} entity
     * @memberof Enterprise.EnterpriseData
     * @instance
     */
    EnterpriseData.prototype.entity = 0;

    /**
     * EnterpriseData delete.
     * @member {boolean} delete
     * @memberof Enterprise.EnterpriseData
     * @instance
     */
    EnterpriseData.prototype["delete"] = false;

    /**
     * EnterpriseData data.
     * @member {Array.<Uint8Array>} data
     * @memberof Enterprise.EnterpriseData
     * @instance
     */
    EnterpriseData.prototype.data = $util.emptyArray;

    /**
     * Creates a new EnterpriseData instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Enterprise.IEnterpriseData=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseData} EnterpriseData instance
     */
    EnterpriseData.create = function create(properties) {
      return new EnterpriseData(properties);
    };

    /**
     * Encodes the specified EnterpriseData message. Does not implicitly {@link Enterprise.EnterpriseData.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Enterprise.IEnterpriseData} message EnterpriseData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseData.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.entity);
      if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message["delete"]);
      if (message.data != null && message.data.length)
        for (let i = 0; i < message.data.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.data[i]);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseData message, length delimited. Does not implicitly {@link Enterprise.EnterpriseData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Enterprise.IEnterpriseData} message EnterpriseData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseData.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseData message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseData} EnterpriseData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseData.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseData();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.entity = reader.int32();
            break;
          }
          case 2: {
            message["delete"] = reader.bool();
            break;
          }
          case 3: {
            if (!(message.data && message.data.length)) message.data = [];
            message.data.push(reader.bytes());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseData} EnterpriseData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseData.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseData message.
     * @function verify
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseData.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.entity != null && message.hasOwnProperty("entity"))
        switch (message.entity) {
          default:
            return "entity: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
            break;
        }
      if (message["delete"] != null && message.hasOwnProperty("delete"))
        if (typeof message["delete"] !== "boolean") return "delete: boolean expected";
      if (message.data != null && message.hasOwnProperty("data")) {
        if (!Array.isArray(message.data)) return "data: array expected";
        for (let i = 0; i < message.data.length; ++i)
          if (
            !(
              (message.data[i] && typeof message.data[i].length === "number") ||
              $util.isString(message.data[i])
            )
          )
            return "data: buffer[] expected";
      }
      return null;
    };

    /**
     * Creates an EnterpriseData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseData} EnterpriseData
     */
    EnterpriseData.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseData) return object;
      let message = new $root.Enterprise.EnterpriseData();
      switch (object.entity) {
        default:
          if (typeof object.entity === "number") {
            message.entity = object.entity;
            break;
          }
          break;
        case "UNKNOWN":
        case 0:
          message.entity = 0;
          break;
        case "NODES":
        case 1:
          message.entity = 1;
          break;
        case "ROLES":
        case 2:
          message.entity = 2;
          break;
        case "USERS":
        case 3:
          message.entity = 3;
          break;
        case "TEAMS":
        case 4:
          message.entity = 4;
          break;
        case "TEAM_USERS":
        case 5:
          message.entity = 5;
          break;
        case "ROLE_USERS":
        case 6:
          message.entity = 6;
          break;
        case "ROLE_PRIVILEGES":
        case 7:
          message.entity = 7;
          break;
        case "ROLE_ENFORCEMENTS":
        case 8:
          message.entity = 8;
          break;
        case "ROLE_TEAMS":
        case 9:
          message.entity = 9;
          break;
        case "LICENSES":
        case 10:
          message.entity = 10;
          break;
        case "MANAGED_NODES":
        case 11:
          message.entity = 11;
          break;
        case "MANAGED_COMPANIES":
        case 12:
          message.entity = 12;
          break;
        case "BRIDGES":
        case 13:
          message.entity = 13;
          break;
        case "SCIMS":
        case 14:
          message.entity = 14;
          break;
        case "EMAIL_PROVISION":
        case 15:
          message.entity = 15;
          break;
        case "QUEUED_TEAMS":
        case 16:
          message.entity = 16;
          break;
        case "QUEUED_TEAM_USERS":
        case 17:
          message.entity = 17;
          break;
        case "SSO_SERVICES":
        case 18:
          message.entity = 18;
          break;
        case "REPORT_FILTER_USERS":
        case 19:
          message.entity = 19;
          break;
        case "DEVICES_REQUEST_FOR_ADMIN_APPROVAL":
        case 20:
          message.entity = 20;
          break;
        case "USER_ALIASES":
        case 21:
          message.entity = 21;
          break;
        case "COMPLIANCE_REPORT_CRITERIA_AND_FILTER":
        case 22:
          message.entity = 22;
          break;
        case "COMPLIANCE_REPORTS":
        case 23:
          message.entity = 23;
          break;
        case "QUEUED_TEAM_USERS_INCLUDING_PENDING":
        case 24:
          message.entity = 24;
          break;
      }
      if (object["delete"] != null) message["delete"] = Boolean(object["delete"]);
      if (object.data) {
        if (!Array.isArray(object.data))
          throw TypeError(".Enterprise.EnterpriseData.data: array expected");
        message.data = [];
        for (let i = 0; i < object.data.length; ++i)
          if (typeof object.data[i] === "string")
            $util.base64.decode(
              object.data[i],
              (message.data[i] = $util.newBuffer($util.base64.length(object.data[i]))),
              0,
            );
          else if (object.data[i].length >= 0) message.data[i] = object.data[i];
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {Enterprise.EnterpriseData} message EnterpriseData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseData.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.data = [];
      if (options.defaults) {
        object.entity = options.enums === String ? "UNKNOWN" : 0;
        object["delete"] = false;
      }
      if (message.entity != null && message.hasOwnProperty("entity"))
        object.entity =
          options.enums === String
            ? $root.Enterprise.EnterpriseDataEntity[message.entity] === undefined
              ? message.entity
              : $root.Enterprise.EnterpriseDataEntity[message.entity]
            : message.entity;
      if (message["delete"] != null && message.hasOwnProperty("delete"))
        object["delete"] = message["delete"];
      if (message.data && message.data.length) {
        object.data = [];
        for (let j = 0; j < message.data.length; ++j)
          object.data[j] =
            options.bytes === String
              ? $util.base64.encode(message.data[j], 0, message.data[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.data[j])
                : message.data[j];
      }
      return object;
    };

    /**
     * Converts this EnterpriseData to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseData.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseData
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseData";
    };

    return EnterpriseData;
  })();

  Enterprise.EnterpriseDataResponse = (function () {
    /**
     * Properties of an EnterpriseDataResponse.
     * @memberof Enterprise
     * @interface IEnterpriseDataResponse
     * @property {Uint8Array|null} [continuationToken] EnterpriseDataResponse continuationToken
     * @property {boolean|null} [hasMore] EnterpriseDataResponse hasMore
     * @property {Enterprise.CacheStatus|null} [cacheStatus] EnterpriseDataResponse cacheStatus
     * @property {Array.<Enterprise.IEnterpriseData>|null} [data] EnterpriseDataResponse data
     * @property {Enterprise.IGeneralDataEntity|null} [generalData] EnterpriseDataResponse generalData
     */

    /**
     * Constructs a new EnterpriseDataResponse.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseDataResponse.
     * @implements IEnterpriseDataResponse
     * @constructor
     * @param {Enterprise.IEnterpriseDataResponse=} [properties] Properties to set
     */
    function EnterpriseDataResponse(properties) {
      this.data = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseDataResponse continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     */
    EnterpriseDataResponse.prototype.continuationToken = $util.newBuffer([]);

    /**
     * EnterpriseDataResponse hasMore.
     * @member {boolean} hasMore
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     */
    EnterpriseDataResponse.prototype.hasMore = false;

    /**
     * EnterpriseDataResponse cacheStatus.
     * @member {Enterprise.CacheStatus} cacheStatus
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     */
    EnterpriseDataResponse.prototype.cacheStatus = 0;

    /**
     * EnterpriseDataResponse data.
     * @member {Array.<Enterprise.IEnterpriseData>} data
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     */
    EnterpriseDataResponse.prototype.data = $util.emptyArray;

    /**
     * EnterpriseDataResponse generalData.
     * @member {Enterprise.IGeneralDataEntity|null|undefined} generalData
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     */
    EnterpriseDataResponse.prototype.generalData = null;

    /**
     * Creates a new EnterpriseDataResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Enterprise.IEnterpriseDataResponse=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseDataResponse} EnterpriseDataResponse instance
     */
    EnterpriseDataResponse.create = function create(properties) {
      return new EnterpriseDataResponse(properties);
    };

    /**
     * Encodes the specified EnterpriseDataResponse message. Does not implicitly {@link Enterprise.EnterpriseDataResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Enterprise.IEnterpriseDataResponse} message EnterpriseDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseDataResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.continuationToken);
      if (message.hasMore != null && Object.hasOwnProperty.call(message, "hasMore"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.hasMore);
      if (message.cacheStatus != null && Object.hasOwnProperty.call(message, "cacheStatus"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.cacheStatus);
      if (message.data != null && message.data.length)
        for (let i = 0; i < message.data.length; ++i)
          $root.Enterprise.EnterpriseData.encode(
            message.data[i],
            writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
          ).ldelim();
      if (message.generalData != null && Object.hasOwnProperty.call(message, "generalData"))
        $root.Enterprise.GeneralDataEntity.encode(
          message.generalData,
          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
        ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified EnterpriseDataResponse message, length delimited. Does not implicitly {@link Enterprise.EnterpriseDataResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Enterprise.IEnterpriseDataResponse} message EnterpriseDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseDataResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseDataResponse} EnterpriseDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseDataResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseDataResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.continuationToken = reader.bytes();
            break;
          }
          case 2: {
            message.hasMore = reader.bool();
            break;
          }
          case 3: {
            message.cacheStatus = reader.int32();
            break;
          }
          case 4: {
            if (!(message.data && message.data.length)) message.data = [];
            message.data.push($root.Enterprise.EnterpriseData.decode(reader, reader.uint32()));
            break;
          }
          case 5: {
            message.generalData = $root.Enterprise.GeneralDataEntity.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseDataResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseDataResponse} EnterpriseDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseDataResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseDataResponse message.
     * @function verify
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseDataResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      if (message.hasMore != null && message.hasOwnProperty("hasMore"))
        if (typeof message.hasMore !== "boolean") return "hasMore: boolean expected";
      if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
        switch (message.cacheStatus) {
          default:
            return "cacheStatus: enum value expected";
          case 0:
          case 1:
            break;
        }
      if (message.data != null && message.hasOwnProperty("data")) {
        if (!Array.isArray(message.data)) return "data: array expected";
        for (let i = 0; i < message.data.length; ++i) {
          let error = $root.Enterprise.EnterpriseData.verify(message.data[i]);
          if (error) return "data." + error;
        }
      }
      if (message.generalData != null && message.hasOwnProperty("generalData")) {
        let error = $root.Enterprise.GeneralDataEntity.verify(message.generalData);
        if (error) return "generalData." + error;
      }
      return null;
    };

    /**
     * Creates an EnterpriseDataResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseDataResponse} EnterpriseDataResponse
     */
    EnterpriseDataResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseDataResponse) return object;
      let message = new $root.Enterprise.EnterpriseDataResponse();
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      if (object.hasMore != null) message.hasMore = Boolean(object.hasMore);
      switch (object.cacheStatus) {
        default:
          if (typeof object.cacheStatus === "number") {
            message.cacheStatus = object.cacheStatus;
            break;
          }
          break;
        case "KEEP":
        case 0:
          message.cacheStatus = 0;
          break;
        case "CLEAR":
        case 1:
          message.cacheStatus = 1;
          break;
      }
      if (object.data) {
        if (!Array.isArray(object.data))
          throw TypeError(".Enterprise.EnterpriseDataResponse.data: array expected");
        message.data = [];
        for (let i = 0; i < object.data.length; ++i) {
          if (typeof object.data[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseDataResponse.data: object expected");
          message.data[i] = $root.Enterprise.EnterpriseData.fromObject(object.data[i]);
        }
      }
      if (object.generalData != null) {
        if (typeof object.generalData !== "object")
          throw TypeError(".Enterprise.EnterpriseDataResponse.generalData: object expected");
        message.generalData = $root.Enterprise.GeneralDataEntity.fromObject(object.generalData);
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseDataResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {Enterprise.EnterpriseDataResponse} message EnterpriseDataResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseDataResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.data = [];
      if (options.defaults) {
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
        object.hasMore = false;
        object.cacheStatus = options.enums === String ? "KEEP" : 0;
        object.generalData = null;
      }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      if (message.hasMore != null && message.hasOwnProperty("hasMore"))
        object.hasMore = message.hasMore;
      if (message.cacheStatus != null && message.hasOwnProperty("cacheStatus"))
        object.cacheStatus =
          options.enums === String
            ? $root.Enterprise.CacheStatus[message.cacheStatus] === undefined
              ? message.cacheStatus
              : $root.Enterprise.CacheStatus[message.cacheStatus]
            : message.cacheStatus;
      if (message.data && message.data.length) {
        object.data = [];
        for (let j = 0; j < message.data.length; ++j)
          object.data[j] = $root.Enterprise.EnterpriseData.toObject(message.data[j], options);
      }
      if (message.generalData != null && message.hasOwnProperty("generalData"))
        object.generalData = $root.Enterprise.GeneralDataEntity.toObject(
          message.generalData,
          options,
        );
      return object;
    };

    /**
     * Converts this EnterpriseDataResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseDataResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseDataResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseDataResponse
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseDataResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseDataResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseDataResponse";
    };

    return EnterpriseDataResponse;
  })();

  Enterprise.BackupRequest = (function () {
    /**
     * Properties of a BackupRequest.
     * @memberof Enterprise
     * @interface IBackupRequest
     * @property {Uint8Array|null} [continuationToken] BackupRequest continuationToken
     */

    /**
     * Constructs a new BackupRequest.
     * @memberof Enterprise
     * @classdesc Represents a BackupRequest.
     * @implements IBackupRequest
     * @constructor
     * @param {Enterprise.IBackupRequest=} [properties] Properties to set
     */
    function BackupRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupRequest continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.BackupRequest
     * @instance
     */
    BackupRequest.prototype.continuationToken = $util.newBuffer([]);

    /**
     * Creates a new BackupRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Enterprise.IBackupRequest=} [properties] Properties to set
     * @returns {Enterprise.BackupRequest} BackupRequest instance
     */
    BackupRequest.create = function create(properties) {
      return new BackupRequest(properties);
    };

    /**
     * Encodes the specified BackupRequest message. Does not implicitly {@link Enterprise.BackupRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Enterprise.IBackupRequest} message BackupRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.continuationToken);
      return writer;
    };

    /**
     * Encodes the specified BackupRequest message, length delimited. Does not implicitly {@link Enterprise.BackupRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Enterprise.IBackupRequest} message BackupRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupRequest} BackupRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.continuationToken = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupRequest} BackupRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupRequest message.
     * @function verify
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      return null;
    };

    /**
     * Creates a BackupRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupRequest} BackupRequest
     */
    BackupRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupRequest) return object;
      let message = new $root.Enterprise.BackupRequest();
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      return message;
    };

    /**
     * Creates a plain object from a BackupRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {Enterprise.BackupRequest} message BackupRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      return object;
    };

    /**
     * Converts this BackupRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupRequest
     * @function getTypeUrl
     * @memberof Enterprise.BackupRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupRequest";
    };

    return BackupRequest;
  })();

  Enterprise.BackupRecord = (function () {
    /**
     * Properties of a BackupRecord.
     * @memberof Enterprise
     * @interface IBackupRecord
     * @property {number|null} [userId] BackupRecord userId
     * @property {Uint8Array|null} [recordUid] BackupRecord recordUid
     * @property {Uint8Array|null} [key] BackupRecord key
     * @property {Enterprise.BackupKeyType|null} [keyType] BackupRecord keyType
     * @property {number|null} [version] BackupRecord version
     * @property {Uint8Array|null} [data] BackupRecord data
     * @property {Uint8Array|null} [extra] BackupRecord extra
     */

    /**
     * Constructs a new BackupRecord.
     * @memberof Enterprise
     * @classdesc Represents a BackupRecord.
     * @implements IBackupRecord
     * @constructor
     * @param {Enterprise.IBackupRecord=} [properties] Properties to set
     */
    function BackupRecord(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupRecord userId.
     * @member {number} userId
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.userId = 0;

    /**
     * BackupRecord recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.recordUid = $util.newBuffer([]);

    /**
     * BackupRecord key.
     * @member {Uint8Array} key
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.key = $util.newBuffer([]);

    /**
     * BackupRecord keyType.
     * @member {Enterprise.BackupKeyType} keyType
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.keyType = 0;

    /**
     * BackupRecord version.
     * @member {number} version
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.version = 0;

    /**
     * BackupRecord data.
     * @member {Uint8Array} data
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.data = $util.newBuffer([]);

    /**
     * BackupRecord extra.
     * @member {Uint8Array} extra
     * @memberof Enterprise.BackupRecord
     * @instance
     */
    BackupRecord.prototype.extra = $util.newBuffer([]);

    /**
     * Creates a new BackupRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Enterprise.IBackupRecord=} [properties] Properties to set
     * @returns {Enterprise.BackupRecord} BackupRecord instance
     */
    BackupRecord.create = function create(properties) {
      return new BackupRecord(properties);
    };

    /**
     * Encodes the specified BackupRecord message. Does not implicitly {@link Enterprise.BackupRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Enterprise.IBackupRecord} message BackupRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.userId);
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.recordUid);
      if (message.key != null && Object.hasOwnProperty.call(message, "key"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.key);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.keyType);
      if (message.version != null && Object.hasOwnProperty.call(message, "version"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.version);
      if (message.data != null && Object.hasOwnProperty.call(message, "data"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.data);
      if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.extra);
      return writer;
    };

    /**
     * Encodes the specified BackupRecord message, length delimited. Does not implicitly {@link Enterprise.BackupRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Enterprise.IBackupRecord} message BackupRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupRecord} BackupRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.userId = reader.int32();
            break;
          }
          case 2: {
            message.recordUid = reader.bytes();
            break;
          }
          case 3: {
            message.key = reader.bytes();
            break;
          }
          case 4: {
            message.keyType = reader.int32();
            break;
          }
          case 5: {
            message.version = reader.int32();
            break;
          }
          case 6: {
            message.data = reader.bytes();
            break;
          }
          case 7: {
            message.extra = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupRecord} BackupRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupRecord message.
     * @function verify
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userId != null && message.hasOwnProperty("userId"))
        if (!$util.isInteger(message.userId)) return "userId: integer expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.key != null && message.hasOwnProperty("key"))
        if (
          !((message.key && typeof message.key.length === "number") || $util.isString(message.key))
        )
          return "key: buffer expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.version != null && message.hasOwnProperty("version"))
        if (!$util.isInteger(message.version)) return "version: integer expected";
      if (message.data != null && message.hasOwnProperty("data"))
        if (
          !(
            (message.data && typeof message.data.length === "number") ||
            $util.isString(message.data)
          )
        )
          return "data: buffer expected";
      if (message.extra != null && message.hasOwnProperty("extra"))
        if (
          !(
            (message.extra && typeof message.extra.length === "number") ||
            $util.isString(message.extra)
          )
        )
          return "extra: buffer expected";
      return null;
    };

    /**
     * Creates a BackupRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupRecord} BackupRecord
     */
    BackupRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupRecord) return object;
      let message = new $root.Enterprise.BackupRecord();
      if (object.userId != null) message.userId = object.userId | 0;
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.key != null)
        if (typeof object.key === "string")
          $util.base64.decode(
            object.key,
            (message.key = $util.newBuffer($util.base64.length(object.key))),
            0,
          );
        else if (object.key.length >= 0) message.key = object.key;
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      if (object.version != null) message.version = object.version | 0;
      if (object.data != null)
        if (typeof object.data === "string")
          $util.base64.decode(
            object.data,
            (message.data = $util.newBuffer($util.base64.length(object.data))),
            0,
          );
        else if (object.data.length >= 0) message.data = object.data;
      if (object.extra != null)
        if (typeof object.extra === "string")
          $util.base64.decode(
            object.extra,
            (message.extra = $util.newBuffer($util.base64.length(object.extra))),
            0,
          );
        else if (object.extra.length >= 0) message.extra = object.extra;
      return message;
    };

    /**
     * Creates a plain object from a BackupRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {Enterprise.BackupRecord} message BackupRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.userId = 0;
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        if (options.bytes === String) object.key = "";
        else {
          object.key = [];
          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
        }
        object.keyType = options.enums === String ? "NO_KEY" : 0;
        object.version = 0;
        if (options.bytes === String) object.data = "";
        else {
          object.data = [];
          if (options.bytes !== Array) object.data = $util.newBuffer(object.data);
        }
        if (options.bytes === String) object.extra = "";
        else {
          object.extra = [];
          if (options.bytes !== Array) object.extra = $util.newBuffer(object.extra);
        }
      }
      if (message.userId != null && message.hasOwnProperty("userId"))
        object.userId = message.userId;
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.key != null && message.hasOwnProperty("key"))
        object.key =
          options.bytes === String
            ? $util.base64.encode(message.key, 0, message.key.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.key)
              : message.key;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.BackupKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.BackupKeyType[message.keyType]
            : message.keyType;
      if (message.version != null && message.hasOwnProperty("version"))
        object.version = message.version;
      if (message.data != null && message.hasOwnProperty("data"))
        object.data =
          options.bytes === String
            ? $util.base64.encode(message.data, 0, message.data.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.data)
              : message.data;
      if (message.extra != null && message.hasOwnProperty("extra"))
        object.extra =
          options.bytes === String
            ? $util.base64.encode(message.extra, 0, message.extra.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.extra)
              : message.extra;
      return object;
    };

    /**
     * Converts this BackupRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupRecord
     * @function getTypeUrl
     * @memberof Enterprise.BackupRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupRecord";
    };

    return BackupRecord;
  })();

  Enterprise.BackupKey = (function () {
    /**
     * Properties of a BackupKey.
     * @memberof Enterprise
     * @interface IBackupKey
     * @property {number|null} [userId] BackupKey userId
     * @property {Uint8Array|null} [backupKey] BackupKey backupKey
     */

    /**
     * Constructs a new BackupKey.
     * @memberof Enterprise
     * @classdesc Represents a BackupKey.
     * @implements IBackupKey
     * @constructor
     * @param {Enterprise.IBackupKey=} [properties] Properties to set
     */
    function BackupKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupKey userId.
     * @member {number} userId
     * @memberof Enterprise.BackupKey
     * @instance
     */
    BackupKey.prototype.userId = 0;

    /**
     * BackupKey backupKey.
     * @member {Uint8Array} backupKey
     * @memberof Enterprise.BackupKey
     * @instance
     */
    BackupKey.prototype.backupKey = $util.newBuffer([]);

    /**
     * Creates a new BackupKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Enterprise.IBackupKey=} [properties] Properties to set
     * @returns {Enterprise.BackupKey} BackupKey instance
     */
    BackupKey.create = function create(properties) {
      return new BackupKey(properties);
    };

    /**
     * Encodes the specified BackupKey message. Does not implicitly {@link Enterprise.BackupKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Enterprise.IBackupKey} message BackupKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.userId);
      if (message.backupKey != null && Object.hasOwnProperty.call(message, "backupKey"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.backupKey);
      return writer;
    };

    /**
     * Encodes the specified BackupKey message, length delimited. Does not implicitly {@link Enterprise.BackupKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Enterprise.IBackupKey} message BackupKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupKey} BackupKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.userId = reader.int32();
            break;
          }
          case 2: {
            message.backupKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupKey} BackupKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupKey message.
     * @function verify
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userId != null && message.hasOwnProperty("userId"))
        if (!$util.isInteger(message.userId)) return "userId: integer expected";
      if (message.backupKey != null && message.hasOwnProperty("backupKey"))
        if (
          !(
            (message.backupKey && typeof message.backupKey.length === "number") ||
            $util.isString(message.backupKey)
          )
        )
          return "backupKey: buffer expected";
      return null;
    };

    /**
     * Creates a BackupKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupKey} BackupKey
     */
    BackupKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupKey) return object;
      let message = new $root.Enterprise.BackupKey();
      if (object.userId != null) message.userId = object.userId | 0;
      if (object.backupKey != null)
        if (typeof object.backupKey === "string")
          $util.base64.decode(
            object.backupKey,
            (message.backupKey = $util.newBuffer($util.base64.length(object.backupKey))),
            0,
          );
        else if (object.backupKey.length >= 0) message.backupKey = object.backupKey;
      return message;
    };

    /**
     * Creates a plain object from a BackupKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupKey
     * @static
     * @param {Enterprise.BackupKey} message BackupKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.userId = 0;
        if (options.bytes === String) object.backupKey = "";
        else {
          object.backupKey = [];
          if (options.bytes !== Array) object.backupKey = $util.newBuffer(object.backupKey);
        }
      }
      if (message.userId != null && message.hasOwnProperty("userId"))
        object.userId = message.userId;
      if (message.backupKey != null && message.hasOwnProperty("backupKey"))
        object.backupKey =
          options.bytes === String
            ? $util.base64.encode(message.backupKey, 0, message.backupKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.backupKey)
              : message.backupKey;
      return object;
    };

    /**
     * Converts this BackupKey to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupKey
     * @function getTypeUrl
     * @memberof Enterprise.BackupKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupKey";
    };

    return BackupKey;
  })();

  Enterprise.BackupUser = (function () {
    /**
     * Properties of a BackupUser.
     * @memberof Enterprise
     * @interface IBackupUser
     * @property {number|null} [userId] BackupUser userId
     * @property {string|null} [userName] BackupUser userName
     * @property {Uint8Array|null} [dataKey] BackupUser dataKey
     * @property {Enterprise.BackupUserDataKeyType|null} [dataKeyType] BackupUser dataKeyType
     * @property {Uint8Array|null} [privateKey] BackupUser privateKey
     * @property {Uint8Array|null} [treeKey] BackupUser treeKey
     * @property {Enterprise.BackupKeyType|null} [treeKeyType] BackupUser treeKeyType
     * @property {Array.<Enterprise.IBackupKey>|null} [backupKeys] BackupUser backupKeys
     * @property {Uint8Array|null} [privateECKey] BackupUser privateECKey
     */

    /**
     * Constructs a new BackupUser.
     * @memberof Enterprise
     * @classdesc Represents a BackupUser.
     * @implements IBackupUser
     * @constructor
     * @param {Enterprise.IBackupUser=} [properties] Properties to set
     */
    function BackupUser(properties) {
      this.backupKeys = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupUser userId.
     * @member {number} userId
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.userId = 0;

    /**
     * BackupUser userName.
     * @member {string} userName
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.userName = "";

    /**
     * BackupUser dataKey.
     * @member {Uint8Array} dataKey
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.dataKey = $util.newBuffer([]);

    /**
     * BackupUser dataKeyType.
     * @member {Enterprise.BackupUserDataKeyType} dataKeyType
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.dataKeyType = 0;

    /**
     * BackupUser privateKey.
     * @member {Uint8Array} privateKey
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.privateKey = $util.newBuffer([]);

    /**
     * BackupUser treeKey.
     * @member {Uint8Array} treeKey
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.treeKey = $util.newBuffer([]);

    /**
     * BackupUser treeKeyType.
     * @member {Enterprise.BackupKeyType} treeKeyType
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.treeKeyType = 0;

    /**
     * BackupUser backupKeys.
     * @member {Array.<Enterprise.IBackupKey>} backupKeys
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.backupKeys = $util.emptyArray;

    /**
     * BackupUser privateECKey.
     * @member {Uint8Array} privateECKey
     * @memberof Enterprise.BackupUser
     * @instance
     */
    BackupUser.prototype.privateECKey = $util.newBuffer([]);

    /**
     * Creates a new BackupUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Enterprise.IBackupUser=} [properties] Properties to set
     * @returns {Enterprise.BackupUser} BackupUser instance
     */
    BackupUser.create = function create(properties) {
      return new BackupUser(properties);
    };

    /**
     * Encodes the specified BackupUser message. Does not implicitly {@link Enterprise.BackupUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Enterprise.IBackupUser} message BackupUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.userId);
      if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.userName);
      if (message.dataKey != null && Object.hasOwnProperty.call(message, "dataKey"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.dataKey);
      if (message.dataKeyType != null && Object.hasOwnProperty.call(message, "dataKeyType"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.dataKeyType);
      if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.privateKey);
      if (message.treeKey != null && Object.hasOwnProperty.call(message, "treeKey"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.treeKey);
      if (message.treeKeyType != null && Object.hasOwnProperty.call(message, "treeKeyType"))
        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.treeKeyType);
      if (message.backupKeys != null && message.backupKeys.length)
        for (let i = 0; i < message.backupKeys.length; ++i)
          $root.Enterprise.BackupKey.encode(
            message.backupKeys[i],
            writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
          ).ldelim();
      if (message.privateECKey != null && Object.hasOwnProperty.call(message, "privateECKey"))
        writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.privateECKey);
      return writer;
    };

    /**
     * Encodes the specified BackupUser message, length delimited. Does not implicitly {@link Enterprise.BackupUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Enterprise.IBackupUser} message BackupUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupUser} BackupUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.userId = reader.int32();
            break;
          }
          case 2: {
            message.userName = reader.string();
            break;
          }
          case 3: {
            message.dataKey = reader.bytes();
            break;
          }
          case 4: {
            message.dataKeyType = reader.int32();
            break;
          }
          case 5: {
            message.privateKey = reader.bytes();
            break;
          }
          case 6: {
            message.treeKey = reader.bytes();
            break;
          }
          case 7: {
            message.treeKeyType = reader.int32();
            break;
          }
          case 8: {
            if (!(message.backupKeys && message.backupKeys.length)) message.backupKeys = [];
            message.backupKeys.push($root.Enterprise.BackupKey.decode(reader, reader.uint32()));
            break;
          }
          case 9: {
            message.privateECKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupUser} BackupUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupUser message.
     * @function verify
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userId != null && message.hasOwnProperty("userId"))
        if (!$util.isInteger(message.userId)) return "userId: integer expected";
      if (message.userName != null && message.hasOwnProperty("userName"))
        if (!$util.isString(message.userName)) return "userName: string expected";
      if (message.dataKey != null && message.hasOwnProperty("dataKey"))
        if (
          !(
            (message.dataKey && typeof message.dataKey.length === "number") ||
            $util.isString(message.dataKey)
          )
        )
          return "dataKey: buffer expected";
      if (message.dataKeyType != null && message.hasOwnProperty("dataKeyType"))
        switch (message.dataKeyType) {
          default:
            return "dataKeyType: enum value expected";
          case 0:
          case 1:
            break;
        }
      if (message.privateKey != null && message.hasOwnProperty("privateKey"))
        if (
          !(
            (message.privateKey && typeof message.privateKey.length === "number") ||
            $util.isString(message.privateKey)
          )
        )
          return "privateKey: buffer expected";
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        if (
          !(
            (message.treeKey && typeof message.treeKey.length === "number") ||
            $util.isString(message.treeKey)
          )
        )
          return "treeKey: buffer expected";
      if (message.treeKeyType != null && message.hasOwnProperty("treeKeyType"))
        switch (message.treeKeyType) {
          default:
            return "treeKeyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.backupKeys != null && message.hasOwnProperty("backupKeys")) {
        if (!Array.isArray(message.backupKeys)) return "backupKeys: array expected";
        for (let i = 0; i < message.backupKeys.length; ++i) {
          let error = $root.Enterprise.BackupKey.verify(message.backupKeys[i]);
          if (error) return "backupKeys." + error;
        }
      }
      if (message.privateECKey != null && message.hasOwnProperty("privateECKey"))
        if (
          !(
            (message.privateECKey && typeof message.privateECKey.length === "number") ||
            $util.isString(message.privateECKey)
          )
        )
          return "privateECKey: buffer expected";
      return null;
    };

    /**
     * Creates a BackupUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupUser} BackupUser
     */
    BackupUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupUser) return object;
      let message = new $root.Enterprise.BackupUser();
      if (object.userId != null) message.userId = object.userId | 0;
      if (object.userName != null) message.userName = String(object.userName);
      if (object.dataKey != null)
        if (typeof object.dataKey === "string")
          $util.base64.decode(
            object.dataKey,
            (message.dataKey = $util.newBuffer($util.base64.length(object.dataKey))),
            0,
          );
        else if (object.dataKey.length >= 0) message.dataKey = object.dataKey;
      switch (object.dataKeyType) {
        default:
          if (typeof object.dataKeyType === "number") {
            message.dataKeyType = object.dataKeyType;
            break;
          }
          break;
        case "OWN":
        case 0:
          message.dataKeyType = 0;
          break;
        case "SHARED_TO_ENTERPRISE":
        case 1:
          message.dataKeyType = 1;
          break;
      }
      if (object.privateKey != null)
        if (typeof object.privateKey === "string")
          $util.base64.decode(
            object.privateKey,
            (message.privateKey = $util.newBuffer($util.base64.length(object.privateKey))),
            0,
          );
        else if (object.privateKey.length >= 0) message.privateKey = object.privateKey;
      if (object.treeKey != null)
        if (typeof object.treeKey === "string")
          $util.base64.decode(
            object.treeKey,
            (message.treeKey = $util.newBuffer($util.base64.length(object.treeKey))),
            0,
          );
        else if (object.treeKey.length >= 0) message.treeKey = object.treeKey;
      switch (object.treeKeyType) {
        default:
          if (typeof object.treeKeyType === "number") {
            message.treeKeyType = object.treeKeyType;
            break;
          }
          break;
        case "NO_KEY":
        case 0:
          message.treeKeyType = 0;
          break;
        case "ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.treeKeyType = 1;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.treeKeyType = 2;
          break;
        case "ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.treeKeyType = 3;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.treeKeyType = 4;
          break;
      }
      if (object.backupKeys) {
        if (!Array.isArray(object.backupKeys))
          throw TypeError(".Enterprise.BackupUser.backupKeys: array expected");
        message.backupKeys = [];
        for (let i = 0; i < object.backupKeys.length; ++i) {
          if (typeof object.backupKeys[i] !== "object")
            throw TypeError(".Enterprise.BackupUser.backupKeys: object expected");
          message.backupKeys[i] = $root.Enterprise.BackupKey.fromObject(object.backupKeys[i]);
        }
      }
      if (object.privateECKey != null)
        if (typeof object.privateECKey === "string")
          $util.base64.decode(
            object.privateECKey,
            (message.privateECKey = $util.newBuffer($util.base64.length(object.privateECKey))),
            0,
          );
        else if (object.privateECKey.length >= 0) message.privateECKey = object.privateECKey;
      return message;
    };

    /**
     * Creates a plain object from a BackupUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupUser
     * @static
     * @param {Enterprise.BackupUser} message BackupUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.backupKeys = [];
      if (options.defaults) {
        object.userId = 0;
        object.userName = "";
        if (options.bytes === String) object.dataKey = "";
        else {
          object.dataKey = [];
          if (options.bytes !== Array) object.dataKey = $util.newBuffer(object.dataKey);
        }
        object.dataKeyType = options.enums === String ? "OWN" : 0;
        if (options.bytes === String) object.privateKey = "";
        else {
          object.privateKey = [];
          if (options.bytes !== Array) object.privateKey = $util.newBuffer(object.privateKey);
        }
        if (options.bytes === String) object.treeKey = "";
        else {
          object.treeKey = [];
          if (options.bytes !== Array) object.treeKey = $util.newBuffer(object.treeKey);
        }
        object.treeKeyType = options.enums === String ? "NO_KEY" : 0;
        if (options.bytes === String) object.privateECKey = "";
        else {
          object.privateECKey = [];
          if (options.bytes !== Array) object.privateECKey = $util.newBuffer(object.privateECKey);
        }
      }
      if (message.userId != null && message.hasOwnProperty("userId"))
        object.userId = message.userId;
      if (message.userName != null && message.hasOwnProperty("userName"))
        object.userName = message.userName;
      if (message.dataKey != null && message.hasOwnProperty("dataKey"))
        object.dataKey =
          options.bytes === String
            ? $util.base64.encode(message.dataKey, 0, message.dataKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.dataKey)
              : message.dataKey;
      if (message.dataKeyType != null && message.hasOwnProperty("dataKeyType"))
        object.dataKeyType =
          options.enums === String
            ? $root.Enterprise.BackupUserDataKeyType[message.dataKeyType] === undefined
              ? message.dataKeyType
              : $root.Enterprise.BackupUserDataKeyType[message.dataKeyType]
            : message.dataKeyType;
      if (message.privateKey != null && message.hasOwnProperty("privateKey"))
        object.privateKey =
          options.bytes === String
            ? $util.base64.encode(message.privateKey, 0, message.privateKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.privateKey)
              : message.privateKey;
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        object.treeKey =
          options.bytes === String
            ? $util.base64.encode(message.treeKey, 0, message.treeKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.treeKey)
              : message.treeKey;
      if (message.treeKeyType != null && message.hasOwnProperty("treeKeyType"))
        object.treeKeyType =
          options.enums === String
            ? $root.Enterprise.BackupKeyType[message.treeKeyType] === undefined
              ? message.treeKeyType
              : $root.Enterprise.BackupKeyType[message.treeKeyType]
            : message.treeKeyType;
      if (message.backupKeys && message.backupKeys.length) {
        object.backupKeys = [];
        for (let j = 0; j < message.backupKeys.length; ++j)
          object.backupKeys[j] = $root.Enterprise.BackupKey.toObject(
            message.backupKeys[j],
            options,
          );
      }
      if (message.privateECKey != null && message.hasOwnProperty("privateECKey"))
        object.privateECKey =
          options.bytes === String
            ? $util.base64.encode(message.privateECKey, 0, message.privateECKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.privateECKey)
              : message.privateECKey;
      return object;
    };

    /**
     * Converts this BackupUser to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupUser
     * @function getTypeUrl
     * @memberof Enterprise.BackupUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupUser";
    };

    return BackupUser;
  })();

  Enterprise.BackupResponse = (function () {
    /**
     * Properties of a BackupResponse.
     * @memberof Enterprise
     * @interface IBackupResponse
     * @property {Uint8Array|null} [enterpriseEccPrivateKey] BackupResponse enterpriseEccPrivateKey
     * @property {Array.<Enterprise.IBackupUser>|null} [users] BackupResponse users
     * @property {Array.<Enterprise.IBackupRecord>|null} [records] BackupResponse records
     * @property {Uint8Array|null} [continuationToken] BackupResponse continuationToken
     */

    /**
     * Constructs a new BackupResponse.
     * @memberof Enterprise
     * @classdesc Represents a BackupResponse.
     * @implements IBackupResponse
     * @constructor
     * @param {Enterprise.IBackupResponse=} [properties] Properties to set
     */
    function BackupResponse(properties) {
      this.users = [];
      this.records = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupResponse enterpriseEccPrivateKey.
     * @member {Uint8Array} enterpriseEccPrivateKey
     * @memberof Enterprise.BackupResponse
     * @instance
     */
    BackupResponse.prototype.enterpriseEccPrivateKey = $util.newBuffer([]);

    /**
     * BackupResponse users.
     * @member {Array.<Enterprise.IBackupUser>} users
     * @memberof Enterprise.BackupResponse
     * @instance
     */
    BackupResponse.prototype.users = $util.emptyArray;

    /**
     * BackupResponse records.
     * @member {Array.<Enterprise.IBackupRecord>} records
     * @memberof Enterprise.BackupResponse
     * @instance
     */
    BackupResponse.prototype.records = $util.emptyArray;

    /**
     * BackupResponse continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.BackupResponse
     * @instance
     */
    BackupResponse.prototype.continuationToken = $util.newBuffer([]);

    /**
     * Creates a new BackupResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Enterprise.IBackupResponse=} [properties] Properties to set
     * @returns {Enterprise.BackupResponse} BackupResponse instance
     */
    BackupResponse.create = function create(properties) {
      return new BackupResponse(properties);
    };

    /**
     * Encodes the specified BackupResponse message. Does not implicitly {@link Enterprise.BackupResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Enterprise.IBackupResponse} message BackupResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseEccPrivateKey != null &&
        Object.hasOwnProperty.call(message, "enterpriseEccPrivateKey")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.enterpriseEccPrivateKey);
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.BackupUser.encode(
            message.users[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.records != null && message.records.length)
        for (let i = 0; i < message.records.length; ++i)
          $root.Enterprise.BackupRecord.encode(
            message.records[i],
            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
          ).ldelim();
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.continuationToken);
      return writer;
    };

    /**
     * Encodes the specified BackupResponse message, length delimited. Does not implicitly {@link Enterprise.BackupResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Enterprise.IBackupResponse} message BackupResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupResponse} BackupResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseEccPrivateKey = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push($root.Enterprise.BackupUser.decode(reader, reader.uint32()));
            break;
          }
          case 3: {
            if (!(message.records && message.records.length)) message.records = [];
            message.records.push($root.Enterprise.BackupRecord.decode(reader, reader.uint32()));
            break;
          }
          case 4: {
            message.continuationToken = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupResponse} BackupResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupResponse message.
     * @function verify
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (
        message.enterpriseEccPrivateKey != null &&
        message.hasOwnProperty("enterpriseEccPrivateKey")
      )
        if (
          !(
            (message.enterpriseEccPrivateKey &&
              typeof message.enterpriseEccPrivateKey.length === "number") ||
            $util.isString(message.enterpriseEccPrivateKey)
          )
        )
          return "enterpriseEccPrivateKey: buffer expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.BackupUser.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      if (message.records != null && message.hasOwnProperty("records")) {
        if (!Array.isArray(message.records)) return "records: array expected";
        for (let i = 0; i < message.records.length; ++i) {
          let error = $root.Enterprise.BackupRecord.verify(message.records[i]);
          if (error) return "records." + error;
        }
      }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      return null;
    };

    /**
     * Creates a BackupResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupResponse} BackupResponse
     */
    BackupResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupResponse) return object;
      let message = new $root.Enterprise.BackupResponse();
      if (object.enterpriseEccPrivateKey != null)
        if (typeof object.enterpriseEccPrivateKey === "string")
          $util.base64.decode(
            object.enterpriseEccPrivateKey,
            (message.enterpriseEccPrivateKey = $util.newBuffer(
              $util.base64.length(object.enterpriseEccPrivateKey),
            )),
            0,
          );
        else if (object.enterpriseEccPrivateKey.length >= 0)
          message.enterpriseEccPrivateKey = object.enterpriseEccPrivateKey;
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.BackupResponse.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.BackupResponse.users: object expected");
          message.users[i] = $root.Enterprise.BackupUser.fromObject(object.users[i]);
        }
      }
      if (object.records) {
        if (!Array.isArray(object.records))
          throw TypeError(".Enterprise.BackupResponse.records: array expected");
        message.records = [];
        for (let i = 0; i < object.records.length; ++i) {
          if (typeof object.records[i] !== "object")
            throw TypeError(".Enterprise.BackupResponse.records: object expected");
          message.records[i] = $root.Enterprise.BackupRecord.fromObject(object.records[i]);
        }
      }
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      return message;
    };

    /**
     * Creates a plain object from a BackupResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {Enterprise.BackupResponse} message BackupResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.users = [];
        object.records = [];
      }
      if (options.defaults) {
        if (options.bytes === String) object.enterpriseEccPrivateKey = "";
        else {
          object.enterpriseEccPrivateKey = [];
          if (options.bytes !== Array)
            object.enterpriseEccPrivateKey = $util.newBuffer(object.enterpriseEccPrivateKey);
        }
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
      }
      if (
        message.enterpriseEccPrivateKey != null &&
        message.hasOwnProperty("enterpriseEccPrivateKey")
      )
        object.enterpriseEccPrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.enterpriseEccPrivateKey,
                0,
                message.enterpriseEccPrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.enterpriseEccPrivateKey)
              : message.enterpriseEccPrivateKey;
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.BackupUser.toObject(message.users[j], options);
      }
      if (message.records && message.records.length) {
        object.records = [];
        for (let j = 0; j < message.records.length; ++j)
          object.records[j] = $root.Enterprise.BackupRecord.toObject(message.records[j], options);
      }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      return object;
    };

    /**
     * Converts this BackupResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupResponse
     * @function getTypeUrl
     * @memberof Enterprise.BackupResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupResponse";
    };

    return BackupResponse;
  })();

  Enterprise.BackupFile = (function () {
    /**
     * Properties of a BackupFile.
     * @memberof Enterprise
     * @interface IBackupFile
     * @property {string|null} [user] BackupFile user
     * @property {Uint8Array|null} [backupUid] BackupFile backupUid
     * @property {string|null} [fileName] BackupFile fileName
     * @property {number|Long|null} [created] BackupFile created
     * @property {string|null} [downloadUrl] BackupFile downloadUrl
     */

    /**
     * Constructs a new BackupFile.
     * @memberof Enterprise
     * @classdesc Represents a BackupFile.
     * @implements IBackupFile
     * @constructor
     * @param {Enterprise.IBackupFile=} [properties] Properties to set
     */
    function BackupFile(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupFile user.
     * @member {string} user
     * @memberof Enterprise.BackupFile
     * @instance
     */
    BackupFile.prototype.user = "";

    /**
     * BackupFile backupUid.
     * @member {Uint8Array} backupUid
     * @memberof Enterprise.BackupFile
     * @instance
     */
    BackupFile.prototype.backupUid = $util.newBuffer([]);

    /**
     * BackupFile fileName.
     * @member {string} fileName
     * @memberof Enterprise.BackupFile
     * @instance
     */
    BackupFile.prototype.fileName = "";

    /**
     * BackupFile created.
     * @member {number|Long} created
     * @memberof Enterprise.BackupFile
     * @instance
     */
    BackupFile.prototype.created = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * BackupFile downloadUrl.
     * @member {string} downloadUrl
     * @memberof Enterprise.BackupFile
     * @instance
     */
    BackupFile.prototype.downloadUrl = "";

    /**
     * Creates a new BackupFile instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Enterprise.IBackupFile=} [properties] Properties to set
     * @returns {Enterprise.BackupFile} BackupFile instance
     */
    BackupFile.create = function create(properties) {
      return new BackupFile(properties);
    };

    /**
     * Encodes the specified BackupFile message. Does not implicitly {@link Enterprise.BackupFile.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Enterprise.IBackupFile} message BackupFile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupFile.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.user != null && Object.hasOwnProperty.call(message, "user"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.user);
      if (message.backupUid != null && Object.hasOwnProperty.call(message, "backupUid"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.backupUid);
      if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.fileName);
      if (message.created != null && Object.hasOwnProperty.call(message, "created"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.created);
      if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.downloadUrl);
      return writer;
    };

    /**
     * Encodes the specified BackupFile message, length delimited. Does not implicitly {@link Enterprise.BackupFile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Enterprise.IBackupFile} message BackupFile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupFile.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupFile message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupFile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupFile} BackupFile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupFile.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupFile();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.user = reader.string();
            break;
          }
          case 2: {
            message.backupUid = reader.bytes();
            break;
          }
          case 3: {
            message.fileName = reader.string();
            break;
          }
          case 4: {
            message.created = reader.int64();
            break;
          }
          case 5: {
            message.downloadUrl = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupFile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupFile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupFile} BackupFile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupFile.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupFile message.
     * @function verify
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupFile.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.user != null && message.hasOwnProperty("user"))
        if (!$util.isString(message.user)) return "user: string expected";
      if (message.backupUid != null && message.hasOwnProperty("backupUid"))
        if (
          !(
            (message.backupUid && typeof message.backupUid.length === "number") ||
            $util.isString(message.backupUid)
          )
        )
          return "backupUid: buffer expected";
      if (message.fileName != null && message.hasOwnProperty("fileName"))
        if (!$util.isString(message.fileName)) return "fileName: string expected";
      if (message.created != null && message.hasOwnProperty("created"))
        if (
          !$util.isInteger(message.created) &&
          !(
            message.created &&
            $util.isInteger(message.created.low) &&
            $util.isInteger(message.created.high)
          )
        )
          return "created: integer|Long expected";
      if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
        if (!$util.isString(message.downloadUrl)) return "downloadUrl: string expected";
      return null;
    };

    /**
     * Creates a BackupFile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupFile} BackupFile
     */
    BackupFile.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupFile) return object;
      let message = new $root.Enterprise.BackupFile();
      if (object.user != null) message.user = String(object.user);
      if (object.backupUid != null)
        if (typeof object.backupUid === "string")
          $util.base64.decode(
            object.backupUid,
            (message.backupUid = $util.newBuffer($util.base64.length(object.backupUid))),
            0,
          );
        else if (object.backupUid.length >= 0) message.backupUid = object.backupUid;
      if (object.fileName != null) message.fileName = String(object.fileName);
      if (object.created != null)
        if ($util.Long) (message.created = $util.Long.fromValue(object.created)).unsigned = false;
        else if (typeof object.created === "string") message.created = parseInt(object.created, 10);
        else if (typeof object.created === "number") message.created = object.created;
        else if (typeof object.created === "object")
          message.created = new $util.LongBits(
            object.created.low >>> 0,
            object.created.high >>> 0,
          ).toNumber();
      if (object.downloadUrl != null) message.downloadUrl = String(object.downloadUrl);
      return message;
    };

    /**
     * Creates a plain object from a BackupFile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupFile
     * @static
     * @param {Enterprise.BackupFile} message BackupFile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupFile.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.user = "";
        if (options.bytes === String) object.backupUid = "";
        else {
          object.backupUid = [];
          if (options.bytes !== Array) object.backupUid = $util.newBuffer(object.backupUid);
        }
        object.fileName = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.created =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.created = options.longs === String ? "0" : 0;
        object.downloadUrl = "";
      }
      if (message.user != null && message.hasOwnProperty("user")) object.user = message.user;
      if (message.backupUid != null && message.hasOwnProperty("backupUid"))
        object.backupUid =
          options.bytes === String
            ? $util.base64.encode(message.backupUid, 0, message.backupUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.backupUid)
              : message.backupUid;
      if (message.fileName != null && message.hasOwnProperty("fileName"))
        object.fileName = message.fileName;
      if (message.created != null && message.hasOwnProperty("created"))
        if (typeof message.created === "number")
          object.created = options.longs === String ? String(message.created) : message.created;
        else
          object.created =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.created)
              : options.longs === Number
                ? new $util.LongBits(
                    message.created.low >>> 0,
                    message.created.high >>> 0,
                  ).toNumber()
                : message.created;
      if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
        object.downloadUrl = message.downloadUrl;
      return object;
    };

    /**
     * Converts this BackupFile to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupFile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupFile.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupFile
     * @function getTypeUrl
     * @memberof Enterprise.BackupFile
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupFile";
    };

    return BackupFile;
  })();

  Enterprise.BackupsResponse = (function () {
    /**
     * Properties of a BackupsResponse.
     * @memberof Enterprise
     * @interface IBackupsResponse
     * @property {Array.<Enterprise.IBackupFile>|null} [files] BackupsResponse files
     */

    /**
     * Constructs a new BackupsResponse.
     * @memberof Enterprise
     * @classdesc Represents a BackupsResponse.
     * @implements IBackupsResponse
     * @constructor
     * @param {Enterprise.IBackupsResponse=} [properties] Properties to set
     */
    function BackupsResponse(properties) {
      this.files = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * BackupsResponse files.
     * @member {Array.<Enterprise.IBackupFile>} files
     * @memberof Enterprise.BackupsResponse
     * @instance
     */
    BackupsResponse.prototype.files = $util.emptyArray;

    /**
     * Creates a new BackupsResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Enterprise.IBackupsResponse=} [properties] Properties to set
     * @returns {Enterprise.BackupsResponse} BackupsResponse instance
     */
    BackupsResponse.create = function create(properties) {
      return new BackupsResponse(properties);
    };

    /**
     * Encodes the specified BackupsResponse message. Does not implicitly {@link Enterprise.BackupsResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Enterprise.IBackupsResponse} message BackupsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupsResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.files != null && message.files.length)
        for (let i = 0; i < message.files.length; ++i)
          $root.Enterprise.BackupFile.encode(
            message.files[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified BackupsResponse message, length delimited. Does not implicitly {@link Enterprise.BackupsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Enterprise.IBackupsResponse} message BackupsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BackupsResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BackupsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.BackupsResponse} BackupsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupsResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.BackupsResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.files && message.files.length)) message.files = [];
            message.files.push($root.Enterprise.BackupFile.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a BackupsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.BackupsResponse} BackupsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BackupsResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BackupsResponse message.
     * @function verify
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BackupsResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.files != null && message.hasOwnProperty("files")) {
        if (!Array.isArray(message.files)) return "files: array expected";
        for (let i = 0; i < message.files.length; ++i) {
          let error = $root.Enterprise.BackupFile.verify(message.files[i]);
          if (error) return "files." + error;
        }
      }
      return null;
    };

    /**
     * Creates a BackupsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.BackupsResponse} BackupsResponse
     */
    BackupsResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.BackupsResponse) return object;
      let message = new $root.Enterprise.BackupsResponse();
      if (object.files) {
        if (!Array.isArray(object.files))
          throw TypeError(".Enterprise.BackupsResponse.files: array expected");
        message.files = [];
        for (let i = 0; i < object.files.length; ++i) {
          if (typeof object.files[i] !== "object")
            throw TypeError(".Enterprise.BackupsResponse.files: object expected");
          message.files[i] = $root.Enterprise.BackupFile.fromObject(object.files[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a BackupsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {Enterprise.BackupsResponse} message BackupsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BackupsResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.files = [];
      if (message.files && message.files.length) {
        object.files = [];
        for (let j = 0; j < message.files.length; ++j)
          object.files[j] = $root.Enterprise.BackupFile.toObject(message.files[j], options);
      }
      return object;
    };

    /**
     * Converts this BackupsResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.BackupsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BackupsResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for BackupsResponse
     * @function getTypeUrl
     * @memberof Enterprise.BackupsResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    BackupsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.BackupsResponse";
    };

    return BackupsResponse;
  })();

  Enterprise.GetEnterpriseDataKeysRequest = (function () {
    /**
     * Properties of a GetEnterpriseDataKeysRequest.
     * @memberof Enterprise
     * @interface IGetEnterpriseDataKeysRequest
     * @property {Array.<number|Long>|null} [roleId] GetEnterpriseDataKeysRequest roleId
     */

    /**
     * Constructs a new GetEnterpriseDataKeysRequest.
     * @memberof Enterprise
     * @classdesc Represents a GetEnterpriseDataKeysRequest.
     * @implements IGetEnterpriseDataKeysRequest
     * @constructor
     * @param {Enterprise.IGetEnterpriseDataKeysRequest=} [properties] Properties to set
     */
    function GetEnterpriseDataKeysRequest(properties) {
      this.roleId = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetEnterpriseDataKeysRequest roleId.
     * @member {Array.<number|Long>} roleId
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @instance
     */
    GetEnterpriseDataKeysRequest.prototype.roleId = $util.emptyArray;

    /**
     * Creates a new GetEnterpriseDataKeysRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysRequest=} [properties] Properties to set
     * @returns {Enterprise.GetEnterpriseDataKeysRequest} GetEnterpriseDataKeysRequest instance
     */
    GetEnterpriseDataKeysRequest.create = function create(properties) {
      return new GetEnterpriseDataKeysRequest(properties);
    };

    /**
     * Encodes the specified GetEnterpriseDataKeysRequest message. Does not implicitly {@link Enterprise.GetEnterpriseDataKeysRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysRequest} message GetEnterpriseDataKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEnterpriseDataKeysRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && message.roleId.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.roleId.length; ++i) writer.int64(message.roleId[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified GetEnterpriseDataKeysRequest message, length delimited. Does not implicitly {@link Enterprise.GetEnterpriseDataKeysRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysRequest} message GetEnterpriseDataKeysRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEnterpriseDataKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetEnterpriseDataKeysRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetEnterpriseDataKeysRequest} GetEnterpriseDataKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEnterpriseDataKeysRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetEnterpriseDataKeysRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.roleId && message.roleId.length)) message.roleId = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.roleId.push(reader.int64());
            } else message.roleId.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetEnterpriseDataKeysRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetEnterpriseDataKeysRequest} GetEnterpriseDataKeysRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEnterpriseDataKeysRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetEnterpriseDataKeysRequest message.
     * @function verify
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetEnterpriseDataKeysRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId")) {
        if (!Array.isArray(message.roleId)) return "roleId: array expected";
        for (let i = 0; i < message.roleId.length; ++i)
          if (
            !$util.isInteger(message.roleId[i]) &&
            !(
              message.roleId[i] &&
              $util.isInteger(message.roleId[i].low) &&
              $util.isInteger(message.roleId[i].high)
            )
          )
            return "roleId: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a GetEnterpriseDataKeysRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetEnterpriseDataKeysRequest} GetEnterpriseDataKeysRequest
     */
    GetEnterpriseDataKeysRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetEnterpriseDataKeysRequest) return object;
      let message = new $root.Enterprise.GetEnterpriseDataKeysRequest();
      if (object.roleId) {
        if (!Array.isArray(object.roleId))
          throw TypeError(".Enterprise.GetEnterpriseDataKeysRequest.roleId: array expected");
        message.roleId = [];
        for (let i = 0; i < object.roleId.length; ++i)
          if ($util.Long)
            (message.roleId[i] = $util.Long.fromValue(object.roleId[i])).unsigned = false;
          else if (typeof object.roleId[i] === "string")
            message.roleId[i] = parseInt(object.roleId[i], 10);
          else if (typeof object.roleId[i] === "number") message.roleId[i] = object.roleId[i];
          else if (typeof object.roleId[i] === "object")
            message.roleId[i] = new $util.LongBits(
              object.roleId[i].low >>> 0,
              object.roleId[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a GetEnterpriseDataKeysRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {Enterprise.GetEnterpriseDataKeysRequest} message GetEnterpriseDataKeysRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetEnterpriseDataKeysRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleId = [];
      if (message.roleId && message.roleId.length) {
        object.roleId = [];
        for (let j = 0; j < message.roleId.length; ++j)
          if (typeof message.roleId[j] === "number")
            object.roleId[j] =
              options.longs === String ? String(message.roleId[j]) : message.roleId[j];
          else
            object.roleId[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.roleId[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.roleId[j].low >>> 0,
                      message.roleId[j].high >>> 0,
                    ).toNumber()
                  : message.roleId[j];
      }
      return object;
    };

    /**
     * Converts this GetEnterpriseDataKeysRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetEnterpriseDataKeysRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetEnterpriseDataKeysRequest
     * @function getTypeUrl
     * @memberof Enterprise.GetEnterpriseDataKeysRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetEnterpriseDataKeysRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetEnterpriseDataKeysRequest";
    };

    return GetEnterpriseDataKeysRequest;
  })();

  Enterprise.GetEnterpriseDataKeysResponse = (function () {
    /**
     * Properties of a GetEnterpriseDataKeysResponse.
     * @memberof Enterprise
     * @interface IGetEnterpriseDataKeysResponse
     * @property {Array.<Enterprise.IReEncryptedRoleKey>|null} [reEncryptedRoleKey] GetEnterpriseDataKeysResponse reEncryptedRoleKey
     * @property {Array.<Enterprise.IRoleKey>|null} [roleKey] GetEnterpriseDataKeysResponse roleKey
     * @property {Enterprise.IMspKey|null} [mspKey] GetEnterpriseDataKeysResponse mspKey
     * @property {Enterprise.IEnterpriseKeys|null} [enterpriseKeys] GetEnterpriseDataKeysResponse enterpriseKeys
     * @property {Enterprise.ITreeKey|null} [treeKey] GetEnterpriseDataKeysResponse treeKey
     */

    /**
     * Constructs a new GetEnterpriseDataKeysResponse.
     * @memberof Enterprise
     * @classdesc Represents a GetEnterpriseDataKeysResponse.
     * @implements IGetEnterpriseDataKeysResponse
     * @constructor
     * @param {Enterprise.IGetEnterpriseDataKeysResponse=} [properties] Properties to set
     */
    function GetEnterpriseDataKeysResponse(properties) {
      this.reEncryptedRoleKey = [];
      this.roleKey = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetEnterpriseDataKeysResponse reEncryptedRoleKey.
     * @member {Array.<Enterprise.IReEncryptedRoleKey>} reEncryptedRoleKey
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     */
    GetEnterpriseDataKeysResponse.prototype.reEncryptedRoleKey = $util.emptyArray;

    /**
     * GetEnterpriseDataKeysResponse roleKey.
     * @member {Array.<Enterprise.IRoleKey>} roleKey
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     */
    GetEnterpriseDataKeysResponse.prototype.roleKey = $util.emptyArray;

    /**
     * GetEnterpriseDataKeysResponse mspKey.
     * @member {Enterprise.IMspKey|null|undefined} mspKey
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     */
    GetEnterpriseDataKeysResponse.prototype.mspKey = null;

    /**
     * GetEnterpriseDataKeysResponse enterpriseKeys.
     * @member {Enterprise.IEnterpriseKeys|null|undefined} enterpriseKeys
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     */
    GetEnterpriseDataKeysResponse.prototype.enterpriseKeys = null;

    /**
     * GetEnterpriseDataKeysResponse treeKey.
     * @member {Enterprise.ITreeKey|null|undefined} treeKey
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     */
    GetEnterpriseDataKeysResponse.prototype.treeKey = null;

    /**
     * Creates a new GetEnterpriseDataKeysResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysResponse=} [properties] Properties to set
     * @returns {Enterprise.GetEnterpriseDataKeysResponse} GetEnterpriseDataKeysResponse instance
     */
    GetEnterpriseDataKeysResponse.create = function create(properties) {
      return new GetEnterpriseDataKeysResponse(properties);
    };

    /**
     * Encodes the specified GetEnterpriseDataKeysResponse message. Does not implicitly {@link Enterprise.GetEnterpriseDataKeysResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysResponse} message GetEnterpriseDataKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEnterpriseDataKeysResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.reEncryptedRoleKey != null && message.reEncryptedRoleKey.length)
        for (let i = 0; i < message.reEncryptedRoleKey.length; ++i)
          $root.Enterprise.ReEncryptedRoleKey.encode(
            message.reEncryptedRoleKey[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.roleKey != null && message.roleKey.length)
        for (let i = 0; i < message.roleKey.length; ++i)
          $root.Enterprise.RoleKey.encode(
            message.roleKey[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.mspKey != null && Object.hasOwnProperty.call(message, "mspKey"))
        $root.Enterprise.MspKey.encode(
          message.mspKey,
          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
        ).ldelim();
      if (message.enterpriseKeys != null && Object.hasOwnProperty.call(message, "enterpriseKeys"))
        $root.Enterprise.EnterpriseKeys.encode(
          message.enterpriseKeys,
          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
        ).ldelim();
      if (message.treeKey != null && Object.hasOwnProperty.call(message, "treeKey"))
        $root.Enterprise.TreeKey.encode(
          message.treeKey,
          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
        ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified GetEnterpriseDataKeysResponse message, length delimited. Does not implicitly {@link Enterprise.GetEnterpriseDataKeysResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Enterprise.IGetEnterpriseDataKeysResponse} message GetEnterpriseDataKeysResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEnterpriseDataKeysResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetEnterpriseDataKeysResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetEnterpriseDataKeysResponse} GetEnterpriseDataKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEnterpriseDataKeysResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetEnterpriseDataKeysResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.reEncryptedRoleKey && message.reEncryptedRoleKey.length))
              message.reEncryptedRoleKey = [];
            message.reEncryptedRoleKey.push(
              $root.Enterprise.ReEncryptedRoleKey.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            if (!(message.roleKey && message.roleKey.length)) message.roleKey = [];
            message.roleKey.push($root.Enterprise.RoleKey.decode(reader, reader.uint32()));
            break;
          }
          case 3: {
            message.mspKey = $root.Enterprise.MspKey.decode(reader, reader.uint32());
            break;
          }
          case 4: {
            message.enterpriseKeys = $root.Enterprise.EnterpriseKeys.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 5: {
            message.treeKey = $root.Enterprise.TreeKey.decode(reader, reader.uint32());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetEnterpriseDataKeysResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetEnterpriseDataKeysResponse} GetEnterpriseDataKeysResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEnterpriseDataKeysResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetEnterpriseDataKeysResponse message.
     * @function verify
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetEnterpriseDataKeysResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.reEncryptedRoleKey != null && message.hasOwnProperty("reEncryptedRoleKey")) {
        if (!Array.isArray(message.reEncryptedRoleKey)) return "reEncryptedRoleKey: array expected";
        for (let i = 0; i < message.reEncryptedRoleKey.length; ++i) {
          let error = $root.Enterprise.ReEncryptedRoleKey.verify(message.reEncryptedRoleKey[i]);
          if (error) return "reEncryptedRoleKey." + error;
        }
      }
      if (message.roleKey != null && message.hasOwnProperty("roleKey")) {
        if (!Array.isArray(message.roleKey)) return "roleKey: array expected";
        for (let i = 0; i < message.roleKey.length; ++i) {
          let error = $root.Enterprise.RoleKey.verify(message.roleKey[i]);
          if (error) return "roleKey." + error;
        }
      }
      if (message.mspKey != null && message.hasOwnProperty("mspKey")) {
        let error = $root.Enterprise.MspKey.verify(message.mspKey);
        if (error) return "mspKey." + error;
      }
      if (message.enterpriseKeys != null && message.hasOwnProperty("enterpriseKeys")) {
        let error = $root.Enterprise.EnterpriseKeys.verify(message.enterpriseKeys);
        if (error) return "enterpriseKeys." + error;
      }
      if (message.treeKey != null && message.hasOwnProperty("treeKey")) {
        let error = $root.Enterprise.TreeKey.verify(message.treeKey);
        if (error) return "treeKey." + error;
      }
      return null;
    };

    /**
     * Creates a GetEnterpriseDataKeysResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetEnterpriseDataKeysResponse} GetEnterpriseDataKeysResponse
     */
    GetEnterpriseDataKeysResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetEnterpriseDataKeysResponse) return object;
      let message = new $root.Enterprise.GetEnterpriseDataKeysResponse();
      if (object.reEncryptedRoleKey) {
        if (!Array.isArray(object.reEncryptedRoleKey))
          throw TypeError(
            ".Enterprise.GetEnterpriseDataKeysResponse.reEncryptedRoleKey: array expected",
          );
        message.reEncryptedRoleKey = [];
        for (let i = 0; i < object.reEncryptedRoleKey.length; ++i) {
          if (typeof object.reEncryptedRoleKey[i] !== "object")
            throw TypeError(
              ".Enterprise.GetEnterpriseDataKeysResponse.reEncryptedRoleKey: object expected",
            );
          message.reEncryptedRoleKey[i] = $root.Enterprise.ReEncryptedRoleKey.fromObject(
            object.reEncryptedRoleKey[i],
          );
        }
      }
      if (object.roleKey) {
        if (!Array.isArray(object.roleKey))
          throw TypeError(".Enterprise.GetEnterpriseDataKeysResponse.roleKey: array expected");
        message.roleKey = [];
        for (let i = 0; i < object.roleKey.length; ++i) {
          if (typeof object.roleKey[i] !== "object")
            throw TypeError(".Enterprise.GetEnterpriseDataKeysResponse.roleKey: object expected");
          message.roleKey[i] = $root.Enterprise.RoleKey.fromObject(object.roleKey[i]);
        }
      }
      if (object.mspKey != null) {
        if (typeof object.mspKey !== "object")
          throw TypeError(".Enterprise.GetEnterpriseDataKeysResponse.mspKey: object expected");
        message.mspKey = $root.Enterprise.MspKey.fromObject(object.mspKey);
      }
      if (object.enterpriseKeys != null) {
        if (typeof object.enterpriseKeys !== "object")
          throw TypeError(
            ".Enterprise.GetEnterpriseDataKeysResponse.enterpriseKeys: object expected",
          );
        message.enterpriseKeys = $root.Enterprise.EnterpriseKeys.fromObject(object.enterpriseKeys);
      }
      if (object.treeKey != null) {
        if (typeof object.treeKey !== "object")
          throw TypeError(".Enterprise.GetEnterpriseDataKeysResponse.treeKey: object expected");
        message.treeKey = $root.Enterprise.TreeKey.fromObject(object.treeKey);
      }
      return message;
    };

    /**
     * Creates a plain object from a GetEnterpriseDataKeysResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {Enterprise.GetEnterpriseDataKeysResponse} message GetEnterpriseDataKeysResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetEnterpriseDataKeysResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.reEncryptedRoleKey = [];
        object.roleKey = [];
      }
      if (options.defaults) {
        object.mspKey = null;
        object.enterpriseKeys = null;
        object.treeKey = null;
      }
      if (message.reEncryptedRoleKey && message.reEncryptedRoleKey.length) {
        object.reEncryptedRoleKey = [];
        for (let j = 0; j < message.reEncryptedRoleKey.length; ++j)
          object.reEncryptedRoleKey[j] = $root.Enterprise.ReEncryptedRoleKey.toObject(
            message.reEncryptedRoleKey[j],
            options,
          );
      }
      if (message.roleKey && message.roleKey.length) {
        object.roleKey = [];
        for (let j = 0; j < message.roleKey.length; ++j)
          object.roleKey[j] = $root.Enterprise.RoleKey.toObject(message.roleKey[j], options);
      }
      if (message.mspKey != null && message.hasOwnProperty("mspKey"))
        object.mspKey = $root.Enterprise.MspKey.toObject(message.mspKey, options);
      if (message.enterpriseKeys != null && message.hasOwnProperty("enterpriseKeys"))
        object.enterpriseKeys = $root.Enterprise.EnterpriseKeys.toObject(
          message.enterpriseKeys,
          options,
        );
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        object.treeKey = $root.Enterprise.TreeKey.toObject(message.treeKey, options);
      return object;
    };

    /**
     * Converts this GetEnterpriseDataKeysResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetEnterpriseDataKeysResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetEnterpriseDataKeysResponse
     * @function getTypeUrl
     * @memberof Enterprise.GetEnterpriseDataKeysResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetEnterpriseDataKeysResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetEnterpriseDataKeysResponse";
    };

    return GetEnterpriseDataKeysResponse;
  })();

  Enterprise.RoleKey = (function () {
    /**
     * Properties of a RoleKey.
     * @memberof Enterprise
     * @interface IRoleKey
     * @property {number|Long|null} [roleId] RoleKey roleId
     * @property {string|null} [encryptedKey] RoleKey encryptedKey
     * @property {Enterprise.EncryptedKeyType|null} [keyType] RoleKey keyType
     */

    /**
     * Constructs a new RoleKey.
     * @memberof Enterprise
     * @classdesc Represents a RoleKey.
     * @implements IRoleKey
     * @constructor
     * @param {Enterprise.IRoleKey=} [properties] Properties to set
     */
    function RoleKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleKey roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.RoleKey
     * @instance
     */
    RoleKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RoleKey encryptedKey.
     * @member {string} encryptedKey
     * @memberof Enterprise.RoleKey
     * @instance
     */
    RoleKey.prototype.encryptedKey = "";

    /**
     * RoleKey keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.RoleKey
     * @instance
     */
    RoleKey.prototype.keyType = 0;

    /**
     * Creates a new RoleKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Enterprise.IRoleKey=} [properties] Properties to set
     * @returns {Enterprise.RoleKey} RoleKey instance
     */
    RoleKey.create = function create(properties) {
      return new RoleKey(properties);
    };

    /**
     * Encodes the specified RoleKey message. Does not implicitly {@link Enterprise.RoleKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Enterprise.IRoleKey} message RoleKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.encryptedKey != null && Object.hasOwnProperty.call(message, "encryptedKey"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.encryptedKey);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.keyType);
      return writer;
    };

    /**
     * Encodes the specified RoleKey message, length delimited. Does not implicitly {@link Enterprise.RoleKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Enterprise.IRoleKey} message RoleKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleKey} RoleKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.encryptedKey = reader.string();
            break;
          }
          case 3: {
            message.keyType = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleKey} RoleKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleKey message.
     * @function verify
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
        if (!$util.isString(message.encryptedKey)) return "encryptedKey: string expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a RoleKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleKey} RoleKey
     */
    RoleKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleKey) return object;
      let message = new $root.Enterprise.RoleKey();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.encryptedKey != null) message.encryptedKey = String(object.encryptedKey);
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a RoleKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleKey
     * @static
     * @param {Enterprise.RoleKey} message RoleKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        object.encryptedKey = "";
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
        object.encryptedKey = message.encryptedKey;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      return object;
    };

    /**
     * Converts this RoleKey to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleKey
     * @function getTypeUrl
     * @memberof Enterprise.RoleKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleKey";
    };

    return RoleKey;
  })();

  Enterprise.MspKey = (function () {
    /**
     * Properties of a MspKey.
     * @memberof Enterprise
     * @interface IMspKey
     * @property {string|null} [encryptedMspTreeKey] MspKey encryptedMspTreeKey
     * @property {Enterprise.EncryptedKeyType|null} [encryptedMspTreeKeyType] MspKey encryptedMspTreeKeyType
     */

    /**
     * Constructs a new MspKey.
     * @memberof Enterprise
     * @classdesc Represents a MspKey.
     * @implements IMspKey
     * @constructor
     * @param {Enterprise.IMspKey=} [properties] Properties to set
     */
    function MspKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * MspKey encryptedMspTreeKey.
     * @member {string} encryptedMspTreeKey
     * @memberof Enterprise.MspKey
     * @instance
     */
    MspKey.prototype.encryptedMspTreeKey = "";

    /**
     * MspKey encryptedMspTreeKeyType.
     * @member {Enterprise.EncryptedKeyType} encryptedMspTreeKeyType
     * @memberof Enterprise.MspKey
     * @instance
     */
    MspKey.prototype.encryptedMspTreeKeyType = 0;

    /**
     * Creates a new MspKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.MspKey
     * @static
     * @param {Enterprise.IMspKey=} [properties] Properties to set
     * @returns {Enterprise.MspKey} MspKey instance
     */
    MspKey.create = function create(properties) {
      return new MspKey(properties);
    };

    /**
     * Encodes the specified MspKey message. Does not implicitly {@link Enterprise.MspKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.MspKey
     * @static
     * @param {Enterprise.IMspKey} message MspKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MspKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.encryptedMspTreeKey != null &&
        Object.hasOwnProperty.call(message, "encryptedMspTreeKey")
      )
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.encryptedMspTreeKey);
      if (
        message.encryptedMspTreeKeyType != null &&
        Object.hasOwnProperty.call(message, "encryptedMspTreeKeyType")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.encryptedMspTreeKeyType);
      return writer;
    };

    /**
     * Encodes the specified MspKey message, length delimited. Does not implicitly {@link Enterprise.MspKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.MspKey
     * @static
     * @param {Enterprise.IMspKey} message MspKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MspKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MspKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.MspKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.MspKey} MspKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MspKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.MspKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.encryptedMspTreeKey = reader.string();
            break;
          }
          case 2: {
            message.encryptedMspTreeKeyType = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a MspKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.MspKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.MspKey} MspKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MspKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MspKey message.
     * @function verify
     * @memberof Enterprise.MspKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MspKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.encryptedMspTreeKey != null && message.hasOwnProperty("encryptedMspTreeKey"))
        if (!$util.isString(message.encryptedMspTreeKey))
          return "encryptedMspTreeKey: string expected";
      if (
        message.encryptedMspTreeKeyType != null &&
        message.hasOwnProperty("encryptedMspTreeKeyType")
      )
        switch (message.encryptedMspTreeKeyType) {
          default:
            return "encryptedMspTreeKeyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a MspKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.MspKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.MspKey} MspKey
     */
    MspKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.MspKey) return object;
      let message = new $root.Enterprise.MspKey();
      if (object.encryptedMspTreeKey != null)
        message.encryptedMspTreeKey = String(object.encryptedMspTreeKey);
      switch (object.encryptedMspTreeKeyType) {
        default:
          if (typeof object.encryptedMspTreeKeyType === "number") {
            message.encryptedMspTreeKeyType = object.encryptedMspTreeKeyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.encryptedMspTreeKeyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.encryptedMspTreeKeyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.encryptedMspTreeKeyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.encryptedMspTreeKeyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.encryptedMspTreeKeyType = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a MspKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.MspKey
     * @static
     * @param {Enterprise.MspKey} message MspKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MspKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.encryptedMspTreeKey = "";
        object.encryptedMspTreeKeyType = options.enums === String ? "KT_NO_KEY" : 0;
      }
      if (message.encryptedMspTreeKey != null && message.hasOwnProperty("encryptedMspTreeKey"))
        object.encryptedMspTreeKey = message.encryptedMspTreeKey;
      if (
        message.encryptedMspTreeKeyType != null &&
        message.hasOwnProperty("encryptedMspTreeKeyType")
      )
        object.encryptedMspTreeKeyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.encryptedMspTreeKeyType] === undefined
              ? message.encryptedMspTreeKeyType
              : $root.Enterprise.EncryptedKeyType[message.encryptedMspTreeKeyType]
            : message.encryptedMspTreeKeyType;
      return object;
    };

    /**
     * Converts this MspKey to JSON.
     * @function toJSON
     * @memberof Enterprise.MspKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MspKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MspKey
     * @function getTypeUrl
     * @memberof Enterprise.MspKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MspKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.MspKey";
    };

    return MspKey;
  })();

  Enterprise.EnterpriseKeys = (function () {
    /**
     * Properties of an EnterpriseKeys.
     * @memberof Enterprise
     * @interface IEnterpriseKeys
     * @property {Uint8Array|null} [rsaPublicKey] EnterpriseKeys rsaPublicKey
     * @property {Uint8Array|null} [rsaEncryptedPrivateKey] EnterpriseKeys rsaEncryptedPrivateKey
     * @property {Uint8Array|null} [eccPublicKey] EnterpriseKeys eccPublicKey
     * @property {Uint8Array|null} [eccEncryptedPrivateKey] EnterpriseKeys eccEncryptedPrivateKey
     */

    /**
     * Constructs a new EnterpriseKeys.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseKeys.
     * @implements IEnterpriseKeys
     * @constructor
     * @param {Enterprise.IEnterpriseKeys=} [properties] Properties to set
     */
    function EnterpriseKeys(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseKeys rsaPublicKey.
     * @member {Uint8Array} rsaPublicKey
     * @memberof Enterprise.EnterpriseKeys
     * @instance
     */
    EnterpriseKeys.prototype.rsaPublicKey = $util.newBuffer([]);

    /**
     * EnterpriseKeys rsaEncryptedPrivateKey.
     * @member {Uint8Array} rsaEncryptedPrivateKey
     * @memberof Enterprise.EnterpriseKeys
     * @instance
     */
    EnterpriseKeys.prototype.rsaEncryptedPrivateKey = $util.newBuffer([]);

    /**
     * EnterpriseKeys eccPublicKey.
     * @member {Uint8Array} eccPublicKey
     * @memberof Enterprise.EnterpriseKeys
     * @instance
     */
    EnterpriseKeys.prototype.eccPublicKey = $util.newBuffer([]);

    /**
     * EnterpriseKeys eccEncryptedPrivateKey.
     * @member {Uint8Array} eccEncryptedPrivateKey
     * @memberof Enterprise.EnterpriseKeys
     * @instance
     */
    EnterpriseKeys.prototype.eccEncryptedPrivateKey = $util.newBuffer([]);

    /**
     * Creates a new EnterpriseKeys instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Enterprise.IEnterpriseKeys=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseKeys} EnterpriseKeys instance
     */
    EnterpriseKeys.create = function create(properties) {
      return new EnterpriseKeys(properties);
    };

    /**
     * Encodes the specified EnterpriseKeys message. Does not implicitly {@link Enterprise.EnterpriseKeys.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Enterprise.IEnterpriseKeys} message EnterpriseKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseKeys.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.rsaPublicKey != null && Object.hasOwnProperty.call(message, "rsaPublicKey"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.rsaPublicKey);
      if (
        message.rsaEncryptedPrivateKey != null &&
        Object.hasOwnProperty.call(message, "rsaEncryptedPrivateKey")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.rsaEncryptedPrivateKey);
      if (message.eccPublicKey != null && Object.hasOwnProperty.call(message, "eccPublicKey"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.eccPublicKey);
      if (
        message.eccEncryptedPrivateKey != null &&
        Object.hasOwnProperty.call(message, "eccEncryptedPrivateKey")
      )
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.eccEncryptedPrivateKey);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseKeys message, length delimited. Does not implicitly {@link Enterprise.EnterpriseKeys.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Enterprise.IEnterpriseKeys} message EnterpriseKeys message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseKeys.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseKeys message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseKeys} EnterpriseKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseKeys.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseKeys();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.rsaPublicKey = reader.bytes();
            break;
          }
          case 2: {
            message.rsaEncryptedPrivateKey = reader.bytes();
            break;
          }
          case 3: {
            message.eccPublicKey = reader.bytes();
            break;
          }
          case 4: {
            message.eccEncryptedPrivateKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseKeys message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseKeys} EnterpriseKeys
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseKeys.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseKeys message.
     * @function verify
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseKeys.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
        if (
          !(
            (message.rsaPublicKey && typeof message.rsaPublicKey.length === "number") ||
            $util.isString(message.rsaPublicKey)
          )
        )
          return "rsaPublicKey: buffer expected";
      if (
        message.rsaEncryptedPrivateKey != null &&
        message.hasOwnProperty("rsaEncryptedPrivateKey")
      )
        if (
          !(
            (message.rsaEncryptedPrivateKey &&
              typeof message.rsaEncryptedPrivateKey.length === "number") ||
            $util.isString(message.rsaEncryptedPrivateKey)
          )
        )
          return "rsaEncryptedPrivateKey: buffer expected";
      if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
        if (
          !(
            (message.eccPublicKey && typeof message.eccPublicKey.length === "number") ||
            $util.isString(message.eccPublicKey)
          )
        )
          return "eccPublicKey: buffer expected";
      if (
        message.eccEncryptedPrivateKey != null &&
        message.hasOwnProperty("eccEncryptedPrivateKey")
      )
        if (
          !(
            (message.eccEncryptedPrivateKey &&
              typeof message.eccEncryptedPrivateKey.length === "number") ||
            $util.isString(message.eccEncryptedPrivateKey)
          )
        )
          return "eccEncryptedPrivateKey: buffer expected";
      return null;
    };

    /**
     * Creates an EnterpriseKeys message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseKeys} EnterpriseKeys
     */
    EnterpriseKeys.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseKeys) return object;
      let message = new $root.Enterprise.EnterpriseKeys();
      if (object.rsaPublicKey != null)
        if (typeof object.rsaPublicKey === "string")
          $util.base64.decode(
            object.rsaPublicKey,
            (message.rsaPublicKey = $util.newBuffer($util.base64.length(object.rsaPublicKey))),
            0,
          );
        else if (object.rsaPublicKey.length >= 0) message.rsaPublicKey = object.rsaPublicKey;
      if (object.rsaEncryptedPrivateKey != null)
        if (typeof object.rsaEncryptedPrivateKey === "string")
          $util.base64.decode(
            object.rsaEncryptedPrivateKey,
            (message.rsaEncryptedPrivateKey = $util.newBuffer(
              $util.base64.length(object.rsaEncryptedPrivateKey),
            )),
            0,
          );
        else if (object.rsaEncryptedPrivateKey.length >= 0)
          message.rsaEncryptedPrivateKey = object.rsaEncryptedPrivateKey;
      if (object.eccPublicKey != null)
        if (typeof object.eccPublicKey === "string")
          $util.base64.decode(
            object.eccPublicKey,
            (message.eccPublicKey = $util.newBuffer($util.base64.length(object.eccPublicKey))),
            0,
          );
        else if (object.eccPublicKey.length >= 0) message.eccPublicKey = object.eccPublicKey;
      if (object.eccEncryptedPrivateKey != null)
        if (typeof object.eccEncryptedPrivateKey === "string")
          $util.base64.decode(
            object.eccEncryptedPrivateKey,
            (message.eccEncryptedPrivateKey = $util.newBuffer(
              $util.base64.length(object.eccEncryptedPrivateKey),
            )),
            0,
          );
        else if (object.eccEncryptedPrivateKey.length >= 0)
          message.eccEncryptedPrivateKey = object.eccEncryptedPrivateKey;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseKeys message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {Enterprise.EnterpriseKeys} message EnterpriseKeys
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseKeys.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.rsaPublicKey = "";
        else {
          object.rsaPublicKey = [];
          if (options.bytes !== Array) object.rsaPublicKey = $util.newBuffer(object.rsaPublicKey);
        }
        if (options.bytes === String) object.rsaEncryptedPrivateKey = "";
        else {
          object.rsaEncryptedPrivateKey = [];
          if (options.bytes !== Array)
            object.rsaEncryptedPrivateKey = $util.newBuffer(object.rsaEncryptedPrivateKey);
        }
        if (options.bytes === String) object.eccPublicKey = "";
        else {
          object.eccPublicKey = [];
          if (options.bytes !== Array) object.eccPublicKey = $util.newBuffer(object.eccPublicKey);
        }
        if (options.bytes === String) object.eccEncryptedPrivateKey = "";
        else {
          object.eccEncryptedPrivateKey = [];
          if (options.bytes !== Array)
            object.eccEncryptedPrivateKey = $util.newBuffer(object.eccEncryptedPrivateKey);
        }
      }
      if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
        object.rsaPublicKey =
          options.bytes === String
            ? $util.base64.encode(message.rsaPublicKey, 0, message.rsaPublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rsaPublicKey)
              : message.rsaPublicKey;
      if (
        message.rsaEncryptedPrivateKey != null &&
        message.hasOwnProperty("rsaEncryptedPrivateKey")
      )
        object.rsaEncryptedPrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.rsaEncryptedPrivateKey,
                0,
                message.rsaEncryptedPrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rsaEncryptedPrivateKey)
              : message.rsaEncryptedPrivateKey;
      if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
        object.eccPublicKey =
          options.bytes === String
            ? $util.base64.encode(message.eccPublicKey, 0, message.eccPublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.eccPublicKey)
              : message.eccPublicKey;
      if (
        message.eccEncryptedPrivateKey != null &&
        message.hasOwnProperty("eccEncryptedPrivateKey")
      )
        object.eccEncryptedPrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.eccEncryptedPrivateKey,
                0,
                message.eccEncryptedPrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.eccEncryptedPrivateKey)
              : message.eccEncryptedPrivateKey;
      return object;
    };

    /**
     * Converts this EnterpriseKeys to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseKeys
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseKeys.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseKeys
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseKeys
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseKeys";
    };

    return EnterpriseKeys;
  })();

  Enterprise.TreeKey = (function () {
    /**
     * Properties of a TreeKey.
     * @memberof Enterprise
     * @interface ITreeKey
     * @property {string|null} [treeKey] TreeKey treeKey
     * @property {Enterprise.BackupKeyType|null} [keyTypeId] TreeKey keyTypeId
     */

    /**
     * Constructs a new TreeKey.
     * @memberof Enterprise
     * @classdesc Represents a TreeKey.
     * @implements ITreeKey
     * @constructor
     * @param {Enterprise.ITreeKey=} [properties] Properties to set
     */
    function TreeKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TreeKey treeKey.
     * @member {string} treeKey
     * @memberof Enterprise.TreeKey
     * @instance
     */
    TreeKey.prototype.treeKey = "";

    /**
     * TreeKey keyTypeId.
     * @member {Enterprise.BackupKeyType} keyTypeId
     * @memberof Enterprise.TreeKey
     * @instance
     */
    TreeKey.prototype.keyTypeId = 0;

    /**
     * Creates a new TreeKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Enterprise.ITreeKey=} [properties] Properties to set
     * @returns {Enterprise.TreeKey} TreeKey instance
     */
    TreeKey.create = function create(properties) {
      return new TreeKey(properties);
    };

    /**
     * Encodes the specified TreeKey message. Does not implicitly {@link Enterprise.TreeKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Enterprise.ITreeKey} message TreeKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TreeKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.treeKey != null && Object.hasOwnProperty.call(message, "treeKey"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.treeKey);
      if (message.keyTypeId != null && Object.hasOwnProperty.call(message, "keyTypeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.keyTypeId);
      return writer;
    };

    /**
     * Encodes the specified TreeKey message, length delimited. Does not implicitly {@link Enterprise.TreeKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Enterprise.ITreeKey} message TreeKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TreeKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TreeKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TreeKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TreeKey} TreeKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TreeKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TreeKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.treeKey = reader.string();
            break;
          }
          case 2: {
            message.keyTypeId = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TreeKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TreeKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TreeKey} TreeKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TreeKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TreeKey message.
     * @function verify
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TreeKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        if (!$util.isString(message.treeKey)) return "treeKey: string expected";
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        switch (message.keyTypeId) {
          default:
            return "keyTypeId: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a TreeKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TreeKey} TreeKey
     */
    TreeKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TreeKey) return object;
      let message = new $root.Enterprise.TreeKey();
      if (object.treeKey != null) message.treeKey = String(object.treeKey);
      switch (object.keyTypeId) {
        default:
          if (typeof object.keyTypeId === "number") {
            message.keyTypeId = object.keyTypeId;
            break;
          }
          break;
        case "NO_KEY":
        case 0:
          message.keyTypeId = 0;
          break;
        case "ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyTypeId = 1;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyTypeId = 2;
          break;
        case "ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyTypeId = 3;
          break;
        case "ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyTypeId = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a TreeKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TreeKey
     * @static
     * @param {Enterprise.TreeKey} message TreeKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TreeKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.treeKey = "";
        object.keyTypeId = options.enums === String ? "NO_KEY" : 0;
      }
      if (message.treeKey != null && message.hasOwnProperty("treeKey"))
        object.treeKey = message.treeKey;
      if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
        object.keyTypeId =
          options.enums === String
            ? $root.Enterprise.BackupKeyType[message.keyTypeId] === undefined
              ? message.keyTypeId
              : $root.Enterprise.BackupKeyType[message.keyTypeId]
            : message.keyTypeId;
      return object;
    };

    /**
     * Converts this TreeKey to JSON.
     * @function toJSON
     * @memberof Enterprise.TreeKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TreeKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TreeKey
     * @function getTypeUrl
     * @memberof Enterprise.TreeKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TreeKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TreeKey";
    };

    return TreeKey;
  })();

  Enterprise.SharedRecordResponse = (function () {
    /**
     * Properties of a SharedRecordResponse.
     * @memberof Enterprise
     * @interface ISharedRecordResponse
     * @property {Array.<Enterprise.ISharedRecordEvent>|null} [events] SharedRecordResponse events
     */

    /**
     * Constructs a new SharedRecordResponse.
     * @memberof Enterprise
     * @classdesc Represents a SharedRecordResponse.
     * @implements ISharedRecordResponse
     * @constructor
     * @param {Enterprise.ISharedRecordResponse=} [properties] Properties to set
     */
    function SharedRecordResponse(properties) {
      this.events = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SharedRecordResponse events.
     * @member {Array.<Enterprise.ISharedRecordEvent>} events
     * @memberof Enterprise.SharedRecordResponse
     * @instance
     */
    SharedRecordResponse.prototype.events = $util.emptyArray;

    /**
     * Creates a new SharedRecordResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Enterprise.ISharedRecordResponse=} [properties] Properties to set
     * @returns {Enterprise.SharedRecordResponse} SharedRecordResponse instance
     */
    SharedRecordResponse.create = function create(properties) {
      return new SharedRecordResponse(properties);
    };

    /**
     * Encodes the specified SharedRecordResponse message. Does not implicitly {@link Enterprise.SharedRecordResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Enterprise.ISharedRecordResponse} message SharedRecordResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedRecordResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.events != null && message.events.length)
        for (let i = 0; i < message.events.length; ++i)
          $root.Enterprise.SharedRecordEvent.encode(
            message.events[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified SharedRecordResponse message, length delimited. Does not implicitly {@link Enterprise.SharedRecordResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Enterprise.ISharedRecordResponse} message SharedRecordResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SharedRecordResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SharedRecordResponse} SharedRecordResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedRecordResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SharedRecordResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.events && message.events.length)) message.events = [];
            message.events.push($root.Enterprise.SharedRecordEvent.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SharedRecordResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SharedRecordResponse} SharedRecordResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedRecordResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SharedRecordResponse message.
     * @function verify
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SharedRecordResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.events != null && message.hasOwnProperty("events")) {
        if (!Array.isArray(message.events)) return "events: array expected";
        for (let i = 0; i < message.events.length; ++i) {
          let error = $root.Enterprise.SharedRecordEvent.verify(message.events[i]);
          if (error) return "events." + error;
        }
      }
      return null;
    };

    /**
     * Creates a SharedRecordResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SharedRecordResponse} SharedRecordResponse
     */
    SharedRecordResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SharedRecordResponse) return object;
      let message = new $root.Enterprise.SharedRecordResponse();
      if (object.events) {
        if (!Array.isArray(object.events))
          throw TypeError(".Enterprise.SharedRecordResponse.events: array expected");
        message.events = [];
        for (let i = 0; i < object.events.length; ++i) {
          if (typeof object.events[i] !== "object")
            throw TypeError(".Enterprise.SharedRecordResponse.events: object expected");
          message.events[i] = $root.Enterprise.SharedRecordEvent.fromObject(object.events[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a SharedRecordResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {Enterprise.SharedRecordResponse} message SharedRecordResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SharedRecordResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.events = [];
      if (message.events && message.events.length) {
        object.events = [];
        for (let j = 0; j < message.events.length; ++j)
          object.events[j] = $root.Enterprise.SharedRecordEvent.toObject(
            message.events[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this SharedRecordResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.SharedRecordResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SharedRecordResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SharedRecordResponse
     * @function getTypeUrl
     * @memberof Enterprise.SharedRecordResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SharedRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SharedRecordResponse";
    };

    return SharedRecordResponse;
  })();

  Enterprise.SharedRecordEvent = (function () {
    /**
     * Properties of a SharedRecordEvent.
     * @memberof Enterprise
     * @interface ISharedRecordEvent
     * @property {Uint8Array|null} [recordUid] SharedRecordEvent recordUid
     * @property {string|null} [userName] SharedRecordEvent userName
     * @property {boolean|null} [canEdit] SharedRecordEvent canEdit
     * @property {boolean|null} [canReshare] SharedRecordEvent canReshare
     * @property {number|null} [shareFrom] SharedRecordEvent shareFrom
     */

    /**
     * Constructs a new SharedRecordEvent.
     * @memberof Enterprise
     * @classdesc Represents a SharedRecordEvent.
     * @implements ISharedRecordEvent
     * @constructor
     * @param {Enterprise.ISharedRecordEvent=} [properties] Properties to set
     */
    function SharedRecordEvent(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SharedRecordEvent recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     */
    SharedRecordEvent.prototype.recordUid = $util.newBuffer([]);

    /**
     * SharedRecordEvent userName.
     * @member {string} userName
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     */
    SharedRecordEvent.prototype.userName = "";

    /**
     * SharedRecordEvent canEdit.
     * @member {boolean} canEdit
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     */
    SharedRecordEvent.prototype.canEdit = false;

    /**
     * SharedRecordEvent canReshare.
     * @member {boolean} canReshare
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     */
    SharedRecordEvent.prototype.canReshare = false;

    /**
     * SharedRecordEvent shareFrom.
     * @member {number} shareFrom
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     */
    SharedRecordEvent.prototype.shareFrom = 0;

    /**
     * Creates a new SharedRecordEvent instance using the specified properties.
     * @function create
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Enterprise.ISharedRecordEvent=} [properties] Properties to set
     * @returns {Enterprise.SharedRecordEvent} SharedRecordEvent instance
     */
    SharedRecordEvent.create = function create(properties) {
      return new SharedRecordEvent(properties);
    };

    /**
     * Encodes the specified SharedRecordEvent message. Does not implicitly {@link Enterprise.SharedRecordEvent.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Enterprise.ISharedRecordEvent} message SharedRecordEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedRecordEvent.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.recordUid);
      if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.userName);
      if (message.canEdit != null && Object.hasOwnProperty.call(message, "canEdit"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.canEdit);
      if (message.canReshare != null && Object.hasOwnProperty.call(message, "canReshare"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.canReshare);
      if (message.shareFrom != null && Object.hasOwnProperty.call(message, "shareFrom"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.shareFrom);
      return writer;
    };

    /**
     * Encodes the specified SharedRecordEvent message, length delimited. Does not implicitly {@link Enterprise.SharedRecordEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Enterprise.ISharedRecordEvent} message SharedRecordEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedRecordEvent.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SharedRecordEvent message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SharedRecordEvent} SharedRecordEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedRecordEvent.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SharedRecordEvent();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.recordUid = reader.bytes();
            break;
          }
          case 2: {
            message.userName = reader.string();
            break;
          }
          case 3: {
            message.canEdit = reader.bool();
            break;
          }
          case 4: {
            message.canReshare = reader.bool();
            break;
          }
          case 5: {
            message.shareFrom = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SharedRecordEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SharedRecordEvent} SharedRecordEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedRecordEvent.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SharedRecordEvent message.
     * @function verify
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SharedRecordEvent.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.userName != null && message.hasOwnProperty("userName"))
        if (!$util.isString(message.userName)) return "userName: string expected";
      if (message.canEdit != null && message.hasOwnProperty("canEdit"))
        if (typeof message.canEdit !== "boolean") return "canEdit: boolean expected";
      if (message.canReshare != null && message.hasOwnProperty("canReshare"))
        if (typeof message.canReshare !== "boolean") return "canReshare: boolean expected";
      if (message.shareFrom != null && message.hasOwnProperty("shareFrom"))
        if (!$util.isInteger(message.shareFrom)) return "shareFrom: integer expected";
      return null;
    };

    /**
     * Creates a SharedRecordEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SharedRecordEvent} SharedRecordEvent
     */
    SharedRecordEvent.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SharedRecordEvent) return object;
      let message = new $root.Enterprise.SharedRecordEvent();
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.userName != null) message.userName = String(object.userName);
      if (object.canEdit != null) message.canEdit = Boolean(object.canEdit);
      if (object.canReshare != null) message.canReshare = Boolean(object.canReshare);
      if (object.shareFrom != null) message.shareFrom = object.shareFrom | 0;
      return message;
    };

    /**
     * Creates a plain object from a SharedRecordEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {Enterprise.SharedRecordEvent} message SharedRecordEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SharedRecordEvent.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        object.userName = "";
        object.canEdit = false;
        object.canReshare = false;
        object.shareFrom = 0;
      }
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.userName != null && message.hasOwnProperty("userName"))
        object.userName = message.userName;
      if (message.canEdit != null && message.hasOwnProperty("canEdit"))
        object.canEdit = message.canEdit;
      if (message.canReshare != null && message.hasOwnProperty("canReshare"))
        object.canReshare = message.canReshare;
      if (message.shareFrom != null && message.hasOwnProperty("shareFrom"))
        object.shareFrom = message.shareFrom;
      return object;
    };

    /**
     * Converts this SharedRecordEvent to JSON.
     * @function toJSON
     * @memberof Enterprise.SharedRecordEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SharedRecordEvent.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SharedRecordEvent
     * @function getTypeUrl
     * @memberof Enterprise.SharedRecordEvent
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SharedRecordEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SharedRecordEvent";
    };

    return SharedRecordEvent;
  })();

  Enterprise.SetRestrictVisibilityRequest = (function () {
    /**
     * Properties of a SetRestrictVisibilityRequest.
     * @memberof Enterprise
     * @interface ISetRestrictVisibilityRequest
     * @property {number|Long|null} [nodeId] SetRestrictVisibilityRequest nodeId
     */

    /**
     * Constructs a new SetRestrictVisibilityRequest.
     * @memberof Enterprise
     * @classdesc Represents a SetRestrictVisibilityRequest.
     * @implements ISetRestrictVisibilityRequest
     * @constructor
     * @param {Enterprise.ISetRestrictVisibilityRequest=} [properties] Properties to set
     */
    function SetRestrictVisibilityRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetRestrictVisibilityRequest nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @instance
     */
    SetRestrictVisibilityRequest.prototype.nodeId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * Creates a new SetRestrictVisibilityRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Enterprise.ISetRestrictVisibilityRequest=} [properties] Properties to set
     * @returns {Enterprise.SetRestrictVisibilityRequest} SetRestrictVisibilityRequest instance
     */
    SetRestrictVisibilityRequest.create = function create(properties) {
      return new SetRestrictVisibilityRequest(properties);
    };

    /**
     * Encodes the specified SetRestrictVisibilityRequest message. Does not implicitly {@link Enterprise.SetRestrictVisibilityRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Enterprise.ISetRestrictVisibilityRequest} message SetRestrictVisibilityRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetRestrictVisibilityRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.nodeId);
      return writer;
    };

    /**
     * Encodes the specified SetRestrictVisibilityRequest message, length delimited. Does not implicitly {@link Enterprise.SetRestrictVisibilityRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Enterprise.ISetRestrictVisibilityRequest} message SetRestrictVisibilityRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetRestrictVisibilityRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetRestrictVisibilityRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SetRestrictVisibilityRequest} SetRestrictVisibilityRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetRestrictVisibilityRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SetRestrictVisibilityRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.nodeId = reader.int64();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SetRestrictVisibilityRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SetRestrictVisibilityRequest} SetRestrictVisibilityRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetRestrictVisibilityRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetRestrictVisibilityRequest message.
     * @function verify
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetRestrictVisibilityRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      return null;
    };

    /**
     * Creates a SetRestrictVisibilityRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SetRestrictVisibilityRequest} SetRestrictVisibilityRequest
     */
    SetRestrictVisibilityRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SetRestrictVisibilityRequest) return object;
      let message = new $root.Enterprise.SetRestrictVisibilityRequest();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      return message;
    };

    /**
     * Creates a plain object from a SetRestrictVisibilityRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {Enterprise.SetRestrictVisibilityRequest} message SetRestrictVisibilityRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetRestrictVisibilityRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      return object;
    };

    /**
     * Converts this SetRestrictVisibilityRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetRestrictVisibilityRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SetRestrictVisibilityRequest
     * @function getTypeUrl
     * @memberof Enterprise.SetRestrictVisibilityRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SetRestrictVisibilityRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SetRestrictVisibilityRequest";
    };

    return SetRestrictVisibilityRequest;
  })();

  Enterprise.UserAddRequest = (function () {
    /**
     * Properties of a UserAddRequest.
     * @memberof Enterprise
     * @interface IUserAddRequest
     * @property {number|Long|null} [enterpriseUserId] UserAddRequest enterpriseUserId
     * @property {number|Long|null} [nodeId] UserAddRequest nodeId
     * @property {Uint8Array|null} [encryptedData] UserAddRequest encryptedData
     * @property {Enterprise.EncryptedKeyType|null} [keyType] UserAddRequest keyType
     * @property {string|null} [fullName] UserAddRequest fullName
     * @property {string|null} [jobTitle] UserAddRequest jobTitle
     * @property {string|null} [email] UserAddRequest email
     * @property {boolean|null} [suppressEmailInvite] UserAddRequest suppressEmailInvite
     */

    /**
     * Constructs a new UserAddRequest.
     * @memberof Enterprise
     * @classdesc Represents a UserAddRequest.
     * @implements IUserAddRequest
     * @constructor
     * @param {Enterprise.IUserAddRequest=} [properties] Properties to set
     */
    function UserAddRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserAddRequest enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserAddRequest nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserAddRequest encryptedData.
     * @member {Uint8Array} encryptedData
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.encryptedData = $util.newBuffer([]);

    /**
     * UserAddRequest keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.keyType = 0;

    /**
     * UserAddRequest fullName.
     * @member {string} fullName
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.fullName = "";

    /**
     * UserAddRequest jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.jobTitle = "";

    /**
     * UserAddRequest email.
     * @member {string} email
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.email = "";

    /**
     * UserAddRequest suppressEmailInvite.
     * @member {boolean} suppressEmailInvite
     * @memberof Enterprise.UserAddRequest
     * @instance
     */
    UserAddRequest.prototype.suppressEmailInvite = false;

    /**
     * Creates a new UserAddRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Enterprise.IUserAddRequest=} [properties] Properties to set
     * @returns {Enterprise.UserAddRequest} UserAddRequest instance
     */
    UserAddRequest.create = function create(properties) {
      return new UserAddRequest(properties);
    };

    /**
     * Encodes the specified UserAddRequest message. Does not implicitly {@link Enterprise.UserAddRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Enterprise.IUserAddRequest} message UserAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserAddRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.keyType);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.jobTitle);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.email);
      if (
        message.suppressEmailInvite != null &&
        Object.hasOwnProperty.call(message, "suppressEmailInvite")
      )
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.suppressEmailInvite);
      return writer;
    };

    /**
     * Encodes the specified UserAddRequest message, length delimited. Does not implicitly {@link Enterprise.UserAddRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Enterprise.IUserAddRequest} message UserAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserAddRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserAddRequest} UserAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserAddRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserAddRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedData = reader.bytes();
            break;
          }
          case 4: {
            message.keyType = reader.int32();
            break;
          }
          case 5: {
            message.fullName = reader.string();
            break;
          }
          case 6: {
            message.jobTitle = reader.string();
            break;
          }
          case 7: {
            message.email = reader.string();
            break;
          }
          case 8: {
            message.suppressEmailInvite = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserAddRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserAddRequest} UserAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserAddRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserAddRequest message.
     * @function verify
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserAddRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (
          !(
            (message.encryptedData && typeof message.encryptedData.length === "number") ||
            $util.isString(message.encryptedData)
          )
        )
          return "encryptedData: buffer expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.suppressEmailInvite != null && message.hasOwnProperty("suppressEmailInvite"))
        if (typeof message.suppressEmailInvite !== "boolean")
          return "suppressEmailInvite: boolean expected";
      return null;
    };

    /**
     * Creates a UserAddRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserAddRequest} UserAddRequest
     */
    UserAddRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserAddRequest) return object;
      let message = new $root.Enterprise.UserAddRequest();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null)
        if (typeof object.encryptedData === "string")
          $util.base64.decode(
            object.encryptedData,
            (message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData))),
            0,
          );
        else if (object.encryptedData.length >= 0) message.encryptedData = object.encryptedData;
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.email != null) message.email = String(object.email);
      if (object.suppressEmailInvite != null)
        message.suppressEmailInvite = Boolean(object.suppressEmailInvite);
      return message;
    };

    /**
     * Creates a plain object from a UserAddRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {Enterprise.UserAddRequest} message UserAddRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserAddRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedData = "";
        else {
          object.encryptedData = [];
          if (options.bytes !== Array) object.encryptedData = $util.newBuffer(object.encryptedData);
        }
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
        object.fullName = "";
        object.jobTitle = "";
        object.email = "";
        object.suppressEmailInvite = false;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData =
          options.bytes === String
            ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedData)
              : message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.suppressEmailInvite != null && message.hasOwnProperty("suppressEmailInvite"))
        object.suppressEmailInvite = message.suppressEmailInvite;
      return object;
    };

    /**
     * Converts this UserAddRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.UserAddRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserAddRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserAddRequest
     * @function getTypeUrl
     * @memberof Enterprise.UserAddRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserAddRequest";
    };

    return UserAddRequest;
  })();

  Enterprise.UserUpdateRequest = (function () {
    /**
     * Properties of a UserUpdateRequest.
     * @memberof Enterprise
     * @interface IUserUpdateRequest
     * @property {Array.<Enterprise.IUserUpdate>|null} [users] UserUpdateRequest users
     */

    /**
     * Constructs a new UserUpdateRequest.
     * @memberof Enterprise
     * @classdesc Represents a UserUpdateRequest.
     * @implements IUserUpdateRequest
     * @constructor
     * @param {Enterprise.IUserUpdateRequest=} [properties] Properties to set
     */
    function UserUpdateRequest(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserUpdateRequest users.
     * @member {Array.<Enterprise.IUserUpdate>} users
     * @memberof Enterprise.UserUpdateRequest
     * @instance
     */
    UserUpdateRequest.prototype.users = $util.emptyArray;

    /**
     * Creates a new UserUpdateRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Enterprise.IUserUpdateRequest=} [properties] Properties to set
     * @returns {Enterprise.UserUpdateRequest} UserUpdateRequest instance
     */
    UserUpdateRequest.create = function create(properties) {
      return new UserUpdateRequest(properties);
    };

    /**
     * Encodes the specified UserUpdateRequest message. Does not implicitly {@link Enterprise.UserUpdateRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Enterprise.IUserUpdateRequest} message UserUpdateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.UserUpdate.encode(
            message.users[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified UserUpdateRequest message, length delimited. Does not implicitly {@link Enterprise.UserUpdateRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Enterprise.IUserUpdateRequest} message UserUpdateRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserUpdateRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserUpdateRequest} UserUpdateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserUpdateRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push($root.Enterprise.UserUpdate.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserUpdateRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserUpdateRequest} UserUpdateRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserUpdateRequest message.
     * @function verify
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserUpdateRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.UserUpdate.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      return null;
    };

    /**
     * Creates a UserUpdateRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserUpdateRequest} UserUpdateRequest
     */
    UserUpdateRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserUpdateRequest) return object;
      let message = new $root.Enterprise.UserUpdateRequest();
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.UserUpdateRequest.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.UserUpdateRequest.users: object expected");
          message.users[i] = $root.Enterprise.UserUpdate.fromObject(object.users[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a UserUpdateRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {Enterprise.UserUpdateRequest} message UserUpdateRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserUpdateRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.UserUpdate.toObject(message.users[j], options);
      }
      return object;
    };

    /**
     * Converts this UserUpdateRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.UserUpdateRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserUpdateRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserUpdateRequest
     * @function getTypeUrl
     * @memberof Enterprise.UserUpdateRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserUpdateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserUpdateRequest";
    };

    return UserUpdateRequest;
  })();

  Enterprise.UserUpdate = (function () {
    /**
     * Properties of a UserUpdate.
     * @memberof Enterprise
     * @interface IUserUpdate
     * @property {number|Long|null} [enterpriseUserId] UserUpdate enterpriseUserId
     * @property {number|Long|null} [nodeId] UserUpdate nodeId
     * @property {Uint8Array|null} [encryptedData] UserUpdate encryptedData
     * @property {Enterprise.EncryptedKeyType|null} [keyType] UserUpdate keyType
     * @property {string|null} [fullName] UserUpdate fullName
     * @property {string|null} [jobTitle] UserUpdate jobTitle
     * @property {string|null} [email] UserUpdate email
     */

    /**
     * Constructs a new UserUpdate.
     * @memberof Enterprise
     * @classdesc Represents a UserUpdate.
     * @implements IUserUpdate
     * @constructor
     * @param {Enterprise.IUserUpdate=} [properties] Properties to set
     */
    function UserUpdate(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserUpdate enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserUpdate nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserUpdate encryptedData.
     * @member {Uint8Array} encryptedData
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.encryptedData = $util.newBuffer([]);

    /**
     * UserUpdate keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.keyType = 0;

    /**
     * UserUpdate fullName.
     * @member {string} fullName
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.fullName = "";

    /**
     * UserUpdate jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.jobTitle = "";

    /**
     * UserUpdate email.
     * @member {string} email
     * @memberof Enterprise.UserUpdate
     * @instance
     */
    UserUpdate.prototype.email = "";

    /**
     * Creates a new UserUpdate instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Enterprise.IUserUpdate=} [properties] Properties to set
     * @returns {Enterprise.UserUpdate} UserUpdate instance
     */
    UserUpdate.create = function create(properties) {
      return new UserUpdate(properties);
    };

    /**
     * Encodes the specified UserUpdate message. Does not implicitly {@link Enterprise.UserUpdate.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Enterprise.IUserUpdate} message UserUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdate.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.keyType);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.jobTitle);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.email);
      return writer;
    };

    /**
     * Encodes the specified UserUpdate message, length delimited. Does not implicitly {@link Enterprise.UserUpdate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Enterprise.IUserUpdate} message UserUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdate.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserUpdate} UserUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdate.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserUpdate();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.nodeId = reader.int64();
            break;
          }
          case 3: {
            message.encryptedData = reader.bytes();
            break;
          }
          case 4: {
            message.keyType = reader.int32();
            break;
          }
          case 5: {
            message.fullName = reader.string();
            break;
          }
          case 6: {
            message.jobTitle = reader.string();
            break;
          }
          case 7: {
            message.email = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserUpdate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserUpdate} UserUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdate.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserUpdate message.
     * @function verify
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserUpdate.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (
          !(
            (message.encryptedData && typeof message.encryptedData.length === "number") ||
            $util.isString(message.encryptedData)
          )
        )
          return "encryptedData: buffer expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      return null;
    };

    /**
     * Creates a UserUpdate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserUpdate} UserUpdate
     */
    UserUpdate.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserUpdate) return object;
      let message = new $root.Enterprise.UserUpdate();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null)
        if (typeof object.encryptedData === "string")
          $util.base64.decode(
            object.encryptedData,
            (message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData))),
            0,
          );
        else if (object.encryptedData.length >= 0) message.encryptedData = object.encryptedData;
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.email != null) message.email = String(object.email);
      return message;
    };

    /**
     * Creates a plain object from a UserUpdate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {Enterprise.UserUpdate} message UserUpdate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserUpdate.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedData = "";
        else {
          object.encryptedData = [];
          if (options.bytes !== Array) object.encryptedData = $util.newBuffer(object.encryptedData);
        }
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
        object.fullName = "";
        object.jobTitle = "";
        object.email = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData =
          options.bytes === String
            ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedData)
              : message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      return object;
    };

    /**
     * Converts this UserUpdate to JSON.
     * @function toJSON
     * @memberof Enterprise.UserUpdate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserUpdate.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserUpdate
     * @function getTypeUrl
     * @memberof Enterprise.UserUpdate
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserUpdate";
    };

    return UserUpdate;
  })();

  Enterprise.UserUpdateResponse = (function () {
    /**
     * Properties of a UserUpdateResponse.
     * @memberof Enterprise
     * @interface IUserUpdateResponse
     * @property {Array.<Enterprise.IUserUpdateResult>|null} [users] UserUpdateResponse users
     */

    /**
     * Constructs a new UserUpdateResponse.
     * @memberof Enterprise
     * @classdesc Represents a UserUpdateResponse.
     * @implements IUserUpdateResponse
     * @constructor
     * @param {Enterprise.IUserUpdateResponse=} [properties] Properties to set
     */
    function UserUpdateResponse(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserUpdateResponse users.
     * @member {Array.<Enterprise.IUserUpdateResult>} users
     * @memberof Enterprise.UserUpdateResponse
     * @instance
     */
    UserUpdateResponse.prototype.users = $util.emptyArray;

    /**
     * Creates a new UserUpdateResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Enterprise.IUserUpdateResponse=} [properties] Properties to set
     * @returns {Enterprise.UserUpdateResponse} UserUpdateResponse instance
     */
    UserUpdateResponse.create = function create(properties) {
      return new UserUpdateResponse(properties);
    };

    /**
     * Encodes the specified UserUpdateResponse message. Does not implicitly {@link Enterprise.UserUpdateResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Enterprise.IUserUpdateResponse} message UserUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.UserUpdateResult.encode(
            message.users[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified UserUpdateResponse message, length delimited. Does not implicitly {@link Enterprise.UserUpdateResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Enterprise.IUserUpdateResponse} message UserUpdateResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserUpdateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserUpdateResponse} UserUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserUpdateResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push($root.Enterprise.UserUpdateResult.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserUpdateResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserUpdateResponse} UserUpdateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserUpdateResponse message.
     * @function verify
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserUpdateResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.UserUpdateResult.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      return null;
    };

    /**
     * Creates a UserUpdateResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserUpdateResponse} UserUpdateResponse
     */
    UserUpdateResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserUpdateResponse) return object;
      let message = new $root.Enterprise.UserUpdateResponse();
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.UserUpdateResponse.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.UserUpdateResponse.users: object expected");
          message.users[i] = $root.Enterprise.UserUpdateResult.fromObject(object.users[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a UserUpdateResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {Enterprise.UserUpdateResponse} message UserUpdateResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserUpdateResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.UserUpdateResult.toObject(message.users[j], options);
      }
      return object;
    };

    /**
     * Converts this UserUpdateResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.UserUpdateResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserUpdateResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserUpdateResponse
     * @function getTypeUrl
     * @memberof Enterprise.UserUpdateResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserUpdateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserUpdateResponse";
    };

    return UserUpdateResponse;
  })();

  Enterprise.UserUpdateResult = (function () {
    /**
     * Properties of a UserUpdateResult.
     * @memberof Enterprise
     * @interface IUserUpdateResult
     * @property {number|Long|null} [enterpriseUserId] UserUpdateResult enterpriseUserId
     * @property {Enterprise.UserUpdateStatus|null} [status] UserUpdateResult status
     */

    /**
     * Constructs a new UserUpdateResult.
     * @memberof Enterprise
     * @classdesc Represents a UserUpdateResult.
     * @implements IUserUpdateResult
     * @constructor
     * @param {Enterprise.IUserUpdateResult=} [properties] Properties to set
     */
    function UserUpdateResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserUpdateResult enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserUpdateResult
     * @instance
     */
    UserUpdateResult.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserUpdateResult status.
     * @member {Enterprise.UserUpdateStatus} status
     * @memberof Enterprise.UserUpdateResult
     * @instance
     */
    UserUpdateResult.prototype.status = 0;

    /**
     * Creates a new UserUpdateResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Enterprise.IUserUpdateResult=} [properties] Properties to set
     * @returns {Enterprise.UserUpdateResult} UserUpdateResult instance
     */
    UserUpdateResult.create = function create(properties) {
      return new UserUpdateResult(properties);
    };

    /**
     * Encodes the specified UserUpdateResult message. Does not implicitly {@link Enterprise.UserUpdateResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Enterprise.IUserUpdateResult} message UserUpdateResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.status);
      return writer;
    };

    /**
     * Encodes the specified UserUpdateResult message, length delimited. Does not implicitly {@link Enterprise.UserUpdateResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Enterprise.IUserUpdateResult} message UserUpdateResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserUpdateResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserUpdateResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserUpdateResult} UserUpdateResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserUpdateResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.status = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserUpdateResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserUpdateResult} UserUpdateResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserUpdateResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserUpdateResult message.
     * @function verify
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserUpdateResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.status != null && message.hasOwnProperty("status"))
        switch (message.status) {
          default:
            return "status: enum value expected";
          case 0:
          case 1:
            break;
        }
      return null;
    };

    /**
     * Creates a UserUpdateResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserUpdateResult} UserUpdateResult
     */
    UserUpdateResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserUpdateResult) return object;
      let message = new $root.Enterprise.UserUpdateResult();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      switch (object.status) {
        default:
          if (typeof object.status === "number") {
            message.status = object.status;
            break;
          }
          break;
        case "USER_UPDATE_OK":
        case 0:
          message.status = 0;
          break;
        case "USER_UPDATE_ACCESS_DENIED":
        case 1:
          message.status = 1;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a UserUpdateResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {Enterprise.UserUpdateResult} message UserUpdateResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserUpdateResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.status = options.enums === String ? "USER_UPDATE_OK" : 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status =
          options.enums === String
            ? $root.Enterprise.UserUpdateStatus[message.status] === undefined
              ? message.status
              : $root.Enterprise.UserUpdateStatus[message.status]
            : message.status;
      return object;
    };

    /**
     * Converts this UserUpdateResult to JSON.
     * @function toJSON
     * @memberof Enterprise.UserUpdateResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserUpdateResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserUpdateResult
     * @function getTypeUrl
     * @memberof Enterprise.UserUpdateResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserUpdateResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserUpdateResult";
    };

    return UserUpdateResult;
  })();

  Enterprise.ComplianceRecordOwnersRequest = (function () {
    /**
     * Properties of a ComplianceRecordOwnersRequest.
     * @memberof Enterprise
     * @interface IComplianceRecordOwnersRequest
     * @property {Array.<number|Long>|null} [nodeIds] ComplianceRecordOwnersRequest nodeIds
     * @property {boolean|null} [includeNonShared] ComplianceRecordOwnersRequest includeNonShared
     */

    /**
     * Constructs a new ComplianceRecordOwnersRequest.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceRecordOwnersRequest.
     * @implements IComplianceRecordOwnersRequest
     * @constructor
     * @param {Enterprise.IComplianceRecordOwnersRequest=} [properties] Properties to set
     */
    function ComplianceRecordOwnersRequest(properties) {
      this.nodeIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceRecordOwnersRequest nodeIds.
     * @member {Array.<number|Long>} nodeIds
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @instance
     */
    ComplianceRecordOwnersRequest.prototype.nodeIds = $util.emptyArray;

    /**
     * ComplianceRecordOwnersRequest includeNonShared.
     * @member {boolean} includeNonShared
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @instance
     */
    ComplianceRecordOwnersRequest.prototype.includeNonShared = false;

    /**
     * Creates a new ComplianceRecordOwnersRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Enterprise.IComplianceRecordOwnersRequest=} [properties] Properties to set
     * @returns {Enterprise.ComplianceRecordOwnersRequest} ComplianceRecordOwnersRequest instance
     */
    ComplianceRecordOwnersRequest.create = function create(properties) {
      return new ComplianceRecordOwnersRequest(properties);
    };

    /**
     * Encodes the specified ComplianceRecordOwnersRequest message. Does not implicitly {@link Enterprise.ComplianceRecordOwnersRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Enterprise.IComplianceRecordOwnersRequest} message ComplianceRecordOwnersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceRecordOwnersRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeIds != null && message.nodeIds.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.nodeIds.length; ++i) writer.int64(message.nodeIds[i]);
        writer.ldelim();
      }
      if (
        message.includeNonShared != null &&
        Object.hasOwnProperty.call(message, "includeNonShared")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.includeNonShared);
      return writer;
    };

    /**
     * Encodes the specified ComplianceRecordOwnersRequest message, length delimited. Does not implicitly {@link Enterprise.ComplianceRecordOwnersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Enterprise.IComplianceRecordOwnersRequest} message ComplianceRecordOwnersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceRecordOwnersRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceRecordOwnersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceRecordOwnersRequest} ComplianceRecordOwnersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceRecordOwnersRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceRecordOwnersRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.nodeIds && message.nodeIds.length)) message.nodeIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.nodeIds.push(reader.int64());
            } else message.nodeIds.push(reader.int64());
            break;
          }
          case 2: {
            message.includeNonShared = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceRecordOwnersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceRecordOwnersRequest} ComplianceRecordOwnersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceRecordOwnersRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceRecordOwnersRequest message.
     * @function verify
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceRecordOwnersRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeIds != null && message.hasOwnProperty("nodeIds")) {
        if (!Array.isArray(message.nodeIds)) return "nodeIds: array expected";
        for (let i = 0; i < message.nodeIds.length; ++i)
          if (
            !$util.isInteger(message.nodeIds[i]) &&
            !(
              message.nodeIds[i] &&
              $util.isInteger(message.nodeIds[i].low) &&
              $util.isInteger(message.nodeIds[i].high)
            )
          )
            return "nodeIds: integer|Long[] expected";
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        if (typeof message.includeNonShared !== "boolean")
          return "includeNonShared: boolean expected";
      return null;
    };

    /**
     * Creates a ComplianceRecordOwnersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceRecordOwnersRequest} ComplianceRecordOwnersRequest
     */
    ComplianceRecordOwnersRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceRecordOwnersRequest) return object;
      let message = new $root.Enterprise.ComplianceRecordOwnersRequest();
      if (object.nodeIds) {
        if (!Array.isArray(object.nodeIds))
          throw TypeError(".Enterprise.ComplianceRecordOwnersRequest.nodeIds: array expected");
        message.nodeIds = [];
        for (let i = 0; i < object.nodeIds.length; ++i)
          if ($util.Long)
            (message.nodeIds[i] = $util.Long.fromValue(object.nodeIds[i])).unsigned = false;
          else if (typeof object.nodeIds[i] === "string")
            message.nodeIds[i] = parseInt(object.nodeIds[i], 10);
          else if (typeof object.nodeIds[i] === "number") message.nodeIds[i] = object.nodeIds[i];
          else if (typeof object.nodeIds[i] === "object")
            message.nodeIds[i] = new $util.LongBits(
              object.nodeIds[i].low >>> 0,
              object.nodeIds[i].high >>> 0,
            ).toNumber();
      }
      if (object.includeNonShared != null)
        message.includeNonShared = Boolean(object.includeNonShared);
      return message;
    };

    /**
     * Creates a plain object from a ComplianceRecordOwnersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {Enterprise.ComplianceRecordOwnersRequest} message ComplianceRecordOwnersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceRecordOwnersRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.nodeIds = [];
      if (options.defaults) object.includeNonShared = false;
      if (message.nodeIds && message.nodeIds.length) {
        object.nodeIds = [];
        for (let j = 0; j < message.nodeIds.length; ++j)
          if (typeof message.nodeIds[j] === "number")
            object.nodeIds[j] =
              options.longs === String ? String(message.nodeIds[j]) : message.nodeIds[j];
          else
            object.nodeIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nodeIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.nodeIds[j].low >>> 0,
                      message.nodeIds[j].high >>> 0,
                    ).toNumber()
                  : message.nodeIds[j];
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        object.includeNonShared = message.includeNonShared;
      return object;
    };

    /**
     * Converts this ComplianceRecordOwnersRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceRecordOwnersRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceRecordOwnersRequest
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceRecordOwnersRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceRecordOwnersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceRecordOwnersRequest";
    };

    return ComplianceRecordOwnersRequest;
  })();

  Enterprise.ComplianceRecordOwnersResponse = (function () {
    /**
     * Properties of a ComplianceRecordOwnersResponse.
     * @memberof Enterprise
     * @interface IComplianceRecordOwnersResponse
     * @property {Array.<Enterprise.IRecordOwner>|null} [recordOwners] ComplianceRecordOwnersResponse recordOwners
     */

    /**
     * Constructs a new ComplianceRecordOwnersResponse.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceRecordOwnersResponse.
     * @implements IComplianceRecordOwnersResponse
     * @constructor
     * @param {Enterprise.IComplianceRecordOwnersResponse=} [properties] Properties to set
     */
    function ComplianceRecordOwnersResponse(properties) {
      this.recordOwners = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceRecordOwnersResponse recordOwners.
     * @member {Array.<Enterprise.IRecordOwner>} recordOwners
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @instance
     */
    ComplianceRecordOwnersResponse.prototype.recordOwners = $util.emptyArray;

    /**
     * Creates a new ComplianceRecordOwnersResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Enterprise.IComplianceRecordOwnersResponse=} [properties] Properties to set
     * @returns {Enterprise.ComplianceRecordOwnersResponse} ComplianceRecordOwnersResponse instance
     */
    ComplianceRecordOwnersResponse.create = function create(properties) {
      return new ComplianceRecordOwnersResponse(properties);
    };

    /**
     * Encodes the specified ComplianceRecordOwnersResponse message. Does not implicitly {@link Enterprise.ComplianceRecordOwnersResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Enterprise.IComplianceRecordOwnersResponse} message ComplianceRecordOwnersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceRecordOwnersResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordOwners != null && message.recordOwners.length)
        for (let i = 0; i < message.recordOwners.length; ++i)
          $root.Enterprise.RecordOwner.encode(
            message.recordOwners[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified ComplianceRecordOwnersResponse message, length delimited. Does not implicitly {@link Enterprise.ComplianceRecordOwnersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Enterprise.IComplianceRecordOwnersResponse} message ComplianceRecordOwnersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceRecordOwnersResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceRecordOwnersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceRecordOwnersResponse} ComplianceRecordOwnersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceRecordOwnersResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceRecordOwnersResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.recordOwners && message.recordOwners.length)) message.recordOwners = [];
            message.recordOwners.push($root.Enterprise.RecordOwner.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceRecordOwnersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceRecordOwnersResponse} ComplianceRecordOwnersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceRecordOwnersResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceRecordOwnersResponse message.
     * @function verify
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceRecordOwnersResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordOwners != null && message.hasOwnProperty("recordOwners")) {
        if (!Array.isArray(message.recordOwners)) return "recordOwners: array expected";
        for (let i = 0; i < message.recordOwners.length; ++i) {
          let error = $root.Enterprise.RecordOwner.verify(message.recordOwners[i]);
          if (error) return "recordOwners." + error;
        }
      }
      return null;
    };

    /**
     * Creates a ComplianceRecordOwnersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceRecordOwnersResponse} ComplianceRecordOwnersResponse
     */
    ComplianceRecordOwnersResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceRecordOwnersResponse) return object;
      let message = new $root.Enterprise.ComplianceRecordOwnersResponse();
      if (object.recordOwners) {
        if (!Array.isArray(object.recordOwners))
          throw TypeError(
            ".Enterprise.ComplianceRecordOwnersResponse.recordOwners: array expected",
          );
        message.recordOwners = [];
        for (let i = 0; i < object.recordOwners.length; ++i) {
          if (typeof object.recordOwners[i] !== "object")
            throw TypeError(
              ".Enterprise.ComplianceRecordOwnersResponse.recordOwners: object expected",
            );
          message.recordOwners[i] = $root.Enterprise.RecordOwner.fromObject(object.recordOwners[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a ComplianceRecordOwnersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {Enterprise.ComplianceRecordOwnersResponse} message ComplianceRecordOwnersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceRecordOwnersResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.recordOwners = [];
      if (message.recordOwners && message.recordOwners.length) {
        object.recordOwners = [];
        for (let j = 0; j < message.recordOwners.length; ++j)
          object.recordOwners[j] = $root.Enterprise.RecordOwner.toObject(
            message.recordOwners[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this ComplianceRecordOwnersResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceRecordOwnersResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceRecordOwnersResponse
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceRecordOwnersResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceRecordOwnersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceRecordOwnersResponse";
    };

    return ComplianceRecordOwnersResponse;
  })();

  Enterprise.RecordOwner = (function () {
    /**
     * Properties of a RecordOwner.
     * @memberof Enterprise
     * @interface IRecordOwner
     * @property {number|Long|null} [enterpriseUserId] RecordOwner enterpriseUserId
     * @property {boolean|null} [shared] RecordOwner shared
     */

    /**
     * Constructs a new RecordOwner.
     * @memberof Enterprise
     * @classdesc Represents a RecordOwner.
     * @implements IRecordOwner
     * @constructor
     * @param {Enterprise.IRecordOwner=} [properties] Properties to set
     */
    function RecordOwner(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RecordOwner enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.RecordOwner
     * @instance
     */
    RecordOwner.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * RecordOwner shared.
     * @member {boolean} shared
     * @memberof Enterprise.RecordOwner
     * @instance
     */
    RecordOwner.prototype.shared = false;

    /**
     * Creates a new RecordOwner instance using the specified properties.
     * @function create
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Enterprise.IRecordOwner=} [properties] Properties to set
     * @returns {Enterprise.RecordOwner} RecordOwner instance
     */
    RecordOwner.create = function create(properties) {
      return new RecordOwner(properties);
    };

    /**
     * Encodes the specified RecordOwner message. Does not implicitly {@link Enterprise.RecordOwner.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Enterprise.IRecordOwner} message RecordOwner message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordOwner.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.shared != null && Object.hasOwnProperty.call(message, "shared"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.shared);
      return writer;
    };

    /**
     * Encodes the specified RecordOwner message, length delimited. Does not implicitly {@link Enterprise.RecordOwner.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Enterprise.IRecordOwner} message RecordOwner message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordOwner.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RecordOwner message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RecordOwner} RecordOwner
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordOwner.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RecordOwner();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.shared = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RecordOwner message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RecordOwner} RecordOwner
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordOwner.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RecordOwner message.
     * @function verify
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RecordOwner.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.shared != null && message.hasOwnProperty("shared"))
        if (typeof message.shared !== "boolean") return "shared: boolean expected";
      return null;
    };

    /**
     * Creates a RecordOwner message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RecordOwner} RecordOwner
     */
    RecordOwner.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RecordOwner) return object;
      let message = new $root.Enterprise.RecordOwner();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.shared != null) message.shared = Boolean(object.shared);
      return message;
    };

    /**
     * Creates a plain object from a RecordOwner message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {Enterprise.RecordOwner} message RecordOwner
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RecordOwner.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.shared = false;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.shared != null && message.hasOwnProperty("shared"))
        object.shared = message.shared;
      return object;
    };

    /**
     * Converts this RecordOwner to JSON.
     * @function toJSON
     * @memberof Enterprise.RecordOwner
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RecordOwner.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RecordOwner
     * @function getTypeUrl
     * @memberof Enterprise.RecordOwner
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RecordOwner.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RecordOwner";
    };

    return RecordOwner;
  })();

  Enterprise.PreliminaryComplianceDataRequest = (function () {
    /**
     * Properties of a PreliminaryComplianceDataRequest.
     * @memberof Enterprise
     * @interface IPreliminaryComplianceDataRequest
     * @property {Array.<number|Long>|null} [enterpriseUserIds] PreliminaryComplianceDataRequest enterpriseUserIds
     * @property {boolean|null} [includeNonShared] PreliminaryComplianceDataRequest includeNonShared
     * @property {Uint8Array|null} [continuationToken] PreliminaryComplianceDataRequest continuationToken
     * @property {boolean|null} [includeTotalMatchingRecordsInFirstResponse] PreliminaryComplianceDataRequest includeTotalMatchingRecordsInFirstResponse
     */

    /**
     * Constructs a new PreliminaryComplianceDataRequest.
     * @memberof Enterprise
     * @classdesc Represents a PreliminaryComplianceDataRequest.
     * @implements IPreliminaryComplianceDataRequest
     * @constructor
     * @param {Enterprise.IPreliminaryComplianceDataRequest=} [properties] Properties to set
     */
    function PreliminaryComplianceDataRequest(properties) {
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * PreliminaryComplianceDataRequest enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @instance
     */
    PreliminaryComplianceDataRequest.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * PreliminaryComplianceDataRequest includeNonShared.
     * @member {boolean} includeNonShared
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @instance
     */
    PreliminaryComplianceDataRequest.prototype.includeNonShared = false;

    /**
     * PreliminaryComplianceDataRequest continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @instance
     */
    PreliminaryComplianceDataRequest.prototype.continuationToken = $util.newBuffer([]);

    /**
     * PreliminaryComplianceDataRequest includeTotalMatchingRecordsInFirstResponse.
     * @member {boolean} includeTotalMatchingRecordsInFirstResponse
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @instance
     */
    PreliminaryComplianceDataRequest.prototype.includeTotalMatchingRecordsInFirstResponse = false;

    /**
     * Creates a new PreliminaryComplianceDataRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataRequest=} [properties] Properties to set
     * @returns {Enterprise.PreliminaryComplianceDataRequest} PreliminaryComplianceDataRequest instance
     */
    PreliminaryComplianceDataRequest.create = function create(properties) {
      return new PreliminaryComplianceDataRequest(properties);
    };

    /**
     * Encodes the specified PreliminaryComplianceDataRequest message. Does not implicitly {@link Enterprise.PreliminaryComplianceDataRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataRequest} message PreliminaryComplianceDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreliminaryComplianceDataRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      if (
        message.includeNonShared != null &&
        Object.hasOwnProperty.call(message, "includeNonShared")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.includeNonShared);
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.continuationToken);
      if (
        message.includeTotalMatchingRecordsInFirstResponse != null &&
        Object.hasOwnProperty.call(message, "includeTotalMatchingRecordsInFirstResponse")
      )
        writer
          .uint32(/* id 4, wireType 0 =*/ 32)
          .bool(message.includeTotalMatchingRecordsInFirstResponse);
      return writer;
    };

    /**
     * Encodes the specified PreliminaryComplianceDataRequest message, length delimited. Does not implicitly {@link Enterprise.PreliminaryComplianceDataRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataRequest} message PreliminaryComplianceDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreliminaryComplianceDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PreliminaryComplianceDataRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.PreliminaryComplianceDataRequest} PreliminaryComplianceDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreliminaryComplianceDataRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.PreliminaryComplianceDataRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          case 2: {
            message.includeNonShared = reader.bool();
            break;
          }
          case 3: {
            message.continuationToken = reader.bytes();
            break;
          }
          case 4: {
            message.includeTotalMatchingRecordsInFirstResponse = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a PreliminaryComplianceDataRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.PreliminaryComplianceDataRequest} PreliminaryComplianceDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreliminaryComplianceDataRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PreliminaryComplianceDataRequest message.
     * @function verify
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PreliminaryComplianceDataRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        if (typeof message.includeNonShared !== "boolean")
          return "includeNonShared: boolean expected";
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      if (
        message.includeTotalMatchingRecordsInFirstResponse != null &&
        message.hasOwnProperty("includeTotalMatchingRecordsInFirstResponse")
      )
        if (typeof message.includeTotalMatchingRecordsInFirstResponse !== "boolean")
          return "includeTotalMatchingRecordsInFirstResponse: boolean expected";
      return null;
    };

    /**
     * Creates a PreliminaryComplianceDataRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.PreliminaryComplianceDataRequest} PreliminaryComplianceDataRequest
     */
    PreliminaryComplianceDataRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.PreliminaryComplianceDataRequest) return object;
      let message = new $root.Enterprise.PreliminaryComplianceDataRequest();
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(
            ".Enterprise.PreliminaryComplianceDataRequest.enterpriseUserIds: array expected",
          );
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      if (object.includeNonShared != null)
        message.includeNonShared = Boolean(object.includeNonShared);
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      if (object.includeTotalMatchingRecordsInFirstResponse != null)
        message.includeTotalMatchingRecordsInFirstResponse = Boolean(
          object.includeTotalMatchingRecordsInFirstResponse,
        );
      return message;
    };

    /**
     * Creates a plain object from a PreliminaryComplianceDataRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {Enterprise.PreliminaryComplianceDataRequest} message PreliminaryComplianceDataRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PreliminaryComplianceDataRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserIds = [];
      if (options.defaults) {
        object.includeNonShared = false;
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
        object.includeTotalMatchingRecordsInFirstResponse = false;
      }
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        object.includeNonShared = message.includeNonShared;
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      if (
        message.includeTotalMatchingRecordsInFirstResponse != null &&
        message.hasOwnProperty("includeTotalMatchingRecordsInFirstResponse")
      )
        object.includeTotalMatchingRecordsInFirstResponse =
          message.includeTotalMatchingRecordsInFirstResponse;
      return object;
    };

    /**
     * Converts this PreliminaryComplianceDataRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PreliminaryComplianceDataRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PreliminaryComplianceDataRequest
     * @function getTypeUrl
     * @memberof Enterprise.PreliminaryComplianceDataRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PreliminaryComplianceDataRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.PreliminaryComplianceDataRequest";
    };

    return PreliminaryComplianceDataRequest;
  })();

  Enterprise.PreliminaryComplianceDataResponse = (function () {
    /**
     * Properties of a PreliminaryComplianceDataResponse.
     * @memberof Enterprise
     * @interface IPreliminaryComplianceDataResponse
     * @property {Array.<Enterprise.IAuditUserData>|null} [auditUserData] PreliminaryComplianceDataResponse auditUserData
     * @property {Uint8Array|null} [continuationToken] PreliminaryComplianceDataResponse continuationToken
     * @property {boolean|null} [hasMore] PreliminaryComplianceDataResponse hasMore
     * @property {number|null} [totalMatchingRecords] PreliminaryComplianceDataResponse totalMatchingRecords
     */

    /**
     * Constructs a new PreliminaryComplianceDataResponse.
     * @memberof Enterprise
     * @classdesc Represents a PreliminaryComplianceDataResponse.
     * @implements IPreliminaryComplianceDataResponse
     * @constructor
     * @param {Enterprise.IPreliminaryComplianceDataResponse=} [properties] Properties to set
     */
    function PreliminaryComplianceDataResponse(properties) {
      this.auditUserData = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * PreliminaryComplianceDataResponse auditUserData.
     * @member {Array.<Enterprise.IAuditUserData>} auditUserData
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @instance
     */
    PreliminaryComplianceDataResponse.prototype.auditUserData = $util.emptyArray;

    /**
     * PreliminaryComplianceDataResponse continuationToken.
     * @member {Uint8Array} continuationToken
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @instance
     */
    PreliminaryComplianceDataResponse.prototype.continuationToken = $util.newBuffer([]);

    /**
     * PreliminaryComplianceDataResponse hasMore.
     * @member {boolean} hasMore
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @instance
     */
    PreliminaryComplianceDataResponse.prototype.hasMore = false;

    /**
     * PreliminaryComplianceDataResponse totalMatchingRecords.
     * @member {number} totalMatchingRecords
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @instance
     */
    PreliminaryComplianceDataResponse.prototype.totalMatchingRecords = 0;

    /**
     * Creates a new PreliminaryComplianceDataResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataResponse=} [properties] Properties to set
     * @returns {Enterprise.PreliminaryComplianceDataResponse} PreliminaryComplianceDataResponse instance
     */
    PreliminaryComplianceDataResponse.create = function create(properties) {
      return new PreliminaryComplianceDataResponse(properties);
    };

    /**
     * Encodes the specified PreliminaryComplianceDataResponse message. Does not implicitly {@link Enterprise.PreliminaryComplianceDataResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataResponse} message PreliminaryComplianceDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreliminaryComplianceDataResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.auditUserData != null && message.auditUserData.length)
        for (let i = 0; i < message.auditUserData.length; ++i)
          $root.Enterprise.AuditUserData.encode(
            message.auditUserData[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (
        message.continuationToken != null &&
        Object.hasOwnProperty.call(message, "continuationToken")
      )
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.continuationToken);
      if (message.hasMore != null && Object.hasOwnProperty.call(message, "hasMore"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.hasMore);
      if (
        message.totalMatchingRecords != null &&
        Object.hasOwnProperty.call(message, "totalMatchingRecords")
      )
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.totalMatchingRecords);
      return writer;
    };

    /**
     * Encodes the specified PreliminaryComplianceDataResponse message, length delimited. Does not implicitly {@link Enterprise.PreliminaryComplianceDataResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Enterprise.IPreliminaryComplianceDataResponse} message PreliminaryComplianceDataResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PreliminaryComplianceDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PreliminaryComplianceDataResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.PreliminaryComplianceDataResponse} PreliminaryComplianceDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreliminaryComplianceDataResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.PreliminaryComplianceDataResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.auditUserData && message.auditUserData.length))
              message.auditUserData = [];
            message.auditUserData.push(
              $root.Enterprise.AuditUserData.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            message.continuationToken = reader.bytes();
            break;
          }
          case 3: {
            message.hasMore = reader.bool();
            break;
          }
          case 4: {
            message.totalMatchingRecords = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a PreliminaryComplianceDataResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.PreliminaryComplianceDataResponse} PreliminaryComplianceDataResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PreliminaryComplianceDataResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PreliminaryComplianceDataResponse message.
     * @function verify
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PreliminaryComplianceDataResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.auditUserData != null && message.hasOwnProperty("auditUserData")) {
        if (!Array.isArray(message.auditUserData)) return "auditUserData: array expected";
        for (let i = 0; i < message.auditUserData.length; ++i) {
          let error = $root.Enterprise.AuditUserData.verify(message.auditUserData[i]);
          if (error) return "auditUserData." + error;
        }
      }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        if (
          !(
            (message.continuationToken && typeof message.continuationToken.length === "number") ||
            $util.isString(message.continuationToken)
          )
        )
          return "continuationToken: buffer expected";
      if (message.hasMore != null && message.hasOwnProperty("hasMore"))
        if (typeof message.hasMore !== "boolean") return "hasMore: boolean expected";
      if (message.totalMatchingRecords != null && message.hasOwnProperty("totalMatchingRecords"))
        if (!$util.isInteger(message.totalMatchingRecords))
          return "totalMatchingRecords: integer expected";
      return null;
    };

    /**
     * Creates a PreliminaryComplianceDataResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.PreliminaryComplianceDataResponse} PreliminaryComplianceDataResponse
     */
    PreliminaryComplianceDataResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.PreliminaryComplianceDataResponse) return object;
      let message = new $root.Enterprise.PreliminaryComplianceDataResponse();
      if (object.auditUserData) {
        if (!Array.isArray(object.auditUserData))
          throw TypeError(
            ".Enterprise.PreliminaryComplianceDataResponse.auditUserData: array expected",
          );
        message.auditUserData = [];
        for (let i = 0; i < object.auditUserData.length; ++i) {
          if (typeof object.auditUserData[i] !== "object")
            throw TypeError(
              ".Enterprise.PreliminaryComplianceDataResponse.auditUserData: object expected",
            );
          message.auditUserData[i] = $root.Enterprise.AuditUserData.fromObject(
            object.auditUserData[i],
          );
        }
      }
      if (object.continuationToken != null)
        if (typeof object.continuationToken === "string")
          $util.base64.decode(
            object.continuationToken,
            (message.continuationToken = $util.newBuffer(
              $util.base64.length(object.continuationToken),
            )),
            0,
          );
        else if (object.continuationToken.length >= 0)
          message.continuationToken = object.continuationToken;
      if (object.hasMore != null) message.hasMore = Boolean(object.hasMore);
      if (object.totalMatchingRecords != null)
        message.totalMatchingRecords = object.totalMatchingRecords | 0;
      return message;
    };

    /**
     * Creates a plain object from a PreliminaryComplianceDataResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {Enterprise.PreliminaryComplianceDataResponse} message PreliminaryComplianceDataResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PreliminaryComplianceDataResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.auditUserData = [];
      if (options.defaults) {
        if (options.bytes === String) object.continuationToken = "";
        else {
          object.continuationToken = [];
          if (options.bytes !== Array)
            object.continuationToken = $util.newBuffer(object.continuationToken);
        }
        object.hasMore = false;
        object.totalMatchingRecords = 0;
      }
      if (message.auditUserData && message.auditUserData.length) {
        object.auditUserData = [];
        for (let j = 0; j < message.auditUserData.length; ++j)
          object.auditUserData[j] = $root.Enterprise.AuditUserData.toObject(
            message.auditUserData[j],
            options,
          );
      }
      if (message.continuationToken != null && message.hasOwnProperty("continuationToken"))
        object.continuationToken =
          options.bytes === String
            ? $util.base64.encode(message.continuationToken, 0, message.continuationToken.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.continuationToken)
              : message.continuationToken;
      if (message.hasMore != null && message.hasOwnProperty("hasMore"))
        object.hasMore = message.hasMore;
      if (message.totalMatchingRecords != null && message.hasOwnProperty("totalMatchingRecords"))
        object.totalMatchingRecords = message.totalMatchingRecords;
      return object;
    };

    /**
     * Converts this PreliminaryComplianceDataResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PreliminaryComplianceDataResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PreliminaryComplianceDataResponse
     * @function getTypeUrl
     * @memberof Enterprise.PreliminaryComplianceDataResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PreliminaryComplianceDataResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.PreliminaryComplianceDataResponse";
    };

    return PreliminaryComplianceDataResponse;
  })();

  Enterprise.AuditUserRecord = (function () {
    /**
     * Properties of an AuditUserRecord.
     * @memberof Enterprise
     * @interface IAuditUserRecord
     * @property {Uint8Array|null} [recordUid] AuditUserRecord recordUid
     * @property {Uint8Array|null} [encryptedData] AuditUserRecord encryptedData
     * @property {boolean|null} [shared] AuditUserRecord shared
     */

    /**
     * Constructs a new AuditUserRecord.
     * @memberof Enterprise
     * @classdesc Represents an AuditUserRecord.
     * @implements IAuditUserRecord
     * @constructor
     * @param {Enterprise.IAuditUserRecord=} [properties] Properties to set
     */
    function AuditUserRecord(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditUserRecord recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.AuditUserRecord
     * @instance
     */
    AuditUserRecord.prototype.recordUid = $util.newBuffer([]);

    /**
     * AuditUserRecord encryptedData.
     * @member {Uint8Array} encryptedData
     * @memberof Enterprise.AuditUserRecord
     * @instance
     */
    AuditUserRecord.prototype.encryptedData = $util.newBuffer([]);

    /**
     * AuditUserRecord shared.
     * @member {boolean} shared
     * @memberof Enterprise.AuditUserRecord
     * @instance
     */
    AuditUserRecord.prototype.shared = false;

    /**
     * Creates a new AuditUserRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Enterprise.IAuditUserRecord=} [properties] Properties to set
     * @returns {Enterprise.AuditUserRecord} AuditUserRecord instance
     */
    AuditUserRecord.create = function create(properties) {
      return new AuditUserRecord(properties);
    };

    /**
     * Encodes the specified AuditUserRecord message. Does not implicitly {@link Enterprise.AuditUserRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Enterprise.IAuditUserRecord} message AuditUserRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditUserRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.recordUid);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedData);
      if (message.shared != null && Object.hasOwnProperty.call(message, "shared"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.shared);
      return writer;
    };

    /**
     * Encodes the specified AuditUserRecord message, length delimited. Does not implicitly {@link Enterprise.AuditUserRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Enterprise.IAuditUserRecord} message AuditUserRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditUserRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditUserRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditUserRecord} AuditUserRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditUserRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditUserRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.recordUid = reader.bytes();
            break;
          }
          case 2: {
            message.encryptedData = reader.bytes();
            break;
          }
          case 3: {
            message.shared = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditUserRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditUserRecord} AuditUserRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditUserRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditUserRecord message.
     * @function verify
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditUserRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (
          !(
            (message.encryptedData && typeof message.encryptedData.length === "number") ||
            $util.isString(message.encryptedData)
          )
        )
          return "encryptedData: buffer expected";
      if (message.shared != null && message.hasOwnProperty("shared"))
        if (typeof message.shared !== "boolean") return "shared: boolean expected";
      return null;
    };

    /**
     * Creates an AuditUserRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditUserRecord} AuditUserRecord
     */
    AuditUserRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditUserRecord) return object;
      let message = new $root.Enterprise.AuditUserRecord();
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.encryptedData != null)
        if (typeof object.encryptedData === "string")
          $util.base64.decode(
            object.encryptedData,
            (message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData))),
            0,
          );
        else if (object.encryptedData.length >= 0) message.encryptedData = object.encryptedData;
      if (object.shared != null) message.shared = Boolean(object.shared);
      return message;
    };

    /**
     * Creates a plain object from an AuditUserRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {Enterprise.AuditUserRecord} message AuditUserRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditUserRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        if (options.bytes === String) object.encryptedData = "";
        else {
          object.encryptedData = [];
          if (options.bytes !== Array) object.encryptedData = $util.newBuffer(object.encryptedData);
        }
        object.shared = false;
      }
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData =
          options.bytes === String
            ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedData)
              : message.encryptedData;
      if (message.shared != null && message.hasOwnProperty("shared"))
        object.shared = message.shared;
      return object;
    };

    /**
     * Converts this AuditUserRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditUserRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditUserRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditUserRecord
     * @function getTypeUrl
     * @memberof Enterprise.AuditUserRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditUserRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditUserRecord";
    };

    return AuditUserRecord;
  })();

  Enterprise.AuditUserData = (function () {
    /**
     * Properties of an AuditUserData.
     * @memberof Enterprise
     * @interface IAuditUserData
     * @property {number|Long|null} [enterpriseUserId] AuditUserData enterpriseUserId
     * @property {Array.<Enterprise.IAuditUserRecord>|null} [auditUserRecords] AuditUserData auditUserRecords
     * @property {Enterprise.AuditUserStatus|null} [status] AuditUserData status
     */

    /**
     * Constructs a new AuditUserData.
     * @memberof Enterprise
     * @classdesc Represents an AuditUserData.
     * @implements IAuditUserData
     * @constructor
     * @param {Enterprise.IAuditUserData=} [properties] Properties to set
     */
    function AuditUserData(properties) {
      this.auditUserRecords = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditUserData enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.AuditUserData
     * @instance
     */
    AuditUserData.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * AuditUserData auditUserRecords.
     * @member {Array.<Enterprise.IAuditUserRecord>} auditUserRecords
     * @memberof Enterprise.AuditUserData
     * @instance
     */
    AuditUserData.prototype.auditUserRecords = $util.emptyArray;

    /**
     * AuditUserData status.
     * @member {Enterprise.AuditUserStatus} status
     * @memberof Enterprise.AuditUserData
     * @instance
     */
    AuditUserData.prototype.status = 0;

    /**
     * Creates a new AuditUserData instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Enterprise.IAuditUserData=} [properties] Properties to set
     * @returns {Enterprise.AuditUserData} AuditUserData instance
     */
    AuditUserData.create = function create(properties) {
      return new AuditUserData(properties);
    };

    /**
     * Encodes the specified AuditUserData message. Does not implicitly {@link Enterprise.AuditUserData.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Enterprise.IAuditUserData} message AuditUserData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditUserData.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.auditUserRecords != null && message.auditUserRecords.length)
        for (let i = 0; i < message.auditUserRecords.length; ++i)
          $root.Enterprise.AuditUserRecord.encode(
            message.auditUserRecords[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.status);
      return writer;
    };

    /**
     * Encodes the specified AuditUserData message, length delimited. Does not implicitly {@link Enterprise.AuditUserData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Enterprise.IAuditUserData} message AuditUserData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditUserData.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditUserData message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditUserData} AuditUserData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditUserData.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditUserData();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.auditUserRecords && message.auditUserRecords.length))
              message.auditUserRecords = [];
            message.auditUserRecords.push(
              $root.Enterprise.AuditUserRecord.decode(reader, reader.uint32()),
            );
            break;
          }
          case 3: {
            message.status = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditUserData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditUserData} AuditUserData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditUserData.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditUserData message.
     * @function verify
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditUserData.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.auditUserRecords != null && message.hasOwnProperty("auditUserRecords")) {
        if (!Array.isArray(message.auditUserRecords)) return "auditUserRecords: array expected";
        for (let i = 0; i < message.auditUserRecords.length; ++i) {
          let error = $root.Enterprise.AuditUserRecord.verify(message.auditUserRecords[i]);
          if (error) return "auditUserRecords." + error;
        }
      }
      if (message.status != null && message.hasOwnProperty("status"))
        switch (message.status) {
          default:
            return "status: enum value expected";
          case 0:
          case 1:
          case 2:
            break;
        }
      return null;
    };

    /**
     * Creates an AuditUserData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditUserData} AuditUserData
     */
    AuditUserData.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditUserData) return object;
      let message = new $root.Enterprise.AuditUserData();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.auditUserRecords) {
        if (!Array.isArray(object.auditUserRecords))
          throw TypeError(".Enterprise.AuditUserData.auditUserRecords: array expected");
        message.auditUserRecords = [];
        for (let i = 0; i < object.auditUserRecords.length; ++i) {
          if (typeof object.auditUserRecords[i] !== "object")
            throw TypeError(".Enterprise.AuditUserData.auditUserRecords: object expected");
          message.auditUserRecords[i] = $root.Enterprise.AuditUserRecord.fromObject(
            object.auditUserRecords[i],
          );
        }
      }
      switch (object.status) {
        default:
          if (typeof object.status === "number") {
            message.status = object.status;
            break;
          }
          break;
        case "OK":
        case 0:
          message.status = 0;
          break;
        case "ACCESS_DENIED":
        case 1:
          message.status = 1;
          break;
        case "NO_LONGER_IN_ENTERPRISE":
        case 2:
          message.status = 2;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from an AuditUserData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {Enterprise.AuditUserData} message AuditUserData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditUserData.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.auditUserRecords = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.status = options.enums === String ? "OK" : 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.auditUserRecords && message.auditUserRecords.length) {
        object.auditUserRecords = [];
        for (let j = 0; j < message.auditUserRecords.length; ++j)
          object.auditUserRecords[j] = $root.Enterprise.AuditUserRecord.toObject(
            message.auditUserRecords[j],
            options,
          );
      }
      if (message.status != null && message.hasOwnProperty("status"))
        object.status =
          options.enums === String
            ? $root.Enterprise.AuditUserStatus[message.status] === undefined
              ? message.status
              : $root.Enterprise.AuditUserStatus[message.status]
            : message.status;
      return object;
    };

    /**
     * Converts this AuditUserData to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditUserData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditUserData.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditUserData
     * @function getTypeUrl
     * @memberof Enterprise.AuditUserData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditUserData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditUserData";
    };

    return AuditUserData;
  })();

  Enterprise.ComplianceReportFilters = (function () {
    /**
     * Properties of a ComplianceReportFilters.
     * @memberof Enterprise
     * @interface IComplianceReportFilters
     * @property {Array.<string>|null} [recordTitles] ComplianceReportFilters recordTitles
     * @property {Array.<Uint8Array>|null} [recordUids] ComplianceReportFilters recordUids
     * @property {Array.<number|Long>|null} [jobTitles] ComplianceReportFilters jobTitles
     * @property {Array.<string>|null} [urls] ComplianceReportFilters urls
     * @property {Array.<number|Long>|null} [enterpriseUserIds] ComplianceReportFilters enterpriseUserIds
     */

    /**
     * Constructs a new ComplianceReportFilters.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportFilters.
     * @implements IComplianceReportFilters
     * @constructor
     * @param {Enterprise.IComplianceReportFilters=} [properties] Properties to set
     */
    function ComplianceReportFilters(properties) {
      this.recordTitles = [];
      this.recordUids = [];
      this.jobTitles = [];
      this.urls = [];
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportFilters recordTitles.
     * @member {Array.<string>} recordTitles
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     */
    ComplianceReportFilters.prototype.recordTitles = $util.emptyArray;

    /**
     * ComplianceReportFilters recordUids.
     * @member {Array.<Uint8Array>} recordUids
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     */
    ComplianceReportFilters.prototype.recordUids = $util.emptyArray;

    /**
     * ComplianceReportFilters jobTitles.
     * @member {Array.<number|Long>} jobTitles
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     */
    ComplianceReportFilters.prototype.jobTitles = $util.emptyArray;

    /**
     * ComplianceReportFilters urls.
     * @member {Array.<string>} urls
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     */
    ComplianceReportFilters.prototype.urls = $util.emptyArray;

    /**
     * ComplianceReportFilters enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     */
    ComplianceReportFilters.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * Creates a new ComplianceReportFilters instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Enterprise.IComplianceReportFilters=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportFilters} ComplianceReportFilters instance
     */
    ComplianceReportFilters.create = function create(properties) {
      return new ComplianceReportFilters(properties);
    };

    /**
     * Encodes the specified ComplianceReportFilters message. Does not implicitly {@link Enterprise.ComplianceReportFilters.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Enterprise.IComplianceReportFilters} message ComplianceReportFilters message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportFilters.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordTitles != null && message.recordTitles.length)
        for (let i = 0; i < message.recordTitles.length; ++i)
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.recordTitles[i]);
      if (message.recordUids != null && message.recordUids.length)
        for (let i = 0; i < message.recordUids.length; ++i)
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.recordUids[i]);
      if (message.jobTitles != null && message.jobTitles.length) {
        writer.uint32(/* id 3, wireType 2 =*/ 26).fork();
        for (let i = 0; i < message.jobTitles.length; ++i) writer.int64(message.jobTitles[i]);
        writer.ldelim();
      }
      if (message.urls != null && message.urls.length)
        for (let i = 0; i < message.urls.length; ++i)
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.urls[i]);
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 5, wireType 2 =*/ 42).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportFilters message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportFilters.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Enterprise.IComplianceReportFilters} message ComplianceReportFilters message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportFilters.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportFilters message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportFilters} ComplianceReportFilters
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportFilters.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportFilters();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.recordTitles && message.recordTitles.length)) message.recordTitles = [];
            message.recordTitles.push(reader.string());
            break;
          }
          case 2: {
            if (!(message.recordUids && message.recordUids.length)) message.recordUids = [];
            message.recordUids.push(reader.bytes());
            break;
          }
          case 3: {
            if (!(message.jobTitles && message.jobTitles.length)) message.jobTitles = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.jobTitles.push(reader.int64());
            } else message.jobTitles.push(reader.int64());
            break;
          }
          case 4: {
            if (!(message.urls && message.urls.length)) message.urls = [];
            message.urls.push(reader.string());
            break;
          }
          case 5: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportFilters message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportFilters} ComplianceReportFilters
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportFilters.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportFilters message.
     * @function verify
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportFilters.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordTitles != null && message.hasOwnProperty("recordTitles")) {
        if (!Array.isArray(message.recordTitles)) return "recordTitles: array expected";
        for (let i = 0; i < message.recordTitles.length; ++i)
          if (!$util.isString(message.recordTitles[i])) return "recordTitles: string[] expected";
      }
      if (message.recordUids != null && message.hasOwnProperty("recordUids")) {
        if (!Array.isArray(message.recordUids)) return "recordUids: array expected";
        for (let i = 0; i < message.recordUids.length; ++i)
          if (
            !(
              (message.recordUids[i] && typeof message.recordUids[i].length === "number") ||
              $util.isString(message.recordUids[i])
            )
          )
            return "recordUids: buffer[] expected";
      }
      if (message.jobTitles != null && message.hasOwnProperty("jobTitles")) {
        if (!Array.isArray(message.jobTitles)) return "jobTitles: array expected";
        for (let i = 0; i < message.jobTitles.length; ++i)
          if (
            !$util.isInteger(message.jobTitles[i]) &&
            !(
              message.jobTitles[i] &&
              $util.isInteger(message.jobTitles[i].low) &&
              $util.isInteger(message.jobTitles[i].high)
            )
          )
            return "jobTitles: integer|Long[] expected";
      }
      if (message.urls != null && message.hasOwnProperty("urls")) {
        if (!Array.isArray(message.urls)) return "urls: array expected";
        for (let i = 0; i < message.urls.length; ++i)
          if (!$util.isString(message.urls[i])) return "urls: string[] expected";
      }
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a ComplianceReportFilters message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportFilters} ComplianceReportFilters
     */
    ComplianceReportFilters.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportFilters) return object;
      let message = new $root.Enterprise.ComplianceReportFilters();
      if (object.recordTitles) {
        if (!Array.isArray(object.recordTitles))
          throw TypeError(".Enterprise.ComplianceReportFilters.recordTitles: array expected");
        message.recordTitles = [];
        for (let i = 0; i < object.recordTitles.length; ++i)
          message.recordTitles[i] = String(object.recordTitles[i]);
      }
      if (object.recordUids) {
        if (!Array.isArray(object.recordUids))
          throw TypeError(".Enterprise.ComplianceReportFilters.recordUids: array expected");
        message.recordUids = [];
        for (let i = 0; i < object.recordUids.length; ++i)
          if (typeof object.recordUids[i] === "string")
            $util.base64.decode(
              object.recordUids[i],
              (message.recordUids[i] = $util.newBuffer($util.base64.length(object.recordUids[i]))),
              0,
            );
          else if (object.recordUids[i].length >= 0) message.recordUids[i] = object.recordUids[i];
      }
      if (object.jobTitles) {
        if (!Array.isArray(object.jobTitles))
          throw TypeError(".Enterprise.ComplianceReportFilters.jobTitles: array expected");
        message.jobTitles = [];
        for (let i = 0; i < object.jobTitles.length; ++i)
          if ($util.Long)
            (message.jobTitles[i] = $util.Long.fromValue(object.jobTitles[i])).unsigned = false;
          else if (typeof object.jobTitles[i] === "string")
            message.jobTitles[i] = parseInt(object.jobTitles[i], 10);
          else if (typeof object.jobTitles[i] === "number")
            message.jobTitles[i] = object.jobTitles[i];
          else if (typeof object.jobTitles[i] === "object")
            message.jobTitles[i] = new $util.LongBits(
              object.jobTitles[i].low >>> 0,
              object.jobTitles[i].high >>> 0,
            ).toNumber();
      }
      if (object.urls) {
        if (!Array.isArray(object.urls))
          throw TypeError(".Enterprise.ComplianceReportFilters.urls: array expected");
        message.urls = [];
        for (let i = 0; i < object.urls.length; ++i) message.urls[i] = String(object.urls[i]);
      }
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(".Enterprise.ComplianceReportFilters.enterpriseUserIds: array expected");
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportFilters message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {Enterprise.ComplianceReportFilters} message ComplianceReportFilters
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportFilters.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.recordTitles = [];
        object.recordUids = [];
        object.jobTitles = [];
        object.urls = [];
        object.enterpriseUserIds = [];
      }
      if (message.recordTitles && message.recordTitles.length) {
        object.recordTitles = [];
        for (let j = 0; j < message.recordTitles.length; ++j)
          object.recordTitles[j] = message.recordTitles[j];
      }
      if (message.recordUids && message.recordUids.length) {
        object.recordUids = [];
        for (let j = 0; j < message.recordUids.length; ++j)
          object.recordUids[j] =
            options.bytes === String
              ? $util.base64.encode(message.recordUids[j], 0, message.recordUids[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.recordUids[j])
                : message.recordUids[j];
      }
      if (message.jobTitles && message.jobTitles.length) {
        object.jobTitles = [];
        for (let j = 0; j < message.jobTitles.length; ++j)
          if (typeof message.jobTitles[j] === "number")
            object.jobTitles[j] =
              options.longs === String ? String(message.jobTitles[j]) : message.jobTitles[j];
          else
            object.jobTitles[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.jobTitles[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.jobTitles[j].low >>> 0,
                      message.jobTitles[j].high >>> 0,
                    ).toNumber()
                  : message.jobTitles[j];
      }
      if (message.urls && message.urls.length) {
        object.urls = [];
        for (let j = 0; j < message.urls.length; ++j) object.urls[j] = message.urls[j];
      }
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      return object;
    };

    /**
     * Converts this ComplianceReportFilters to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportFilters
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportFilters.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportFilters
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportFilters
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportFilters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportFilters";
    };

    return ComplianceReportFilters;
  })();

  Enterprise.ComplianceReportRequest = (function () {
    /**
     * Properties of a ComplianceReportRequest.
     * @memberof Enterprise
     * @interface IComplianceReportRequest
     * @property {Enterprise.IComplianceReportRun|null} [complianceReportRun] ComplianceReportRequest complianceReportRun
     * @property {string|null} [reportName] ComplianceReportRequest reportName
     * @property {boolean|null} [saveReport] ComplianceReportRequest saveReport
     */

    /**
     * Constructs a new ComplianceReportRequest.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportRequest.
     * @implements IComplianceReportRequest
     * @constructor
     * @param {Enterprise.IComplianceReportRequest=} [properties] Properties to set
     */
    function ComplianceReportRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportRequest complianceReportRun.
     * @member {Enterprise.IComplianceReportRun|null|undefined} complianceReportRun
     * @memberof Enterprise.ComplianceReportRequest
     * @instance
     */
    ComplianceReportRequest.prototype.complianceReportRun = null;

    /**
     * ComplianceReportRequest reportName.
     * @member {string} reportName
     * @memberof Enterprise.ComplianceReportRequest
     * @instance
     */
    ComplianceReportRequest.prototype.reportName = "";

    /**
     * ComplianceReportRequest saveReport.
     * @member {boolean} saveReport
     * @memberof Enterprise.ComplianceReportRequest
     * @instance
     */
    ComplianceReportRequest.prototype.saveReport = false;

    /**
     * Creates a new ComplianceReportRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Enterprise.IComplianceReportRequest=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportRequest} ComplianceReportRequest instance
     */
    ComplianceReportRequest.create = function create(properties) {
      return new ComplianceReportRequest(properties);
    };

    /**
     * Encodes the specified ComplianceReportRequest message. Does not implicitly {@link Enterprise.ComplianceReportRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Enterprise.IComplianceReportRequest} message ComplianceReportRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.complianceReportRun != null &&
        Object.hasOwnProperty.call(message, "complianceReportRun")
      )
        $root.Enterprise.ComplianceReportRun.encode(
          message.complianceReportRun,
          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
        ).ldelim();
      if (message.reportName != null && Object.hasOwnProperty.call(message, "reportName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reportName);
      if (message.saveReport != null && Object.hasOwnProperty.call(message, "saveReport"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.saveReport);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportRequest message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Enterprise.IComplianceReportRequest} message ComplianceReportRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportRequest} ComplianceReportRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.complianceReportRun = $root.Enterprise.ComplianceReportRun.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 2: {
            message.reportName = reader.string();
            break;
          }
          case 3: {
            message.saveReport = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportRequest} ComplianceReportRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportRequest message.
     * @function verify
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.complianceReportRun != null && message.hasOwnProperty("complianceReportRun")) {
        let error = $root.Enterprise.ComplianceReportRun.verify(message.complianceReportRun);
        if (error) return "complianceReportRun." + error;
      }
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        if (!$util.isString(message.reportName)) return "reportName: string expected";
      if (message.saveReport != null && message.hasOwnProperty("saveReport"))
        if (typeof message.saveReport !== "boolean") return "saveReport: boolean expected";
      return null;
    };

    /**
     * Creates a ComplianceReportRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportRequest} ComplianceReportRequest
     */
    ComplianceReportRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportRequest) return object;
      let message = new $root.Enterprise.ComplianceReportRequest();
      if (object.complianceReportRun != null) {
        if (typeof object.complianceReportRun !== "object")
          throw TypeError(
            ".Enterprise.ComplianceReportRequest.complianceReportRun: object expected",
          );
        message.complianceReportRun = $root.Enterprise.ComplianceReportRun.fromObject(
          object.complianceReportRun,
        );
      }
      if (object.reportName != null) message.reportName = String(object.reportName);
      if (object.saveReport != null) message.saveReport = Boolean(object.saveReport);
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {Enterprise.ComplianceReportRequest} message ComplianceReportRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.complianceReportRun = null;
        object.reportName = "";
        object.saveReport = false;
      }
      if (message.complianceReportRun != null && message.hasOwnProperty("complianceReportRun"))
        object.complianceReportRun = $root.Enterprise.ComplianceReportRun.toObject(
          message.complianceReportRun,
          options,
        );
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        object.reportName = message.reportName;
      if (message.saveReport != null && message.hasOwnProperty("saveReport"))
        object.saveReport = message.saveReport;
      return object;
    };

    /**
     * Converts this ComplianceReportRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportRequest
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportRequest";
    };

    return ComplianceReportRequest;
  })();

  Enterprise.ComplianceReportRun = (function () {
    /**
     * Properties of a ComplianceReportRun.
     * @memberof Enterprise
     * @interface IComplianceReportRun
     * @property {Enterprise.IComplianceReportCriteriaAndFilter|null} [reportCriteriaAndFilter] ComplianceReportRun reportCriteriaAndFilter
     * @property {Array.<number|Long>|null} [users] ComplianceReportRun users
     * @property {Array.<Uint8Array>|null} [records] ComplianceReportRun records
     */

    /**
     * Constructs a new ComplianceReportRun.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportRun.
     * @implements IComplianceReportRun
     * @constructor
     * @param {Enterprise.IComplianceReportRun=} [properties] Properties to set
     */
    function ComplianceReportRun(properties) {
      this.users = [];
      this.records = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportRun reportCriteriaAndFilter.
     * @member {Enterprise.IComplianceReportCriteriaAndFilter|null|undefined} reportCriteriaAndFilter
     * @memberof Enterprise.ComplianceReportRun
     * @instance
     */
    ComplianceReportRun.prototype.reportCriteriaAndFilter = null;

    /**
     * ComplianceReportRun users.
     * @member {Array.<number|Long>} users
     * @memberof Enterprise.ComplianceReportRun
     * @instance
     */
    ComplianceReportRun.prototype.users = $util.emptyArray;

    /**
     * ComplianceReportRun records.
     * @member {Array.<Uint8Array>} records
     * @memberof Enterprise.ComplianceReportRun
     * @instance
     */
    ComplianceReportRun.prototype.records = $util.emptyArray;

    /**
     * Creates a new ComplianceReportRun instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Enterprise.IComplianceReportRun=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportRun} ComplianceReportRun instance
     */
    ComplianceReportRun.create = function create(properties) {
      return new ComplianceReportRun(properties);
    };

    /**
     * Encodes the specified ComplianceReportRun message. Does not implicitly {@link Enterprise.ComplianceReportRun.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Enterprise.IComplianceReportRun} message ComplianceReportRun message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportRun.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.reportCriteriaAndFilter != null &&
        Object.hasOwnProperty.call(message, "reportCriteriaAndFilter")
      )
        $root.Enterprise.ComplianceReportCriteriaAndFilter.encode(
          message.reportCriteriaAndFilter,
          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
        ).ldelim();
      if (message.users != null && message.users.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.users.length; ++i) writer.int64(message.users[i]);
        writer.ldelim();
      }
      if (message.records != null && message.records.length)
        for (let i = 0; i < message.records.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.records[i]);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportRun message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportRun.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Enterprise.IComplianceReportRun} message ComplianceReportRun message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportRun.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportRun message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportRun} ComplianceReportRun
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportRun.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportRun();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.reportCriteriaAndFilter =
              $root.Enterprise.ComplianceReportCriteriaAndFilter.decode(reader, reader.uint32());
            break;
          }
          case 2: {
            if (!(message.users && message.users.length)) message.users = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.users.push(reader.int64());
            } else message.users.push(reader.int64());
            break;
          }
          case 3: {
            if (!(message.records && message.records.length)) message.records = [];
            message.records.push(reader.bytes());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportRun message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportRun} ComplianceReportRun
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportRun.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportRun message.
     * @function verify
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportRun.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (
        message.reportCriteriaAndFilter != null &&
        message.hasOwnProperty("reportCriteriaAndFilter")
      ) {
        let error = $root.Enterprise.ComplianceReportCriteriaAndFilter.verify(
          message.reportCriteriaAndFilter,
        );
        if (error) return "reportCriteriaAndFilter." + error;
      }
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i)
          if (
            !$util.isInteger(message.users[i]) &&
            !(
              message.users[i] &&
              $util.isInteger(message.users[i].low) &&
              $util.isInteger(message.users[i].high)
            )
          )
            return "users: integer|Long[] expected";
      }
      if (message.records != null && message.hasOwnProperty("records")) {
        if (!Array.isArray(message.records)) return "records: array expected";
        for (let i = 0; i < message.records.length; ++i)
          if (
            !(
              (message.records[i] && typeof message.records[i].length === "number") ||
              $util.isString(message.records[i])
            )
          )
            return "records: buffer[] expected";
      }
      return null;
    };

    /**
     * Creates a ComplianceReportRun message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportRun} ComplianceReportRun
     */
    ComplianceReportRun.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportRun) return object;
      let message = new $root.Enterprise.ComplianceReportRun();
      if (object.reportCriteriaAndFilter != null) {
        if (typeof object.reportCriteriaAndFilter !== "object")
          throw TypeError(
            ".Enterprise.ComplianceReportRun.reportCriteriaAndFilter: object expected",
          );
        message.reportCriteriaAndFilter =
          $root.Enterprise.ComplianceReportCriteriaAndFilter.fromObject(
            object.reportCriteriaAndFilter,
          );
      }
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.ComplianceReportRun.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i)
          if ($util.Long)
            (message.users[i] = $util.Long.fromValue(object.users[i])).unsigned = false;
          else if (typeof object.users[i] === "string")
            message.users[i] = parseInt(object.users[i], 10);
          else if (typeof object.users[i] === "number") message.users[i] = object.users[i];
          else if (typeof object.users[i] === "object")
            message.users[i] = new $util.LongBits(
              object.users[i].low >>> 0,
              object.users[i].high >>> 0,
            ).toNumber();
      }
      if (object.records) {
        if (!Array.isArray(object.records))
          throw TypeError(".Enterprise.ComplianceReportRun.records: array expected");
        message.records = [];
        for (let i = 0; i < object.records.length; ++i)
          if (typeof object.records[i] === "string")
            $util.base64.decode(
              object.records[i],
              (message.records[i] = $util.newBuffer($util.base64.length(object.records[i]))),
              0,
            );
          else if (object.records[i].length >= 0) message.records[i] = object.records[i];
      }
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportRun message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {Enterprise.ComplianceReportRun} message ComplianceReportRun
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportRun.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.users = [];
        object.records = [];
      }
      if (options.defaults) object.reportCriteriaAndFilter = null;
      if (
        message.reportCriteriaAndFilter != null &&
        message.hasOwnProperty("reportCriteriaAndFilter")
      )
        object.reportCriteriaAndFilter =
          $root.Enterprise.ComplianceReportCriteriaAndFilter.toObject(
            message.reportCriteriaAndFilter,
            options,
          );
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          if (typeof message.users[j] === "number")
            object.users[j] =
              options.longs === String ? String(message.users[j]) : message.users[j];
          else
            object.users[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.users[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.users[j].low >>> 0,
                      message.users[j].high >>> 0,
                    ).toNumber()
                  : message.users[j];
      }
      if (message.records && message.records.length) {
        object.records = [];
        for (let j = 0; j < message.records.length; ++j)
          object.records[j] =
            options.bytes === String
              ? $util.base64.encode(message.records[j], 0, message.records[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.records[j])
                : message.records[j];
      }
      return object;
    };

    /**
     * Converts this ComplianceReportRun to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportRun
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportRun.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportRun
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportRun
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportRun.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportRun";
    };

    return ComplianceReportRun;
  })();

  Enterprise.ComplianceReportCriteriaAndFilter = (function () {
    /**
     * Properties of a ComplianceReportCriteriaAndFilter.
     * @memberof Enterprise
     * @interface IComplianceReportCriteriaAndFilter
     * @property {number|Long|null} [nodeId] ComplianceReportCriteriaAndFilter nodeId
     * @property {Uint8Array|null} [criteriaUid] ComplianceReportCriteriaAndFilter criteriaUid
     * @property {string|null} [criteriaName] ComplianceReportCriteriaAndFilter criteriaName
     * @property {Enterprise.IComplianceReportCriteria|null} [criteria] ComplianceReportCriteriaAndFilter criteria
     * @property {Array.<Enterprise.IComplianceReportFilter>|null} [filters] ComplianceReportCriteriaAndFilter filters
     * @property {number|Long|null} [lastModified] ComplianceReportCriteriaAndFilter lastModified
     * @property {Uint8Array|null} [nodeEncryptedData] ComplianceReportCriteriaAndFilter nodeEncryptedData
     */

    /**
     * Constructs a new ComplianceReportCriteriaAndFilter.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportCriteriaAndFilter.
     * @implements IComplianceReportCriteriaAndFilter
     * @constructor
     * @param {Enterprise.IComplianceReportCriteriaAndFilter=} [properties] Properties to set
     */
    function ComplianceReportCriteriaAndFilter(properties) {
      this.filters = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportCriteriaAndFilter nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.nodeId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ComplianceReportCriteriaAndFilter criteriaUid.
     * @member {Uint8Array} criteriaUid
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.criteriaUid = $util.newBuffer([]);

    /**
     * ComplianceReportCriteriaAndFilter criteriaName.
     * @member {string} criteriaName
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.criteriaName = "";

    /**
     * ComplianceReportCriteriaAndFilter criteria.
     * @member {Enterprise.IComplianceReportCriteria|null|undefined} criteria
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.criteria = null;

    /**
     * ComplianceReportCriteriaAndFilter filters.
     * @member {Array.<Enterprise.IComplianceReportFilter>} filters
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.filters = $util.emptyArray;

    /**
     * ComplianceReportCriteriaAndFilter lastModified.
     * @member {number|Long} lastModified
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.lastModified = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ComplianceReportCriteriaAndFilter nodeEncryptedData.
     * @member {Uint8Array} nodeEncryptedData
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     */
    ComplianceReportCriteriaAndFilter.prototype.nodeEncryptedData = $util.newBuffer([]);

    /**
     * Creates a new ComplianceReportCriteriaAndFilter instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Enterprise.IComplianceReportCriteriaAndFilter=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportCriteriaAndFilter} ComplianceReportCriteriaAndFilter instance
     */
    ComplianceReportCriteriaAndFilter.create = function create(properties) {
      return new ComplianceReportCriteriaAndFilter(properties);
    };

    /**
     * Encodes the specified ComplianceReportCriteriaAndFilter message. Does not implicitly {@link Enterprise.ComplianceReportCriteriaAndFilter.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Enterprise.IComplianceReportCriteriaAndFilter} message ComplianceReportCriteriaAndFilter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteriaAndFilter.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.nodeId);
      if (message.criteriaUid != null && Object.hasOwnProperty.call(message, "criteriaUid"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.criteriaUid);
      if (message.criteriaName != null && Object.hasOwnProperty.call(message, "criteriaName"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.criteriaName);
      if (message.criteria != null && Object.hasOwnProperty.call(message, "criteria"))
        $root.Enterprise.ComplianceReportCriteria.encode(
          message.criteria,
          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
        ).ldelim();
      if (message.filters != null && message.filters.length)
        for (let i = 0; i < message.filters.length; ++i)
          $root.Enterprise.ComplianceReportFilter.encode(
            message.filters[i],
            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
          ).ldelim();
      if (message.lastModified != null && Object.hasOwnProperty.call(message, "lastModified"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.lastModified);
      if (
        message.nodeEncryptedData != null &&
        Object.hasOwnProperty.call(message, "nodeEncryptedData")
      )
        writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.nodeEncryptedData);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportCriteriaAndFilter message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportCriteriaAndFilter.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Enterprise.IComplianceReportCriteriaAndFilter} message ComplianceReportCriteriaAndFilter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteriaAndFilter.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportCriteriaAndFilter message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportCriteriaAndFilter} ComplianceReportCriteriaAndFilter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteriaAndFilter.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportCriteriaAndFilter();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.nodeId = reader.int64();
            break;
          }
          case 2: {
            message.criteriaUid = reader.bytes();
            break;
          }
          case 3: {
            message.criteriaName = reader.string();
            break;
          }
          case 4: {
            message.criteria = $root.Enterprise.ComplianceReportCriteria.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 5: {
            if (!(message.filters && message.filters.length)) message.filters = [];
            message.filters.push(
              $root.Enterprise.ComplianceReportFilter.decode(reader, reader.uint32()),
            );
            break;
          }
          case 6: {
            message.lastModified = reader.int64();
            break;
          }
          case 7: {
            message.nodeEncryptedData = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportCriteriaAndFilter message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportCriteriaAndFilter} ComplianceReportCriteriaAndFilter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteriaAndFilter.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportCriteriaAndFilter message.
     * @function verify
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportCriteriaAndFilter.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        if (
          !(
            (message.criteriaUid && typeof message.criteriaUid.length === "number") ||
            $util.isString(message.criteriaUid)
          )
        )
          return "criteriaUid: buffer expected";
      if (message.criteriaName != null && message.hasOwnProperty("criteriaName"))
        if (!$util.isString(message.criteriaName)) return "criteriaName: string expected";
      if (message.criteria != null && message.hasOwnProperty("criteria")) {
        let error = $root.Enterprise.ComplianceReportCriteria.verify(message.criteria);
        if (error) return "criteria." + error;
      }
      if (message.filters != null && message.hasOwnProperty("filters")) {
        if (!Array.isArray(message.filters)) return "filters: array expected";
        for (let i = 0; i < message.filters.length; ++i) {
          let error = $root.Enterprise.ComplianceReportFilter.verify(message.filters[i]);
          if (error) return "filters." + error;
        }
      }
      if (message.lastModified != null && message.hasOwnProperty("lastModified"))
        if (
          !$util.isInteger(message.lastModified) &&
          !(
            message.lastModified &&
            $util.isInteger(message.lastModified.low) &&
            $util.isInteger(message.lastModified.high)
          )
        )
          return "lastModified: integer|Long expected";
      if (message.nodeEncryptedData != null && message.hasOwnProperty("nodeEncryptedData"))
        if (
          !(
            (message.nodeEncryptedData && typeof message.nodeEncryptedData.length === "number") ||
            $util.isString(message.nodeEncryptedData)
          )
        )
          return "nodeEncryptedData: buffer expected";
      return null;
    };

    /**
     * Creates a ComplianceReportCriteriaAndFilter message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportCriteriaAndFilter} ComplianceReportCriteriaAndFilter
     */
    ComplianceReportCriteriaAndFilter.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportCriteriaAndFilter) return object;
      let message = new $root.Enterprise.ComplianceReportCriteriaAndFilter();
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.criteriaUid != null)
        if (typeof object.criteriaUid === "string")
          $util.base64.decode(
            object.criteriaUid,
            (message.criteriaUid = $util.newBuffer($util.base64.length(object.criteriaUid))),
            0,
          );
        else if (object.criteriaUid.length >= 0) message.criteriaUid = object.criteriaUid;
      if (object.criteriaName != null) message.criteriaName = String(object.criteriaName);
      if (object.criteria != null) {
        if (typeof object.criteria !== "object")
          throw TypeError(
            ".Enterprise.ComplianceReportCriteriaAndFilter.criteria: object expected",
          );
        message.criteria = $root.Enterprise.ComplianceReportCriteria.fromObject(object.criteria);
      }
      if (object.filters) {
        if (!Array.isArray(object.filters))
          throw TypeError(".Enterprise.ComplianceReportCriteriaAndFilter.filters: array expected");
        message.filters = [];
        for (let i = 0; i < object.filters.length; ++i) {
          if (typeof object.filters[i] !== "object")
            throw TypeError(
              ".Enterprise.ComplianceReportCriteriaAndFilter.filters: object expected",
            );
          message.filters[i] = $root.Enterprise.ComplianceReportFilter.fromObject(
            object.filters[i],
          );
        }
      }
      if (object.lastModified != null)
        if ($util.Long)
          (message.lastModified = $util.Long.fromValue(object.lastModified)).unsigned = false;
        else if (typeof object.lastModified === "string")
          message.lastModified = parseInt(object.lastModified, 10);
        else if (typeof object.lastModified === "number")
          message.lastModified = object.lastModified;
        else if (typeof object.lastModified === "object")
          message.lastModified = new $util.LongBits(
            object.lastModified.low >>> 0,
            object.lastModified.high >>> 0,
          ).toNumber();
      if (object.nodeEncryptedData != null)
        if (typeof object.nodeEncryptedData === "string")
          $util.base64.decode(
            object.nodeEncryptedData,
            (message.nodeEncryptedData = $util.newBuffer(
              $util.base64.length(object.nodeEncryptedData),
            )),
            0,
          );
        else if (object.nodeEncryptedData.length >= 0)
          message.nodeEncryptedData = object.nodeEncryptedData;
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportCriteriaAndFilter message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {Enterprise.ComplianceReportCriteriaAndFilter} message ComplianceReportCriteriaAndFilter
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportCriteriaAndFilter.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.filters = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.criteriaUid = "";
        else {
          object.criteriaUid = [];
          if (options.bytes !== Array) object.criteriaUid = $util.newBuffer(object.criteriaUid);
        }
        object.criteriaName = "";
        object.criteria = null;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.lastModified =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.lastModified = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.nodeEncryptedData = "";
        else {
          object.nodeEncryptedData = [];
          if (options.bytes !== Array)
            object.nodeEncryptedData = $util.newBuffer(object.nodeEncryptedData);
        }
      }
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        object.criteriaUid =
          options.bytes === String
            ? $util.base64.encode(message.criteriaUid, 0, message.criteriaUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.criteriaUid)
              : message.criteriaUid;
      if (message.criteriaName != null && message.hasOwnProperty("criteriaName"))
        object.criteriaName = message.criteriaName;
      if (message.criteria != null && message.hasOwnProperty("criteria"))
        object.criteria = $root.Enterprise.ComplianceReportCriteria.toObject(
          message.criteria,
          options,
        );
      if (message.filters && message.filters.length) {
        object.filters = [];
        for (let j = 0; j < message.filters.length; ++j)
          object.filters[j] = $root.Enterprise.ComplianceReportFilter.toObject(
            message.filters[j],
            options,
          );
      }
      if (message.lastModified != null && message.hasOwnProperty("lastModified"))
        if (typeof message.lastModified === "number")
          object.lastModified =
            options.longs === String ? String(message.lastModified) : message.lastModified;
        else
          object.lastModified =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.lastModified)
              : options.longs === Number
                ? new $util.LongBits(
                    message.lastModified.low >>> 0,
                    message.lastModified.high >>> 0,
                  ).toNumber()
                : message.lastModified;
      if (message.nodeEncryptedData != null && message.hasOwnProperty("nodeEncryptedData"))
        object.nodeEncryptedData =
          options.bytes === String
            ? $util.base64.encode(message.nodeEncryptedData, 0, message.nodeEncryptedData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.nodeEncryptedData)
              : message.nodeEncryptedData;
      return object;
    };

    /**
     * Converts this ComplianceReportCriteriaAndFilter to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportCriteriaAndFilter.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportCriteriaAndFilter
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportCriteriaAndFilter
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportCriteriaAndFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportCriteriaAndFilter";
    };

    return ComplianceReportCriteriaAndFilter;
  })();

  Enterprise.ComplianceReportCriteria = (function () {
    /**
     * Properties of a ComplianceReportCriteria.
     * @memberof Enterprise
     * @interface IComplianceReportCriteria
     * @property {Array.<string>|null} [jobTitles] ComplianceReportCriteria jobTitles
     * @property {Array.<number|Long>|null} [enterpriseUserIds] ComplianceReportCriteria enterpriseUserIds
     * @property {boolean|null} [includeNonShared] ComplianceReportCriteria includeNonShared
     */

    /**
     * Constructs a new ComplianceReportCriteria.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportCriteria.
     * @implements IComplianceReportCriteria
     * @constructor
     * @param {Enterprise.IComplianceReportCriteria=} [properties] Properties to set
     */
    function ComplianceReportCriteria(properties) {
      this.jobTitles = [];
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportCriteria jobTitles.
     * @member {Array.<string>} jobTitles
     * @memberof Enterprise.ComplianceReportCriteria
     * @instance
     */
    ComplianceReportCriteria.prototype.jobTitles = $util.emptyArray;

    /**
     * ComplianceReportCriteria enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.ComplianceReportCriteria
     * @instance
     */
    ComplianceReportCriteria.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * ComplianceReportCriteria includeNonShared.
     * @member {boolean} includeNonShared
     * @memberof Enterprise.ComplianceReportCriteria
     * @instance
     */
    ComplianceReportCriteria.prototype.includeNonShared = false;

    /**
     * Creates a new ComplianceReportCriteria instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Enterprise.IComplianceReportCriteria=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportCriteria} ComplianceReportCriteria instance
     */
    ComplianceReportCriteria.create = function create(properties) {
      return new ComplianceReportCriteria(properties);
    };

    /**
     * Encodes the specified ComplianceReportCriteria message. Does not implicitly {@link Enterprise.ComplianceReportCriteria.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Enterprise.IComplianceReportCriteria} message ComplianceReportCriteria message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteria.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.jobTitles != null && message.jobTitles.length)
        for (let i = 0; i < message.jobTitles.length; ++i)
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.jobTitles[i]);
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      if (
        message.includeNonShared != null &&
        Object.hasOwnProperty.call(message, "includeNonShared")
      )
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.includeNonShared);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportCriteria message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportCriteria.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Enterprise.IComplianceReportCriteria} message ComplianceReportCriteria message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteria.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportCriteria message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportCriteria} ComplianceReportCriteria
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteria.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportCriteria();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.jobTitles && message.jobTitles.length)) message.jobTitles = [];
            message.jobTitles.push(reader.string());
            break;
          }
          case 2: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          case 3: {
            message.includeNonShared = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportCriteria message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportCriteria} ComplianceReportCriteria
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteria.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportCriteria message.
     * @function verify
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportCriteria.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.jobTitles != null && message.hasOwnProperty("jobTitles")) {
        if (!Array.isArray(message.jobTitles)) return "jobTitles: array expected";
        for (let i = 0; i < message.jobTitles.length; ++i)
          if (!$util.isString(message.jobTitles[i])) return "jobTitles: string[] expected";
      }
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        if (typeof message.includeNonShared !== "boolean")
          return "includeNonShared: boolean expected";
      return null;
    };

    /**
     * Creates a ComplianceReportCriteria message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportCriteria} ComplianceReportCriteria
     */
    ComplianceReportCriteria.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportCriteria) return object;
      let message = new $root.Enterprise.ComplianceReportCriteria();
      if (object.jobTitles) {
        if (!Array.isArray(object.jobTitles))
          throw TypeError(".Enterprise.ComplianceReportCriteria.jobTitles: array expected");
        message.jobTitles = [];
        for (let i = 0; i < object.jobTitles.length; ++i)
          message.jobTitles[i] = String(object.jobTitles[i]);
      }
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(".Enterprise.ComplianceReportCriteria.enterpriseUserIds: array expected");
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      if (object.includeNonShared != null)
        message.includeNonShared = Boolean(object.includeNonShared);
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportCriteria message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {Enterprise.ComplianceReportCriteria} message ComplianceReportCriteria
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportCriteria.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.jobTitles = [];
        object.enterpriseUserIds = [];
      }
      if (options.defaults) object.includeNonShared = false;
      if (message.jobTitles && message.jobTitles.length) {
        object.jobTitles = [];
        for (let j = 0; j < message.jobTitles.length; ++j)
          object.jobTitles[j] = message.jobTitles[j];
      }
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      if (message.includeNonShared != null && message.hasOwnProperty("includeNonShared"))
        object.includeNonShared = message.includeNonShared;
      return object;
    };

    /**
     * Converts this ComplianceReportCriteria to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportCriteria
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportCriteria.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportCriteria
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportCriteria
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportCriteria.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportCriteria";
    };

    return ComplianceReportCriteria;
  })();

  Enterprise.ComplianceReportFilter = (function () {
    /**
     * Properties of a ComplianceReportFilter.
     * @memberof Enterprise
     * @interface IComplianceReportFilter
     * @property {Array.<string>|null} [recordTitles] ComplianceReportFilter recordTitles
     * @property {Array.<Uint8Array>|null} [recordUids] ComplianceReportFilter recordUids
     * @property {Array.<string>|null} [jobTitles] ComplianceReportFilter jobTitles
     * @property {Array.<string>|null} [urls] ComplianceReportFilter urls
     * @property {Array.<string>|null} [recordTypes] ComplianceReportFilter recordTypes
     */

    /**
     * Constructs a new ComplianceReportFilter.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportFilter.
     * @implements IComplianceReportFilter
     * @constructor
     * @param {Enterprise.IComplianceReportFilter=} [properties] Properties to set
     */
    function ComplianceReportFilter(properties) {
      this.recordTitles = [];
      this.recordUids = [];
      this.jobTitles = [];
      this.urls = [];
      this.recordTypes = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportFilter recordTitles.
     * @member {Array.<string>} recordTitles
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     */
    ComplianceReportFilter.prototype.recordTitles = $util.emptyArray;

    /**
     * ComplianceReportFilter recordUids.
     * @member {Array.<Uint8Array>} recordUids
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     */
    ComplianceReportFilter.prototype.recordUids = $util.emptyArray;

    /**
     * ComplianceReportFilter jobTitles.
     * @member {Array.<string>} jobTitles
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     */
    ComplianceReportFilter.prototype.jobTitles = $util.emptyArray;

    /**
     * ComplianceReportFilter urls.
     * @member {Array.<string>} urls
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     */
    ComplianceReportFilter.prototype.urls = $util.emptyArray;

    /**
     * ComplianceReportFilter recordTypes.
     * @member {Array.<string>} recordTypes
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     */
    ComplianceReportFilter.prototype.recordTypes = $util.emptyArray;

    /**
     * Creates a new ComplianceReportFilter instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Enterprise.IComplianceReportFilter=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportFilter} ComplianceReportFilter instance
     */
    ComplianceReportFilter.create = function create(properties) {
      return new ComplianceReportFilter(properties);
    };

    /**
     * Encodes the specified ComplianceReportFilter message. Does not implicitly {@link Enterprise.ComplianceReportFilter.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Enterprise.IComplianceReportFilter} message ComplianceReportFilter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportFilter.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordTitles != null && message.recordTitles.length)
        for (let i = 0; i < message.recordTitles.length; ++i)
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.recordTitles[i]);
      if (message.recordUids != null && message.recordUids.length)
        for (let i = 0; i < message.recordUids.length; ++i)
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.recordUids[i]);
      if (message.jobTitles != null && message.jobTitles.length)
        for (let i = 0; i < message.jobTitles.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.jobTitles[i]);
      if (message.urls != null && message.urls.length)
        for (let i = 0; i < message.urls.length; ++i)
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.urls[i]);
      if (message.recordTypes != null && message.recordTypes.length)
        for (let i = 0; i < message.recordTypes.length; ++i)
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.recordTypes[i]);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportFilter message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportFilter.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Enterprise.IComplianceReportFilter} message ComplianceReportFilter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportFilter.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportFilter message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportFilter} ComplianceReportFilter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportFilter.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportFilter();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.recordTitles && message.recordTitles.length)) message.recordTitles = [];
            message.recordTitles.push(reader.string());
            break;
          }
          case 2: {
            if (!(message.recordUids && message.recordUids.length)) message.recordUids = [];
            message.recordUids.push(reader.bytes());
            break;
          }
          case 3: {
            if (!(message.jobTitles && message.jobTitles.length)) message.jobTitles = [];
            message.jobTitles.push(reader.string());
            break;
          }
          case 4: {
            if (!(message.urls && message.urls.length)) message.urls = [];
            message.urls.push(reader.string());
            break;
          }
          case 5: {
            if (!(message.recordTypes && message.recordTypes.length)) message.recordTypes = [];
            message.recordTypes.push(reader.string());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportFilter message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportFilter} ComplianceReportFilter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportFilter.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportFilter message.
     * @function verify
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportFilter.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordTitles != null && message.hasOwnProperty("recordTitles")) {
        if (!Array.isArray(message.recordTitles)) return "recordTitles: array expected";
        for (let i = 0; i < message.recordTitles.length; ++i)
          if (!$util.isString(message.recordTitles[i])) return "recordTitles: string[] expected";
      }
      if (message.recordUids != null && message.hasOwnProperty("recordUids")) {
        if (!Array.isArray(message.recordUids)) return "recordUids: array expected";
        for (let i = 0; i < message.recordUids.length; ++i)
          if (
            !(
              (message.recordUids[i] && typeof message.recordUids[i].length === "number") ||
              $util.isString(message.recordUids[i])
            )
          )
            return "recordUids: buffer[] expected";
      }
      if (message.jobTitles != null && message.hasOwnProperty("jobTitles")) {
        if (!Array.isArray(message.jobTitles)) return "jobTitles: array expected";
        for (let i = 0; i < message.jobTitles.length; ++i)
          if (!$util.isString(message.jobTitles[i])) return "jobTitles: string[] expected";
      }
      if (message.urls != null && message.hasOwnProperty("urls")) {
        if (!Array.isArray(message.urls)) return "urls: array expected";
        for (let i = 0; i < message.urls.length; ++i)
          if (!$util.isString(message.urls[i])) return "urls: string[] expected";
      }
      if (message.recordTypes != null && message.hasOwnProperty("recordTypes")) {
        if (!Array.isArray(message.recordTypes)) return "recordTypes: array expected";
        for (let i = 0; i < message.recordTypes.length; ++i)
          if (!$util.isString(message.recordTypes[i])) return "recordTypes: string[] expected";
      }
      return null;
    };

    /**
     * Creates a ComplianceReportFilter message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportFilter} ComplianceReportFilter
     */
    ComplianceReportFilter.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportFilter) return object;
      let message = new $root.Enterprise.ComplianceReportFilter();
      if (object.recordTitles) {
        if (!Array.isArray(object.recordTitles))
          throw TypeError(".Enterprise.ComplianceReportFilter.recordTitles: array expected");
        message.recordTitles = [];
        for (let i = 0; i < object.recordTitles.length; ++i)
          message.recordTitles[i] = String(object.recordTitles[i]);
      }
      if (object.recordUids) {
        if (!Array.isArray(object.recordUids))
          throw TypeError(".Enterprise.ComplianceReportFilter.recordUids: array expected");
        message.recordUids = [];
        for (let i = 0; i < object.recordUids.length; ++i)
          if (typeof object.recordUids[i] === "string")
            $util.base64.decode(
              object.recordUids[i],
              (message.recordUids[i] = $util.newBuffer($util.base64.length(object.recordUids[i]))),
              0,
            );
          else if (object.recordUids[i].length >= 0) message.recordUids[i] = object.recordUids[i];
      }
      if (object.jobTitles) {
        if (!Array.isArray(object.jobTitles))
          throw TypeError(".Enterprise.ComplianceReportFilter.jobTitles: array expected");
        message.jobTitles = [];
        for (let i = 0; i < object.jobTitles.length; ++i)
          message.jobTitles[i] = String(object.jobTitles[i]);
      }
      if (object.urls) {
        if (!Array.isArray(object.urls))
          throw TypeError(".Enterprise.ComplianceReportFilter.urls: array expected");
        message.urls = [];
        for (let i = 0; i < object.urls.length; ++i) message.urls[i] = String(object.urls[i]);
      }
      if (object.recordTypes) {
        if (!Array.isArray(object.recordTypes))
          throw TypeError(".Enterprise.ComplianceReportFilter.recordTypes: array expected");
        message.recordTypes = [];
        for (let i = 0; i < object.recordTypes.length; ++i)
          message.recordTypes[i] = String(object.recordTypes[i]);
      }
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportFilter message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {Enterprise.ComplianceReportFilter} message ComplianceReportFilter
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportFilter.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.recordTitles = [];
        object.recordUids = [];
        object.jobTitles = [];
        object.urls = [];
        object.recordTypes = [];
      }
      if (message.recordTitles && message.recordTitles.length) {
        object.recordTitles = [];
        for (let j = 0; j < message.recordTitles.length; ++j)
          object.recordTitles[j] = message.recordTitles[j];
      }
      if (message.recordUids && message.recordUids.length) {
        object.recordUids = [];
        for (let j = 0; j < message.recordUids.length; ++j)
          object.recordUids[j] =
            options.bytes === String
              ? $util.base64.encode(message.recordUids[j], 0, message.recordUids[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.recordUids[j])
                : message.recordUids[j];
      }
      if (message.jobTitles && message.jobTitles.length) {
        object.jobTitles = [];
        for (let j = 0; j < message.jobTitles.length; ++j)
          object.jobTitles[j] = message.jobTitles[j];
      }
      if (message.urls && message.urls.length) {
        object.urls = [];
        for (let j = 0; j < message.urls.length; ++j) object.urls[j] = message.urls[j];
      }
      if (message.recordTypes && message.recordTypes.length) {
        object.recordTypes = [];
        for (let j = 0; j < message.recordTypes.length; ++j)
          object.recordTypes[j] = message.recordTypes[j];
      }
      return object;
    };

    /**
     * Converts this ComplianceReportFilter to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportFilter
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportFilter.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportFilter
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportFilter
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportFilter";
    };

    return ComplianceReportFilter;
  })();

  Enterprise.ComplianceReportResponse = (function () {
    /**
     * Properties of a ComplianceReportResponse.
     * @memberof Enterprise
     * @interface IComplianceReportResponse
     * @property {number|Long|null} [dateGenerated] ComplianceReportResponse dateGenerated
     * @property {string|null} [runByUserName] ComplianceReportResponse runByUserName
     * @property {string|null} [reportName] ComplianceReportResponse reportName
     * @property {Uint8Array|null} [reportUid] ComplianceReportResponse reportUid
     * @property {Enterprise.IComplianceReportRun|null} [complianceReportRun] ComplianceReportResponse complianceReportRun
     * @property {Array.<Enterprise.IUserProfile>|null} [userProfiles] ComplianceReportResponse userProfiles
     * @property {Array.<Enterprise.IAuditTeam>|null} [auditTeams] ComplianceReportResponse auditTeams
     * @property {Array.<Enterprise.IAuditRecord>|null} [auditRecords] ComplianceReportResponse auditRecords
     * @property {Array.<Enterprise.IUserRecord>|null} [userRecords] ComplianceReportResponse userRecords
     * @property {Array.<Enterprise.ISharedFolderRecord>|null} [sharedFolderRecords] ComplianceReportResponse sharedFolderRecords
     * @property {Array.<Enterprise.ISharedFolderUser>|null} [sharedFolderUsers] ComplianceReportResponse sharedFolderUsers
     * @property {Array.<Enterprise.ISharedFolderTeam>|null} [sharedFolderTeams] ComplianceReportResponse sharedFolderTeams
     * @property {Array.<Enterprise.IAuditTeamUser>|null} [auditTeamUsers] ComplianceReportResponse auditTeamUsers
     * @property {Array.<Enterprise.IAuditRole>|null} [auditRoles] ComplianceReportResponse auditRoles
     * @property {Array.<Enterprise.ILinkedRecord>|null} [linkedRecords] ComplianceReportResponse linkedRecords
     */

    /**
     * Constructs a new ComplianceReportResponse.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportResponse.
     * @implements IComplianceReportResponse
     * @constructor
     * @param {Enterprise.IComplianceReportResponse=} [properties] Properties to set
     */
    function ComplianceReportResponse(properties) {
      this.userProfiles = [];
      this.auditTeams = [];
      this.auditRecords = [];
      this.userRecords = [];
      this.sharedFolderRecords = [];
      this.sharedFolderUsers = [];
      this.sharedFolderTeams = [];
      this.auditTeamUsers = [];
      this.auditRoles = [];
      this.linkedRecords = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportResponse dateGenerated.
     * @member {number|Long} dateGenerated
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.dateGenerated = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * ComplianceReportResponse runByUserName.
     * @member {string} runByUserName
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.runByUserName = "";

    /**
     * ComplianceReportResponse reportName.
     * @member {string} reportName
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.reportName = "";

    /**
     * ComplianceReportResponse reportUid.
     * @member {Uint8Array} reportUid
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.reportUid = $util.newBuffer([]);

    /**
     * ComplianceReportResponse complianceReportRun.
     * @member {Enterprise.IComplianceReportRun|null|undefined} complianceReportRun
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.complianceReportRun = null;

    /**
     * ComplianceReportResponse userProfiles.
     * @member {Array.<Enterprise.IUserProfile>} userProfiles
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.userProfiles = $util.emptyArray;

    /**
     * ComplianceReportResponse auditTeams.
     * @member {Array.<Enterprise.IAuditTeam>} auditTeams
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.auditTeams = $util.emptyArray;

    /**
     * ComplianceReportResponse auditRecords.
     * @member {Array.<Enterprise.IAuditRecord>} auditRecords
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.auditRecords = $util.emptyArray;

    /**
     * ComplianceReportResponse userRecords.
     * @member {Array.<Enterprise.IUserRecord>} userRecords
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.userRecords = $util.emptyArray;

    /**
     * ComplianceReportResponse sharedFolderRecords.
     * @member {Array.<Enterprise.ISharedFolderRecord>} sharedFolderRecords
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.sharedFolderRecords = $util.emptyArray;

    /**
     * ComplianceReportResponse sharedFolderUsers.
     * @member {Array.<Enterprise.ISharedFolderUser>} sharedFolderUsers
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.sharedFolderUsers = $util.emptyArray;

    /**
     * ComplianceReportResponse sharedFolderTeams.
     * @member {Array.<Enterprise.ISharedFolderTeam>} sharedFolderTeams
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.sharedFolderTeams = $util.emptyArray;

    /**
     * ComplianceReportResponse auditTeamUsers.
     * @member {Array.<Enterprise.IAuditTeamUser>} auditTeamUsers
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.auditTeamUsers = $util.emptyArray;

    /**
     * ComplianceReportResponse auditRoles.
     * @member {Array.<Enterprise.IAuditRole>} auditRoles
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.auditRoles = $util.emptyArray;

    /**
     * ComplianceReportResponse linkedRecords.
     * @member {Array.<Enterprise.ILinkedRecord>} linkedRecords
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     */
    ComplianceReportResponse.prototype.linkedRecords = $util.emptyArray;

    /**
     * Creates a new ComplianceReportResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Enterprise.IComplianceReportResponse=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportResponse} ComplianceReportResponse instance
     */
    ComplianceReportResponse.create = function create(properties) {
      return new ComplianceReportResponse(properties);
    };

    /**
     * Encodes the specified ComplianceReportResponse message. Does not implicitly {@link Enterprise.ComplianceReportResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Enterprise.IComplianceReportResponse} message ComplianceReportResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.dateGenerated != null && Object.hasOwnProperty.call(message, "dateGenerated"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.dateGenerated);
      if (message.runByUserName != null && Object.hasOwnProperty.call(message, "runByUserName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.runByUserName);
      if (message.reportName != null && Object.hasOwnProperty.call(message, "reportName"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.reportName);
      if (message.reportUid != null && Object.hasOwnProperty.call(message, "reportUid"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.reportUid);
      if (
        message.complianceReportRun != null &&
        Object.hasOwnProperty.call(message, "complianceReportRun")
      )
        $root.Enterprise.ComplianceReportRun.encode(
          message.complianceReportRun,
          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
        ).ldelim();
      if (message.userProfiles != null && message.userProfiles.length)
        for (let i = 0; i < message.userProfiles.length; ++i)
          $root.Enterprise.UserProfile.encode(
            message.userProfiles[i],
            writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
          ).ldelim();
      if (message.auditTeams != null && message.auditTeams.length)
        for (let i = 0; i < message.auditTeams.length; ++i)
          $root.Enterprise.AuditTeam.encode(
            message.auditTeams[i],
            writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
          ).ldelim();
      if (message.auditRecords != null && message.auditRecords.length)
        for (let i = 0; i < message.auditRecords.length; ++i)
          $root.Enterprise.AuditRecord.encode(
            message.auditRecords[i],
            writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
          ).ldelim();
      if (message.userRecords != null && message.userRecords.length)
        for (let i = 0; i < message.userRecords.length; ++i)
          $root.Enterprise.UserRecord.encode(
            message.userRecords[i],
            writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
          ).ldelim();
      if (message.sharedFolderRecords != null && message.sharedFolderRecords.length)
        for (let i = 0; i < message.sharedFolderRecords.length; ++i)
          $root.Enterprise.SharedFolderRecord.encode(
            message.sharedFolderRecords[i],
            writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
          ).ldelim();
      if (message.sharedFolderUsers != null && message.sharedFolderUsers.length)
        for (let i = 0; i < message.sharedFolderUsers.length; ++i)
          $root.Enterprise.SharedFolderUser.encode(
            message.sharedFolderUsers[i],
            writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
          ).ldelim();
      if (message.sharedFolderTeams != null && message.sharedFolderTeams.length)
        for (let i = 0; i < message.sharedFolderTeams.length; ++i)
          $root.Enterprise.SharedFolderTeam.encode(
            message.sharedFolderTeams[i],
            writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
          ).ldelim();
      if (message.auditTeamUsers != null && message.auditTeamUsers.length)
        for (let i = 0; i < message.auditTeamUsers.length; ++i)
          $root.Enterprise.AuditTeamUser.encode(
            message.auditTeamUsers[i],
            writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),
          ).ldelim();
      if (message.auditRoles != null && message.auditRoles.length)
        for (let i = 0; i < message.auditRoles.length; ++i)
          $root.Enterprise.AuditRole.encode(
            message.auditRoles[i],
            writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),
          ).ldelim();
      if (message.linkedRecords != null && message.linkedRecords.length)
        for (let i = 0; i < message.linkedRecords.length; ++i)
          $root.Enterprise.LinkedRecord.encode(
            message.linkedRecords[i],
            writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportResponse message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Enterprise.IComplianceReportResponse} message ComplianceReportResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportResponse} ComplianceReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.dateGenerated = reader.int64();
            break;
          }
          case 2: {
            message.runByUserName = reader.string();
            break;
          }
          case 3: {
            message.reportName = reader.string();
            break;
          }
          case 4: {
            message.reportUid = reader.bytes();
            break;
          }
          case 5: {
            message.complianceReportRun = $root.Enterprise.ComplianceReportRun.decode(
              reader,
              reader.uint32(),
            );
            break;
          }
          case 6: {
            if (!(message.userProfiles && message.userProfiles.length)) message.userProfiles = [];
            message.userProfiles.push($root.Enterprise.UserProfile.decode(reader, reader.uint32()));
            break;
          }
          case 7: {
            if (!(message.auditTeams && message.auditTeams.length)) message.auditTeams = [];
            message.auditTeams.push($root.Enterprise.AuditTeam.decode(reader, reader.uint32()));
            break;
          }
          case 8: {
            if (!(message.auditRecords && message.auditRecords.length)) message.auditRecords = [];
            message.auditRecords.push($root.Enterprise.AuditRecord.decode(reader, reader.uint32()));
            break;
          }
          case 9: {
            if (!(message.userRecords && message.userRecords.length)) message.userRecords = [];
            message.userRecords.push($root.Enterprise.UserRecord.decode(reader, reader.uint32()));
            break;
          }
          case 10: {
            if (!(message.sharedFolderRecords && message.sharedFolderRecords.length))
              message.sharedFolderRecords = [];
            message.sharedFolderRecords.push(
              $root.Enterprise.SharedFolderRecord.decode(reader, reader.uint32()),
            );
            break;
          }
          case 11: {
            if (!(message.sharedFolderUsers && message.sharedFolderUsers.length))
              message.sharedFolderUsers = [];
            message.sharedFolderUsers.push(
              $root.Enterprise.SharedFolderUser.decode(reader, reader.uint32()),
            );
            break;
          }
          case 12: {
            if (!(message.sharedFolderTeams && message.sharedFolderTeams.length))
              message.sharedFolderTeams = [];
            message.sharedFolderTeams.push(
              $root.Enterprise.SharedFolderTeam.decode(reader, reader.uint32()),
            );
            break;
          }
          case 13: {
            if (!(message.auditTeamUsers && message.auditTeamUsers.length))
              message.auditTeamUsers = [];
            message.auditTeamUsers.push(
              $root.Enterprise.AuditTeamUser.decode(reader, reader.uint32()),
            );
            break;
          }
          case 14: {
            if (!(message.auditRoles && message.auditRoles.length)) message.auditRoles = [];
            message.auditRoles.push($root.Enterprise.AuditRole.decode(reader, reader.uint32()));
            break;
          }
          case 15: {
            if (!(message.linkedRecords && message.linkedRecords.length))
              message.linkedRecords = [];
            message.linkedRecords.push(
              $root.Enterprise.LinkedRecord.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportResponse} ComplianceReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportResponse message.
     * @function verify
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.dateGenerated != null && message.hasOwnProperty("dateGenerated"))
        if (
          !$util.isInteger(message.dateGenerated) &&
          !(
            message.dateGenerated &&
            $util.isInteger(message.dateGenerated.low) &&
            $util.isInteger(message.dateGenerated.high)
          )
        )
          return "dateGenerated: integer|Long expected";
      if (message.runByUserName != null && message.hasOwnProperty("runByUserName"))
        if (!$util.isString(message.runByUserName)) return "runByUserName: string expected";
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        if (!$util.isString(message.reportName)) return "reportName: string expected";
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        if (
          !(
            (message.reportUid && typeof message.reportUid.length === "number") ||
            $util.isString(message.reportUid)
          )
        )
          return "reportUid: buffer expected";
      if (message.complianceReportRun != null && message.hasOwnProperty("complianceReportRun")) {
        let error = $root.Enterprise.ComplianceReportRun.verify(message.complianceReportRun);
        if (error) return "complianceReportRun." + error;
      }
      if (message.userProfiles != null && message.hasOwnProperty("userProfiles")) {
        if (!Array.isArray(message.userProfiles)) return "userProfiles: array expected";
        for (let i = 0; i < message.userProfiles.length; ++i) {
          let error = $root.Enterprise.UserProfile.verify(message.userProfiles[i]);
          if (error) return "userProfiles." + error;
        }
      }
      if (message.auditTeams != null && message.hasOwnProperty("auditTeams")) {
        if (!Array.isArray(message.auditTeams)) return "auditTeams: array expected";
        for (let i = 0; i < message.auditTeams.length; ++i) {
          let error = $root.Enterprise.AuditTeam.verify(message.auditTeams[i]);
          if (error) return "auditTeams." + error;
        }
      }
      if (message.auditRecords != null && message.hasOwnProperty("auditRecords")) {
        if (!Array.isArray(message.auditRecords)) return "auditRecords: array expected";
        for (let i = 0; i < message.auditRecords.length; ++i) {
          let error = $root.Enterprise.AuditRecord.verify(message.auditRecords[i]);
          if (error) return "auditRecords." + error;
        }
      }
      if (message.userRecords != null && message.hasOwnProperty("userRecords")) {
        if (!Array.isArray(message.userRecords)) return "userRecords: array expected";
        for (let i = 0; i < message.userRecords.length; ++i) {
          let error = $root.Enterprise.UserRecord.verify(message.userRecords[i]);
          if (error) return "userRecords." + error;
        }
      }
      if (message.sharedFolderRecords != null && message.hasOwnProperty("sharedFolderRecords")) {
        if (!Array.isArray(message.sharedFolderRecords))
          return "sharedFolderRecords: array expected";
        for (let i = 0; i < message.sharedFolderRecords.length; ++i) {
          let error = $root.Enterprise.SharedFolderRecord.verify(message.sharedFolderRecords[i]);
          if (error) return "sharedFolderRecords." + error;
        }
      }
      if (message.sharedFolderUsers != null && message.hasOwnProperty("sharedFolderUsers")) {
        if (!Array.isArray(message.sharedFolderUsers)) return "sharedFolderUsers: array expected";
        for (let i = 0; i < message.sharedFolderUsers.length; ++i) {
          let error = $root.Enterprise.SharedFolderUser.verify(message.sharedFolderUsers[i]);
          if (error) return "sharedFolderUsers." + error;
        }
      }
      if (message.sharedFolderTeams != null && message.hasOwnProperty("sharedFolderTeams")) {
        if (!Array.isArray(message.sharedFolderTeams)) return "sharedFolderTeams: array expected";
        for (let i = 0; i < message.sharedFolderTeams.length; ++i) {
          let error = $root.Enterprise.SharedFolderTeam.verify(message.sharedFolderTeams[i]);
          if (error) return "sharedFolderTeams." + error;
        }
      }
      if (message.auditTeamUsers != null && message.hasOwnProperty("auditTeamUsers")) {
        if (!Array.isArray(message.auditTeamUsers)) return "auditTeamUsers: array expected";
        for (let i = 0; i < message.auditTeamUsers.length; ++i) {
          let error = $root.Enterprise.AuditTeamUser.verify(message.auditTeamUsers[i]);
          if (error) return "auditTeamUsers." + error;
        }
      }
      if (message.auditRoles != null && message.hasOwnProperty("auditRoles")) {
        if (!Array.isArray(message.auditRoles)) return "auditRoles: array expected";
        for (let i = 0; i < message.auditRoles.length; ++i) {
          let error = $root.Enterprise.AuditRole.verify(message.auditRoles[i]);
          if (error) return "auditRoles." + error;
        }
      }
      if (message.linkedRecords != null && message.hasOwnProperty("linkedRecords")) {
        if (!Array.isArray(message.linkedRecords)) return "linkedRecords: array expected";
        for (let i = 0; i < message.linkedRecords.length; ++i) {
          let error = $root.Enterprise.LinkedRecord.verify(message.linkedRecords[i]);
          if (error) return "linkedRecords." + error;
        }
      }
      return null;
    };

    /**
     * Creates a ComplianceReportResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportResponse} ComplianceReportResponse
     */
    ComplianceReportResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportResponse) return object;
      let message = new $root.Enterprise.ComplianceReportResponse();
      if (object.dateGenerated != null)
        if ($util.Long)
          (message.dateGenerated = $util.Long.fromValue(object.dateGenerated)).unsigned = false;
        else if (typeof object.dateGenerated === "string")
          message.dateGenerated = parseInt(object.dateGenerated, 10);
        else if (typeof object.dateGenerated === "number")
          message.dateGenerated = object.dateGenerated;
        else if (typeof object.dateGenerated === "object")
          message.dateGenerated = new $util.LongBits(
            object.dateGenerated.low >>> 0,
            object.dateGenerated.high >>> 0,
          ).toNumber();
      if (object.runByUserName != null) message.runByUserName = String(object.runByUserName);
      if (object.reportName != null) message.reportName = String(object.reportName);
      if (object.reportUid != null)
        if (typeof object.reportUid === "string")
          $util.base64.decode(
            object.reportUid,
            (message.reportUid = $util.newBuffer($util.base64.length(object.reportUid))),
            0,
          );
        else if (object.reportUid.length >= 0) message.reportUid = object.reportUid;
      if (object.complianceReportRun != null) {
        if (typeof object.complianceReportRun !== "object")
          throw TypeError(
            ".Enterprise.ComplianceReportResponse.complianceReportRun: object expected",
          );
        message.complianceReportRun = $root.Enterprise.ComplianceReportRun.fromObject(
          object.complianceReportRun,
        );
      }
      if (object.userProfiles) {
        if (!Array.isArray(object.userProfiles))
          throw TypeError(".Enterprise.ComplianceReportResponse.userProfiles: array expected");
        message.userProfiles = [];
        for (let i = 0; i < object.userProfiles.length; ++i) {
          if (typeof object.userProfiles[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.userProfiles: object expected");
          message.userProfiles[i] = $root.Enterprise.UserProfile.fromObject(object.userProfiles[i]);
        }
      }
      if (object.auditTeams) {
        if (!Array.isArray(object.auditTeams))
          throw TypeError(".Enterprise.ComplianceReportResponse.auditTeams: array expected");
        message.auditTeams = [];
        for (let i = 0; i < object.auditTeams.length; ++i) {
          if (typeof object.auditTeams[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.auditTeams: object expected");
          message.auditTeams[i] = $root.Enterprise.AuditTeam.fromObject(object.auditTeams[i]);
        }
      }
      if (object.auditRecords) {
        if (!Array.isArray(object.auditRecords))
          throw TypeError(".Enterprise.ComplianceReportResponse.auditRecords: array expected");
        message.auditRecords = [];
        for (let i = 0; i < object.auditRecords.length; ++i) {
          if (typeof object.auditRecords[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.auditRecords: object expected");
          message.auditRecords[i] = $root.Enterprise.AuditRecord.fromObject(object.auditRecords[i]);
        }
      }
      if (object.userRecords) {
        if (!Array.isArray(object.userRecords))
          throw TypeError(".Enterprise.ComplianceReportResponse.userRecords: array expected");
        message.userRecords = [];
        for (let i = 0; i < object.userRecords.length; ++i) {
          if (typeof object.userRecords[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.userRecords: object expected");
          message.userRecords[i] = $root.Enterprise.UserRecord.fromObject(object.userRecords[i]);
        }
      }
      if (object.sharedFolderRecords) {
        if (!Array.isArray(object.sharedFolderRecords))
          throw TypeError(
            ".Enterprise.ComplianceReportResponse.sharedFolderRecords: array expected",
          );
        message.sharedFolderRecords = [];
        for (let i = 0; i < object.sharedFolderRecords.length; ++i) {
          if (typeof object.sharedFolderRecords[i] !== "object")
            throw TypeError(
              ".Enterprise.ComplianceReportResponse.sharedFolderRecords: object expected",
            );
          message.sharedFolderRecords[i] = $root.Enterprise.SharedFolderRecord.fromObject(
            object.sharedFolderRecords[i],
          );
        }
      }
      if (object.sharedFolderUsers) {
        if (!Array.isArray(object.sharedFolderUsers))
          throw TypeError(".Enterprise.ComplianceReportResponse.sharedFolderUsers: array expected");
        message.sharedFolderUsers = [];
        for (let i = 0; i < object.sharedFolderUsers.length; ++i) {
          if (typeof object.sharedFolderUsers[i] !== "object")
            throw TypeError(
              ".Enterprise.ComplianceReportResponse.sharedFolderUsers: object expected",
            );
          message.sharedFolderUsers[i] = $root.Enterprise.SharedFolderUser.fromObject(
            object.sharedFolderUsers[i],
          );
        }
      }
      if (object.sharedFolderTeams) {
        if (!Array.isArray(object.sharedFolderTeams))
          throw TypeError(".Enterprise.ComplianceReportResponse.sharedFolderTeams: array expected");
        message.sharedFolderTeams = [];
        for (let i = 0; i < object.sharedFolderTeams.length; ++i) {
          if (typeof object.sharedFolderTeams[i] !== "object")
            throw TypeError(
              ".Enterprise.ComplianceReportResponse.sharedFolderTeams: object expected",
            );
          message.sharedFolderTeams[i] = $root.Enterprise.SharedFolderTeam.fromObject(
            object.sharedFolderTeams[i],
          );
        }
      }
      if (object.auditTeamUsers) {
        if (!Array.isArray(object.auditTeamUsers))
          throw TypeError(".Enterprise.ComplianceReportResponse.auditTeamUsers: array expected");
        message.auditTeamUsers = [];
        for (let i = 0; i < object.auditTeamUsers.length; ++i) {
          if (typeof object.auditTeamUsers[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.auditTeamUsers: object expected");
          message.auditTeamUsers[i] = $root.Enterprise.AuditTeamUser.fromObject(
            object.auditTeamUsers[i],
          );
        }
      }
      if (object.auditRoles) {
        if (!Array.isArray(object.auditRoles))
          throw TypeError(".Enterprise.ComplianceReportResponse.auditRoles: array expected");
        message.auditRoles = [];
        for (let i = 0; i < object.auditRoles.length; ++i) {
          if (typeof object.auditRoles[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.auditRoles: object expected");
          message.auditRoles[i] = $root.Enterprise.AuditRole.fromObject(object.auditRoles[i]);
        }
      }
      if (object.linkedRecords) {
        if (!Array.isArray(object.linkedRecords))
          throw TypeError(".Enterprise.ComplianceReportResponse.linkedRecords: array expected");
        message.linkedRecords = [];
        for (let i = 0; i < object.linkedRecords.length; ++i) {
          if (typeof object.linkedRecords[i] !== "object")
            throw TypeError(".Enterprise.ComplianceReportResponse.linkedRecords: object expected");
          message.linkedRecords[i] = $root.Enterprise.LinkedRecord.fromObject(
            object.linkedRecords[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {Enterprise.ComplianceReportResponse} message ComplianceReportResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.userProfiles = [];
        object.auditTeams = [];
        object.auditRecords = [];
        object.userRecords = [];
        object.sharedFolderRecords = [];
        object.sharedFolderUsers = [];
        object.sharedFolderTeams = [];
        object.auditTeamUsers = [];
        object.auditRoles = [];
        object.linkedRecords = [];
      }
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.dateGenerated =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.dateGenerated = options.longs === String ? "0" : 0;
        object.runByUserName = "";
        object.reportName = "";
        if (options.bytes === String) object.reportUid = "";
        else {
          object.reportUid = [];
          if (options.bytes !== Array) object.reportUid = $util.newBuffer(object.reportUid);
        }
        object.complianceReportRun = null;
      }
      if (message.dateGenerated != null && message.hasOwnProperty("dateGenerated"))
        if (typeof message.dateGenerated === "number")
          object.dateGenerated =
            options.longs === String ? String(message.dateGenerated) : message.dateGenerated;
        else
          object.dateGenerated =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.dateGenerated)
              : options.longs === Number
                ? new $util.LongBits(
                    message.dateGenerated.low >>> 0,
                    message.dateGenerated.high >>> 0,
                  ).toNumber()
                : message.dateGenerated;
      if (message.runByUserName != null && message.hasOwnProperty("runByUserName"))
        object.runByUserName = message.runByUserName;
      if (message.reportName != null && message.hasOwnProperty("reportName"))
        object.reportName = message.reportName;
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        object.reportUid =
          options.bytes === String
            ? $util.base64.encode(message.reportUid, 0, message.reportUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.reportUid)
              : message.reportUid;
      if (message.complianceReportRun != null && message.hasOwnProperty("complianceReportRun"))
        object.complianceReportRun = $root.Enterprise.ComplianceReportRun.toObject(
          message.complianceReportRun,
          options,
        );
      if (message.userProfiles && message.userProfiles.length) {
        object.userProfiles = [];
        for (let j = 0; j < message.userProfiles.length; ++j)
          object.userProfiles[j] = $root.Enterprise.UserProfile.toObject(
            message.userProfiles[j],
            options,
          );
      }
      if (message.auditTeams && message.auditTeams.length) {
        object.auditTeams = [];
        for (let j = 0; j < message.auditTeams.length; ++j)
          object.auditTeams[j] = $root.Enterprise.AuditTeam.toObject(
            message.auditTeams[j],
            options,
          );
      }
      if (message.auditRecords && message.auditRecords.length) {
        object.auditRecords = [];
        for (let j = 0; j < message.auditRecords.length; ++j)
          object.auditRecords[j] = $root.Enterprise.AuditRecord.toObject(
            message.auditRecords[j],
            options,
          );
      }
      if (message.userRecords && message.userRecords.length) {
        object.userRecords = [];
        for (let j = 0; j < message.userRecords.length; ++j)
          object.userRecords[j] = $root.Enterprise.UserRecord.toObject(
            message.userRecords[j],
            options,
          );
      }
      if (message.sharedFolderRecords && message.sharedFolderRecords.length) {
        object.sharedFolderRecords = [];
        for (let j = 0; j < message.sharedFolderRecords.length; ++j)
          object.sharedFolderRecords[j] = $root.Enterprise.SharedFolderRecord.toObject(
            message.sharedFolderRecords[j],
            options,
          );
      }
      if (message.sharedFolderUsers && message.sharedFolderUsers.length) {
        object.sharedFolderUsers = [];
        for (let j = 0; j < message.sharedFolderUsers.length; ++j)
          object.sharedFolderUsers[j] = $root.Enterprise.SharedFolderUser.toObject(
            message.sharedFolderUsers[j],
            options,
          );
      }
      if (message.sharedFolderTeams && message.sharedFolderTeams.length) {
        object.sharedFolderTeams = [];
        for (let j = 0; j < message.sharedFolderTeams.length; ++j)
          object.sharedFolderTeams[j] = $root.Enterprise.SharedFolderTeam.toObject(
            message.sharedFolderTeams[j],
            options,
          );
      }
      if (message.auditTeamUsers && message.auditTeamUsers.length) {
        object.auditTeamUsers = [];
        for (let j = 0; j < message.auditTeamUsers.length; ++j)
          object.auditTeamUsers[j] = $root.Enterprise.AuditTeamUser.toObject(
            message.auditTeamUsers[j],
            options,
          );
      }
      if (message.auditRoles && message.auditRoles.length) {
        object.auditRoles = [];
        for (let j = 0; j < message.auditRoles.length; ++j)
          object.auditRoles[j] = $root.Enterprise.AuditRole.toObject(
            message.auditRoles[j],
            options,
          );
      }
      if (message.linkedRecords && message.linkedRecords.length) {
        object.linkedRecords = [];
        for (let j = 0; j < message.linkedRecords.length; ++j)
          object.linkedRecords[j] = $root.Enterprise.LinkedRecord.toObject(
            message.linkedRecords[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this ComplianceReportResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportResponse
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportResponse";
    };

    return ComplianceReportResponse;
  })();

  Enterprise.AuditRecord = (function () {
    /**
     * Properties of an AuditRecord.
     * @memberof Enterprise
     * @interface IAuditRecord
     * @property {Uint8Array|null} [recordUid] AuditRecord recordUid
     * @property {Uint8Array|null} [auditData] AuditRecord auditData
     * @property {boolean|null} [hasAttachments] AuditRecord hasAttachments
     * @property {boolean|null} [inTrash] AuditRecord inTrash
     * @property {number|null} [treeLeft] AuditRecord treeLeft
     * @property {number|null} [treeRight] AuditRecord treeRight
     */

    /**
     * Constructs a new AuditRecord.
     * @memberof Enterprise
     * @classdesc Represents an AuditRecord.
     * @implements IAuditRecord
     * @constructor
     * @param {Enterprise.IAuditRecord=} [properties] Properties to set
     */
    function AuditRecord(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditRecord recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.recordUid = $util.newBuffer([]);

    /**
     * AuditRecord auditData.
     * @member {Uint8Array} auditData
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.auditData = $util.newBuffer([]);

    /**
     * AuditRecord hasAttachments.
     * @member {boolean} hasAttachments
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.hasAttachments = false;

    /**
     * AuditRecord inTrash.
     * @member {boolean} inTrash
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.inTrash = false;

    /**
     * AuditRecord treeLeft.
     * @member {number} treeLeft
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.treeLeft = 0;

    /**
     * AuditRecord treeRight.
     * @member {number} treeRight
     * @memberof Enterprise.AuditRecord
     * @instance
     */
    AuditRecord.prototype.treeRight = 0;

    /**
     * Creates a new AuditRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Enterprise.IAuditRecord=} [properties] Properties to set
     * @returns {Enterprise.AuditRecord} AuditRecord instance
     */
    AuditRecord.create = function create(properties) {
      return new AuditRecord(properties);
    };

    /**
     * Encodes the specified AuditRecord message. Does not implicitly {@link Enterprise.AuditRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Enterprise.IAuditRecord} message AuditRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.recordUid);
      if (message.auditData != null && Object.hasOwnProperty.call(message, "auditData"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.auditData);
      if (message.hasAttachments != null && Object.hasOwnProperty.call(message, "hasAttachments"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.hasAttachments);
      if (message.inTrash != null && Object.hasOwnProperty.call(message, "inTrash"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.inTrash);
      if (message.treeLeft != null && Object.hasOwnProperty.call(message, "treeLeft"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.treeLeft);
      if (message.treeRight != null && Object.hasOwnProperty.call(message, "treeRight"))
        writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.treeRight);
      return writer;
    };

    /**
     * Encodes the specified AuditRecord message, length delimited. Does not implicitly {@link Enterprise.AuditRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Enterprise.IAuditRecord} message AuditRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditRecord} AuditRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.recordUid = reader.bytes();
            break;
          }
          case 2: {
            message.auditData = reader.bytes();
            break;
          }
          case 3: {
            message.hasAttachments = reader.bool();
            break;
          }
          case 4: {
            message.inTrash = reader.bool();
            break;
          }
          case 5: {
            message.treeLeft = reader.int32();
            break;
          }
          case 6: {
            message.treeRight = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditRecord} AuditRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditRecord message.
     * @function verify
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.auditData != null && message.hasOwnProperty("auditData"))
        if (
          !(
            (message.auditData && typeof message.auditData.length === "number") ||
            $util.isString(message.auditData)
          )
        )
          return "auditData: buffer expected";
      if (message.hasAttachments != null && message.hasOwnProperty("hasAttachments"))
        if (typeof message.hasAttachments !== "boolean") return "hasAttachments: boolean expected";
      if (message.inTrash != null && message.hasOwnProperty("inTrash"))
        if (typeof message.inTrash !== "boolean") return "inTrash: boolean expected";
      if (message.treeLeft != null && message.hasOwnProperty("treeLeft"))
        if (!$util.isInteger(message.treeLeft)) return "treeLeft: integer expected";
      if (message.treeRight != null && message.hasOwnProperty("treeRight"))
        if (!$util.isInteger(message.treeRight)) return "treeRight: integer expected";
      return null;
    };

    /**
     * Creates an AuditRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditRecord} AuditRecord
     */
    AuditRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditRecord) return object;
      let message = new $root.Enterprise.AuditRecord();
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.auditData != null)
        if (typeof object.auditData === "string")
          $util.base64.decode(
            object.auditData,
            (message.auditData = $util.newBuffer($util.base64.length(object.auditData))),
            0,
          );
        else if (object.auditData.length >= 0) message.auditData = object.auditData;
      if (object.hasAttachments != null) message.hasAttachments = Boolean(object.hasAttachments);
      if (object.inTrash != null) message.inTrash = Boolean(object.inTrash);
      if (object.treeLeft != null) message.treeLeft = object.treeLeft | 0;
      if (object.treeRight != null) message.treeRight = object.treeRight | 0;
      return message;
    };

    /**
     * Creates a plain object from an AuditRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {Enterprise.AuditRecord} message AuditRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        if (options.bytes === String) object.auditData = "";
        else {
          object.auditData = [];
          if (options.bytes !== Array) object.auditData = $util.newBuffer(object.auditData);
        }
        object.hasAttachments = false;
        object.inTrash = false;
        object.treeLeft = 0;
        object.treeRight = 0;
      }
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.auditData != null && message.hasOwnProperty("auditData"))
        object.auditData =
          options.bytes === String
            ? $util.base64.encode(message.auditData, 0, message.auditData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.auditData)
              : message.auditData;
      if (message.hasAttachments != null && message.hasOwnProperty("hasAttachments"))
        object.hasAttachments = message.hasAttachments;
      if (message.inTrash != null && message.hasOwnProperty("inTrash"))
        object.inTrash = message.inTrash;
      if (message.treeLeft != null && message.hasOwnProperty("treeLeft"))
        object.treeLeft = message.treeLeft;
      if (message.treeRight != null && message.hasOwnProperty("treeRight"))
        object.treeRight = message.treeRight;
      return object;
    };

    /**
     * Converts this AuditRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditRecord
     * @function getTypeUrl
     * @memberof Enterprise.AuditRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditRecord";
    };

    return AuditRecord;
  })();

  Enterprise.AuditRole = (function () {
    /**
     * Properties of an AuditRole.
     * @memberof Enterprise
     * @interface IAuditRole
     * @property {number|Long|null} [roleId] AuditRole roleId
     * @property {Uint8Array|null} [encryptedData] AuditRole encryptedData
     * @property {boolean|null} [restrictShareOutsideEnterprise] AuditRole restrictShareOutsideEnterprise
     * @property {boolean|null} [restrictShareAll] AuditRole restrictShareAll
     * @property {boolean|null} [restrictShareOfAttachments] AuditRole restrictShareOfAttachments
     * @property {boolean|null} [restrictMaskPasswordsWhileEditing] AuditRole restrictMaskPasswordsWhileEditing
     * @property {Array.<Enterprise.IRoleNodeManagement>|null} [roleNodeManagements] AuditRole roleNodeManagements
     */

    /**
     * Constructs a new AuditRole.
     * @memberof Enterprise
     * @classdesc Represents an AuditRole.
     * @implements IAuditRole
     * @constructor
     * @param {Enterprise.IAuditRole=} [properties] Properties to set
     */
    function AuditRole(properties) {
      this.roleNodeManagements = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditRole roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * AuditRole encryptedData.
     * @member {Uint8Array} encryptedData
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.encryptedData = $util.newBuffer([]);

    /**
     * AuditRole restrictShareOutsideEnterprise.
     * @member {boolean} restrictShareOutsideEnterprise
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.restrictShareOutsideEnterprise = false;

    /**
     * AuditRole restrictShareAll.
     * @member {boolean} restrictShareAll
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.restrictShareAll = false;

    /**
     * AuditRole restrictShareOfAttachments.
     * @member {boolean} restrictShareOfAttachments
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.restrictShareOfAttachments = false;

    /**
     * AuditRole restrictMaskPasswordsWhileEditing.
     * @member {boolean} restrictMaskPasswordsWhileEditing
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.restrictMaskPasswordsWhileEditing = false;

    /**
     * AuditRole roleNodeManagements.
     * @member {Array.<Enterprise.IRoleNodeManagement>} roleNodeManagements
     * @memberof Enterprise.AuditRole
     * @instance
     */
    AuditRole.prototype.roleNodeManagements = $util.emptyArray;

    /**
     * Creates a new AuditRole instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Enterprise.IAuditRole=} [properties] Properties to set
     * @returns {Enterprise.AuditRole} AuditRole instance
     */
    AuditRole.create = function create(properties) {
      return new AuditRole(properties);
    };

    /**
     * Encodes the specified AuditRole message. Does not implicitly {@link Enterprise.AuditRole.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Enterprise.IAuditRole} message AuditRole message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditRole.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.roleId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.encryptedData);
      if (
        message.restrictShareOutsideEnterprise != null &&
        Object.hasOwnProperty.call(message, "restrictShareOutsideEnterprise")
      )
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.restrictShareOutsideEnterprise);
      if (
        message.restrictShareAll != null &&
        Object.hasOwnProperty.call(message, "restrictShareAll")
      )
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.restrictShareAll);
      if (
        message.restrictShareOfAttachments != null &&
        Object.hasOwnProperty.call(message, "restrictShareOfAttachments")
      )
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.restrictShareOfAttachments);
      if (
        message.restrictMaskPasswordsWhileEditing != null &&
        Object.hasOwnProperty.call(message, "restrictMaskPasswordsWhileEditing")
      )
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.restrictMaskPasswordsWhileEditing);
      if (message.roleNodeManagements != null && message.roleNodeManagements.length)
        for (let i = 0; i < message.roleNodeManagements.length; ++i)
          $root.Enterprise.RoleNodeManagement.encode(
            message.roleNodeManagements[i],
            writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified AuditRole message, length delimited. Does not implicitly {@link Enterprise.AuditRole.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Enterprise.IAuditRole} message AuditRole message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditRole.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditRole message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditRole
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditRole} AuditRole
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditRole.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditRole();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.roleId = reader.int64();
            break;
          }
          case 2: {
            message.encryptedData = reader.bytes();
            break;
          }
          case 3: {
            message.restrictShareOutsideEnterprise = reader.bool();
            break;
          }
          case 4: {
            message.restrictShareAll = reader.bool();
            break;
          }
          case 5: {
            message.restrictShareOfAttachments = reader.bool();
            break;
          }
          case 6: {
            message.restrictMaskPasswordsWhileEditing = reader.bool();
            break;
          }
          case 7: {
            if (!(message.roleNodeManagements && message.roleNodeManagements.length))
              message.roleNodeManagements = [];
            message.roleNodeManagements.push(
              $root.Enterprise.RoleNodeManagement.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditRole message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditRole
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditRole} AuditRole
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditRole.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditRole message.
     * @function verify
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditRole.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (
          !(
            (message.encryptedData && typeof message.encryptedData.length === "number") ||
            $util.isString(message.encryptedData)
          )
        )
          return "encryptedData: buffer expected";
      if (
        message.restrictShareOutsideEnterprise != null &&
        message.hasOwnProperty("restrictShareOutsideEnterprise")
      )
        if (typeof message.restrictShareOutsideEnterprise !== "boolean")
          return "restrictShareOutsideEnterprise: boolean expected";
      if (message.restrictShareAll != null && message.hasOwnProperty("restrictShareAll"))
        if (typeof message.restrictShareAll !== "boolean")
          return "restrictShareAll: boolean expected";
      if (
        message.restrictShareOfAttachments != null &&
        message.hasOwnProperty("restrictShareOfAttachments")
      )
        if (typeof message.restrictShareOfAttachments !== "boolean")
          return "restrictShareOfAttachments: boolean expected";
      if (
        message.restrictMaskPasswordsWhileEditing != null &&
        message.hasOwnProperty("restrictMaskPasswordsWhileEditing")
      )
        if (typeof message.restrictMaskPasswordsWhileEditing !== "boolean")
          return "restrictMaskPasswordsWhileEditing: boolean expected";
      if (message.roleNodeManagements != null && message.hasOwnProperty("roleNodeManagements")) {
        if (!Array.isArray(message.roleNodeManagements))
          return "roleNodeManagements: array expected";
        for (let i = 0; i < message.roleNodeManagements.length; ++i) {
          let error = $root.Enterprise.RoleNodeManagement.verify(message.roleNodeManagements[i]);
          if (error) return "roleNodeManagements." + error;
        }
      }
      return null;
    };

    /**
     * Creates an AuditRole message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditRole} AuditRole
     */
    AuditRole.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditRole) return object;
      let message = new $root.Enterprise.AuditRole();
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null)
        if (typeof object.encryptedData === "string")
          $util.base64.decode(
            object.encryptedData,
            (message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData))),
            0,
          );
        else if (object.encryptedData.length >= 0) message.encryptedData = object.encryptedData;
      if (object.restrictShareOutsideEnterprise != null)
        message.restrictShareOutsideEnterprise = Boolean(object.restrictShareOutsideEnterprise);
      if (object.restrictShareAll != null)
        message.restrictShareAll = Boolean(object.restrictShareAll);
      if (object.restrictShareOfAttachments != null)
        message.restrictShareOfAttachments = Boolean(object.restrictShareOfAttachments);
      if (object.restrictMaskPasswordsWhileEditing != null)
        message.restrictMaskPasswordsWhileEditing = Boolean(
          object.restrictMaskPasswordsWhileEditing,
        );
      if (object.roleNodeManagements) {
        if (!Array.isArray(object.roleNodeManagements))
          throw TypeError(".Enterprise.AuditRole.roleNodeManagements: array expected");
        message.roleNodeManagements = [];
        for (let i = 0; i < object.roleNodeManagements.length; ++i) {
          if (typeof object.roleNodeManagements[i] !== "object")
            throw TypeError(".Enterprise.AuditRole.roleNodeManagements: object expected");
          message.roleNodeManagements[i] = $root.Enterprise.RoleNodeManagement.fromObject(
            object.roleNodeManagements[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an AuditRole message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditRole
     * @static
     * @param {Enterprise.AuditRole} message AuditRole
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditRole.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleNodeManagements = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
        if (options.bytes === String) object.encryptedData = "";
        else {
          object.encryptedData = [];
          if (options.bytes !== Array) object.encryptedData = $util.newBuffer(object.encryptedData);
        }
        object.restrictShareOutsideEnterprise = false;
        object.restrictShareAll = false;
        object.restrictShareOfAttachments = false;
        object.restrictMaskPasswordsWhileEditing = false;
      }
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData =
          options.bytes === String
            ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedData)
              : message.encryptedData;
      if (
        message.restrictShareOutsideEnterprise != null &&
        message.hasOwnProperty("restrictShareOutsideEnterprise")
      )
        object.restrictShareOutsideEnterprise = message.restrictShareOutsideEnterprise;
      if (message.restrictShareAll != null && message.hasOwnProperty("restrictShareAll"))
        object.restrictShareAll = message.restrictShareAll;
      if (
        message.restrictShareOfAttachments != null &&
        message.hasOwnProperty("restrictShareOfAttachments")
      )
        object.restrictShareOfAttachments = message.restrictShareOfAttachments;
      if (
        message.restrictMaskPasswordsWhileEditing != null &&
        message.hasOwnProperty("restrictMaskPasswordsWhileEditing")
      )
        object.restrictMaskPasswordsWhileEditing = message.restrictMaskPasswordsWhileEditing;
      if (message.roleNodeManagements && message.roleNodeManagements.length) {
        object.roleNodeManagements = [];
        for (let j = 0; j < message.roleNodeManagements.length; ++j)
          object.roleNodeManagements[j] = $root.Enterprise.RoleNodeManagement.toObject(
            message.roleNodeManagements[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this AuditRole to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditRole
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditRole.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditRole
     * @function getTypeUrl
     * @memberof Enterprise.AuditRole
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditRole";
    };

    return AuditRole;
  })();

  Enterprise.RoleNodeManagement = (function () {
    /**
     * Properties of a RoleNodeManagement.
     * @memberof Enterprise
     * @interface IRoleNodeManagement
     * @property {number|null} [treeLeft] RoleNodeManagement treeLeft
     * @property {number|null} [treeRight] RoleNodeManagement treeRight
     * @property {boolean|null} [cascade] RoleNodeManagement cascade
     * @property {number|null} [privileges] RoleNodeManagement privileges
     */

    /**
     * Constructs a new RoleNodeManagement.
     * @memberof Enterprise
     * @classdesc Represents a RoleNodeManagement.
     * @implements IRoleNodeManagement
     * @constructor
     * @param {Enterprise.IRoleNodeManagement=} [properties] Properties to set
     */
    function RoleNodeManagement(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RoleNodeManagement treeLeft.
     * @member {number} treeLeft
     * @memberof Enterprise.RoleNodeManagement
     * @instance
     */
    RoleNodeManagement.prototype.treeLeft = 0;

    /**
     * RoleNodeManagement treeRight.
     * @member {number} treeRight
     * @memberof Enterprise.RoleNodeManagement
     * @instance
     */
    RoleNodeManagement.prototype.treeRight = 0;

    /**
     * RoleNodeManagement cascade.
     * @member {boolean} cascade
     * @memberof Enterprise.RoleNodeManagement
     * @instance
     */
    RoleNodeManagement.prototype.cascade = false;

    /**
     * RoleNodeManagement privileges.
     * @member {number} privileges
     * @memberof Enterprise.RoleNodeManagement
     * @instance
     */
    RoleNodeManagement.prototype.privileges = 0;

    /**
     * Creates a new RoleNodeManagement instance using the specified properties.
     * @function create
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Enterprise.IRoleNodeManagement=} [properties] Properties to set
     * @returns {Enterprise.RoleNodeManagement} RoleNodeManagement instance
     */
    RoleNodeManagement.create = function create(properties) {
      return new RoleNodeManagement(properties);
    };

    /**
     * Encodes the specified RoleNodeManagement message. Does not implicitly {@link Enterprise.RoleNodeManagement.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Enterprise.IRoleNodeManagement} message RoleNodeManagement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleNodeManagement.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.treeLeft != null && Object.hasOwnProperty.call(message, "treeLeft"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.treeLeft);
      if (message.treeRight != null && Object.hasOwnProperty.call(message, "treeRight"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.treeRight);
      if (message.cascade != null && Object.hasOwnProperty.call(message, "cascade"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.cascade);
      if (message.privileges != null && Object.hasOwnProperty.call(message, "privileges"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.privileges);
      return writer;
    };

    /**
     * Encodes the specified RoleNodeManagement message, length delimited. Does not implicitly {@link Enterprise.RoleNodeManagement.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Enterprise.IRoleNodeManagement} message RoleNodeManagement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RoleNodeManagement.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RoleNodeManagement message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RoleNodeManagement} RoleNodeManagement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleNodeManagement.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RoleNodeManagement();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.treeLeft = reader.int32();
            break;
          }
          case 2: {
            message.treeRight = reader.int32();
            break;
          }
          case 3: {
            message.cascade = reader.bool();
            break;
          }
          case 4: {
            message.privileges = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RoleNodeManagement message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RoleNodeManagement} RoleNodeManagement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RoleNodeManagement.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RoleNodeManagement message.
     * @function verify
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RoleNodeManagement.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.treeLeft != null && message.hasOwnProperty("treeLeft"))
        if (!$util.isInteger(message.treeLeft)) return "treeLeft: integer expected";
      if (message.treeRight != null && message.hasOwnProperty("treeRight"))
        if (!$util.isInteger(message.treeRight)) return "treeRight: integer expected";
      if (message.cascade != null && message.hasOwnProperty("cascade"))
        if (typeof message.cascade !== "boolean") return "cascade: boolean expected";
      if (message.privileges != null && message.hasOwnProperty("privileges"))
        if (!$util.isInteger(message.privileges)) return "privileges: integer expected";
      return null;
    };

    /**
     * Creates a RoleNodeManagement message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RoleNodeManagement} RoleNodeManagement
     */
    RoleNodeManagement.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RoleNodeManagement) return object;
      let message = new $root.Enterprise.RoleNodeManagement();
      if (object.treeLeft != null) message.treeLeft = object.treeLeft | 0;
      if (object.treeRight != null) message.treeRight = object.treeRight | 0;
      if (object.cascade != null) message.cascade = Boolean(object.cascade);
      if (object.privileges != null) message.privileges = object.privileges | 0;
      return message;
    };

    /**
     * Creates a plain object from a RoleNodeManagement message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {Enterprise.RoleNodeManagement} message RoleNodeManagement
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RoleNodeManagement.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.treeLeft = 0;
        object.treeRight = 0;
        object.cascade = false;
        object.privileges = 0;
      }
      if (message.treeLeft != null && message.hasOwnProperty("treeLeft"))
        object.treeLeft = message.treeLeft;
      if (message.treeRight != null && message.hasOwnProperty("treeRight"))
        object.treeRight = message.treeRight;
      if (message.cascade != null && message.hasOwnProperty("cascade"))
        object.cascade = message.cascade;
      if (message.privileges != null && message.hasOwnProperty("privileges"))
        object.privileges = message.privileges;
      return object;
    };

    /**
     * Converts this RoleNodeManagement to JSON.
     * @function toJSON
     * @memberof Enterprise.RoleNodeManagement
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RoleNodeManagement.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RoleNodeManagement
     * @function getTypeUrl
     * @memberof Enterprise.RoleNodeManagement
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RoleNodeManagement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RoleNodeManagement";
    };

    return RoleNodeManagement;
  })();

  Enterprise.UserProfile = (function () {
    /**
     * Properties of a UserProfile.
     * @memberof Enterprise
     * @interface IUserProfile
     * @property {number|Long|null} [enterpriseUserId] UserProfile enterpriseUserId
     * @property {string|null} [fullName] UserProfile fullName
     * @property {string|null} [jobTitle] UserProfile jobTitle
     * @property {string|null} [email] UserProfile email
     * @property {Array.<number|Long>|null} [roleIds] UserProfile roleIds
     */

    /**
     * Constructs a new UserProfile.
     * @memberof Enterprise
     * @classdesc Represents a UserProfile.
     * @implements IUserProfile
     * @constructor
     * @param {Enterprise.IUserProfile=} [properties] Properties to set
     */
    function UserProfile(properties) {
      this.roleIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserProfile enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserProfile
     * @instance
     */
    UserProfile.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserProfile fullName.
     * @member {string} fullName
     * @memberof Enterprise.UserProfile
     * @instance
     */
    UserProfile.prototype.fullName = "";

    /**
     * UserProfile jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.UserProfile
     * @instance
     */
    UserProfile.prototype.jobTitle = "";

    /**
     * UserProfile email.
     * @member {string} email
     * @memberof Enterprise.UserProfile
     * @instance
     */
    UserProfile.prototype.email = "";

    /**
     * UserProfile roleIds.
     * @member {Array.<number|Long>} roleIds
     * @memberof Enterprise.UserProfile
     * @instance
     */
    UserProfile.prototype.roleIds = $util.emptyArray;

    /**
     * Creates a new UserProfile instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Enterprise.IUserProfile=} [properties] Properties to set
     * @returns {Enterprise.UserProfile} UserProfile instance
     */
    UserProfile.create = function create(properties) {
      return new UserProfile(properties);
    };

    /**
     * Encodes the specified UserProfile message. Does not implicitly {@link Enterprise.UserProfile.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Enterprise.IUserProfile} message UserProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfile.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.jobTitle);
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.email);
      if (message.roleIds != null && message.roleIds.length) {
        writer.uint32(/* id 5, wireType 2 =*/ 42).fork();
        for (let i = 0; i < message.roleIds.length; ++i) writer.int64(message.roleIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified UserProfile message, length delimited. Does not implicitly {@link Enterprise.UserProfile.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Enterprise.IUserProfile} message UserProfile message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfile.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserProfile message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserProfile} UserProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfile.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserProfile();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.fullName = reader.string();
            break;
          }
          case 3: {
            message.jobTitle = reader.string();
            break;
          }
          case 4: {
            message.email = reader.string();
            break;
          }
          case 5: {
            if (!(message.roleIds && message.roleIds.length)) message.roleIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.roleIds.push(reader.int64());
            } else message.roleIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserProfile message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserProfile} UserProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfile.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserProfile message.
     * @function verify
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserProfile.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.roleIds != null && message.hasOwnProperty("roleIds")) {
        if (!Array.isArray(message.roleIds)) return "roleIds: array expected";
        for (let i = 0; i < message.roleIds.length; ++i)
          if (
            !$util.isInteger(message.roleIds[i]) &&
            !(
              message.roleIds[i] &&
              $util.isInteger(message.roleIds[i].low) &&
              $util.isInteger(message.roleIds[i].high)
            )
          )
            return "roleIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a UserProfile message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserProfile} UserProfile
     */
    UserProfile.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserProfile) return object;
      let message = new $root.Enterprise.UserProfile();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.email != null) message.email = String(object.email);
      if (object.roleIds) {
        if (!Array.isArray(object.roleIds))
          throw TypeError(".Enterprise.UserProfile.roleIds: array expected");
        message.roleIds = [];
        for (let i = 0; i < object.roleIds.length; ++i)
          if ($util.Long)
            (message.roleIds[i] = $util.Long.fromValue(object.roleIds[i])).unsigned = false;
          else if (typeof object.roleIds[i] === "string")
            message.roleIds[i] = parseInt(object.roleIds[i], 10);
          else if (typeof object.roleIds[i] === "number") message.roleIds[i] = object.roleIds[i];
          else if (typeof object.roleIds[i] === "object")
            message.roleIds[i] = new $util.LongBits(
              object.roleIds[i].low >>> 0,
              object.roleIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a UserProfile message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserProfile
     * @static
     * @param {Enterprise.UserProfile} message UserProfile
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserProfile.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.roleIds = [];
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.fullName = "";
        object.jobTitle = "";
        object.email = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.roleIds && message.roleIds.length) {
        object.roleIds = [];
        for (let j = 0; j < message.roleIds.length; ++j)
          if (typeof message.roleIds[j] === "number")
            object.roleIds[j] =
              options.longs === String ? String(message.roleIds[j]) : message.roleIds[j];
          else
            object.roleIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.roleIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.roleIds[j].low >>> 0,
                      message.roleIds[j].high >>> 0,
                    ).toNumber()
                  : message.roleIds[j];
      }
      return object;
    };

    /**
     * Converts this UserProfile to JSON.
     * @function toJSON
     * @memberof Enterprise.UserProfile
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserProfile.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserProfile
     * @function getTypeUrl
     * @memberof Enterprise.UserProfile
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserProfile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserProfile";
    };

    return UserProfile;
  })();

  Enterprise.RecordPermission = (function () {
    /**
     * Properties of a RecordPermission.
     * @memberof Enterprise
     * @interface IRecordPermission
     * @property {Uint8Array|null} [recordUid] RecordPermission recordUid
     * @property {number|null} [permissionBits] RecordPermission permissionBits
     */

    /**
     * Constructs a new RecordPermission.
     * @memberof Enterprise
     * @classdesc Represents a RecordPermission.
     * @implements IRecordPermission
     * @constructor
     * @param {Enterprise.IRecordPermission=} [properties] Properties to set
     */
    function RecordPermission(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * RecordPermission recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.RecordPermission
     * @instance
     */
    RecordPermission.prototype.recordUid = $util.newBuffer([]);

    /**
     * RecordPermission permissionBits.
     * @member {number} permissionBits
     * @memberof Enterprise.RecordPermission
     * @instance
     */
    RecordPermission.prototype.permissionBits = 0;

    /**
     * Creates a new RecordPermission instance using the specified properties.
     * @function create
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Enterprise.IRecordPermission=} [properties] Properties to set
     * @returns {Enterprise.RecordPermission} RecordPermission instance
     */
    RecordPermission.create = function create(properties) {
      return new RecordPermission(properties);
    };

    /**
     * Encodes the specified RecordPermission message. Does not implicitly {@link Enterprise.RecordPermission.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Enterprise.IRecordPermission} message RecordPermission message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordPermission.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.recordUid);
      if (message.permissionBits != null && Object.hasOwnProperty.call(message, "permissionBits"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.permissionBits);
      return writer;
    };

    /**
     * Encodes the specified RecordPermission message, length delimited. Does not implicitly {@link Enterprise.RecordPermission.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Enterprise.IRecordPermission} message RecordPermission message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RecordPermission.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RecordPermission message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.RecordPermission} RecordPermission
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordPermission.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.RecordPermission();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.recordUid = reader.bytes();
            break;
          }
          case 2: {
            message.permissionBits = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a RecordPermission message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.RecordPermission} RecordPermission
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RecordPermission.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RecordPermission message.
     * @function verify
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RecordPermission.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.permissionBits != null && message.hasOwnProperty("permissionBits"))
        if (!$util.isInteger(message.permissionBits)) return "permissionBits: integer expected";
      return null;
    };

    /**
     * Creates a RecordPermission message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.RecordPermission} RecordPermission
     */
    RecordPermission.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.RecordPermission) return object;
      let message = new $root.Enterprise.RecordPermission();
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.permissionBits != null) message.permissionBits = object.permissionBits | 0;
      return message;
    };

    /**
     * Creates a plain object from a RecordPermission message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {Enterprise.RecordPermission} message RecordPermission
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RecordPermission.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        object.permissionBits = 0;
      }
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.permissionBits != null && message.hasOwnProperty("permissionBits"))
        object.permissionBits = message.permissionBits;
      return object;
    };

    /**
     * Converts this RecordPermission to JSON.
     * @function toJSON
     * @memberof Enterprise.RecordPermission
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RecordPermission.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RecordPermission
     * @function getTypeUrl
     * @memberof Enterprise.RecordPermission
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RecordPermission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.RecordPermission";
    };

    return RecordPermission;
  })();

  Enterprise.UserRecord = (function () {
    /**
     * Properties of a UserRecord.
     * @memberof Enterprise
     * @interface IUserRecord
     * @property {number|Long|null} [enterpriseUserId] UserRecord enterpriseUserId
     * @property {Array.<Enterprise.IRecordPermission>|null} [recordPermissions] UserRecord recordPermissions
     */

    /**
     * Constructs a new UserRecord.
     * @memberof Enterprise
     * @classdesc Represents a UserRecord.
     * @implements IUserRecord
     * @constructor
     * @param {Enterprise.IUserRecord=} [properties] Properties to set
     */
    function UserRecord(properties) {
      this.recordPermissions = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserRecord enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.UserRecord
     * @instance
     */
    UserRecord.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * UserRecord recordPermissions.
     * @member {Array.<Enterprise.IRecordPermission>} recordPermissions
     * @memberof Enterprise.UserRecord
     * @instance
     */
    UserRecord.prototype.recordPermissions = $util.emptyArray;

    /**
     * Creates a new UserRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Enterprise.IUserRecord=} [properties] Properties to set
     * @returns {Enterprise.UserRecord} UserRecord instance
     */
    UserRecord.create = function create(properties) {
      return new UserRecord(properties);
    };

    /**
     * Encodes the specified UserRecord message. Does not implicitly {@link Enterprise.UserRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Enterprise.IUserRecord} message UserRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.recordPermissions != null && message.recordPermissions.length)
        for (let i = 0; i < message.recordPermissions.length; ++i)
          $root.Enterprise.RecordPermission.encode(
            message.recordPermissions[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified UserRecord message, length delimited. Does not implicitly {@link Enterprise.UserRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Enterprise.IUserRecord} message UserRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserRecord} UserRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.recordPermissions && message.recordPermissions.length))
              message.recordPermissions = [];
            message.recordPermissions.push(
              $root.Enterprise.RecordPermission.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserRecord} UserRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserRecord message.
     * @function verify
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.recordPermissions != null && message.hasOwnProperty("recordPermissions")) {
        if (!Array.isArray(message.recordPermissions)) return "recordPermissions: array expected";
        for (let i = 0; i < message.recordPermissions.length; ++i) {
          let error = $root.Enterprise.RecordPermission.verify(message.recordPermissions[i]);
          if (error) return "recordPermissions." + error;
        }
      }
      return null;
    };

    /**
     * Creates a UserRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserRecord} UserRecord
     */
    UserRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserRecord) return object;
      let message = new $root.Enterprise.UserRecord();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.recordPermissions) {
        if (!Array.isArray(object.recordPermissions))
          throw TypeError(".Enterprise.UserRecord.recordPermissions: array expected");
        message.recordPermissions = [];
        for (let i = 0; i < object.recordPermissions.length; ++i) {
          if (typeof object.recordPermissions[i] !== "object")
            throw TypeError(".Enterprise.UserRecord.recordPermissions: object expected");
          message.recordPermissions[i] = $root.Enterprise.RecordPermission.fromObject(
            object.recordPermissions[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a UserRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserRecord
     * @static
     * @param {Enterprise.UserRecord} message UserRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.recordPermissions = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.recordPermissions && message.recordPermissions.length) {
        object.recordPermissions = [];
        for (let j = 0; j < message.recordPermissions.length; ++j)
          object.recordPermissions[j] = $root.Enterprise.RecordPermission.toObject(
            message.recordPermissions[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this UserRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.UserRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserRecord
     * @function getTypeUrl
     * @memberof Enterprise.UserRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserRecord";
    };

    return UserRecord;
  })();

  Enterprise.AuditTeam = (function () {
    /**
     * Properties of an AuditTeam.
     * @memberof Enterprise
     * @interface IAuditTeam
     * @property {Uint8Array|null} [teamUid] AuditTeam teamUid
     * @property {string|null} [teamName] AuditTeam teamName
     * @property {boolean|null} [restrictEdit] AuditTeam restrictEdit
     * @property {boolean|null} [restrictShare] AuditTeam restrictShare
     */

    /**
     * Constructs a new AuditTeam.
     * @memberof Enterprise
     * @classdesc Represents an AuditTeam.
     * @implements IAuditTeam
     * @constructor
     * @param {Enterprise.IAuditTeam=} [properties] Properties to set
     */
    function AuditTeam(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditTeam teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.AuditTeam
     * @instance
     */
    AuditTeam.prototype.teamUid = $util.newBuffer([]);

    /**
     * AuditTeam teamName.
     * @member {string} teamName
     * @memberof Enterprise.AuditTeam
     * @instance
     */
    AuditTeam.prototype.teamName = "";

    /**
     * AuditTeam restrictEdit.
     * @member {boolean} restrictEdit
     * @memberof Enterprise.AuditTeam
     * @instance
     */
    AuditTeam.prototype.restrictEdit = false;

    /**
     * AuditTeam restrictShare.
     * @member {boolean} restrictShare
     * @memberof Enterprise.AuditTeam
     * @instance
     */
    AuditTeam.prototype.restrictShare = false;

    /**
     * Creates a new AuditTeam instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Enterprise.IAuditTeam=} [properties] Properties to set
     * @returns {Enterprise.AuditTeam} AuditTeam instance
     */
    AuditTeam.create = function create(properties) {
      return new AuditTeam(properties);
    };

    /**
     * Encodes the specified AuditTeam message. Does not implicitly {@link Enterprise.AuditTeam.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Enterprise.IAuditTeam} message AuditTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditTeam.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.teamName != null && Object.hasOwnProperty.call(message, "teamName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.teamName);
      if (message.restrictEdit != null && Object.hasOwnProperty.call(message, "restrictEdit"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.restrictEdit);
      if (message.restrictShare != null && Object.hasOwnProperty.call(message, "restrictShare"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.restrictShare);
      return writer;
    };

    /**
     * Encodes the specified AuditTeam message, length delimited. Does not implicitly {@link Enterprise.AuditTeam.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Enterprise.IAuditTeam} message AuditTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditTeam.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditTeam message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditTeam} AuditTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditTeam.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditTeam();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            message.teamName = reader.string();
            break;
          }
          case 3: {
            message.restrictEdit = reader.bool();
            break;
          }
          case 4: {
            message.restrictShare = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditTeam message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditTeam} AuditTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditTeam.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditTeam message.
     * @function verify
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditTeam.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.teamName != null && message.hasOwnProperty("teamName"))
        if (!$util.isString(message.teamName)) return "teamName: string expected";
      if (message.restrictEdit != null && message.hasOwnProperty("restrictEdit"))
        if (typeof message.restrictEdit !== "boolean") return "restrictEdit: boolean expected";
      if (message.restrictShare != null && message.hasOwnProperty("restrictShare"))
        if (typeof message.restrictShare !== "boolean") return "restrictShare: boolean expected";
      return null;
    };

    /**
     * Creates an AuditTeam message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditTeam} AuditTeam
     */
    AuditTeam.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditTeam) return object;
      let message = new $root.Enterprise.AuditTeam();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.teamName != null) message.teamName = String(object.teamName);
      if (object.restrictEdit != null) message.restrictEdit = Boolean(object.restrictEdit);
      if (object.restrictShare != null) message.restrictShare = Boolean(object.restrictShare);
      return message;
    };

    /**
     * Creates a plain object from an AuditTeam message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {Enterprise.AuditTeam} message AuditTeam
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditTeam.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        object.teamName = "";
        object.restrictEdit = false;
        object.restrictShare = false;
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.teamName != null && message.hasOwnProperty("teamName"))
        object.teamName = message.teamName;
      if (message.restrictEdit != null && message.hasOwnProperty("restrictEdit"))
        object.restrictEdit = message.restrictEdit;
      if (message.restrictShare != null && message.hasOwnProperty("restrictShare"))
        object.restrictShare = message.restrictShare;
      return object;
    };

    /**
     * Converts this AuditTeam to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditTeam
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditTeam.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditTeam
     * @function getTypeUrl
     * @memberof Enterprise.AuditTeam
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditTeam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditTeam";
    };

    return AuditTeam;
  })();

  Enterprise.AuditTeamUser = (function () {
    /**
     * Properties of an AuditTeamUser.
     * @memberof Enterprise
     * @interface IAuditTeamUser
     * @property {Uint8Array|null} [teamUid] AuditTeamUser teamUid
     * @property {Array.<number|Long>|null} [enterpriseUserIds] AuditTeamUser enterpriseUserIds
     */

    /**
     * Constructs a new AuditTeamUser.
     * @memberof Enterprise
     * @classdesc Represents an AuditTeamUser.
     * @implements IAuditTeamUser
     * @constructor
     * @param {Enterprise.IAuditTeamUser=} [properties] Properties to set
     */
    function AuditTeamUser(properties) {
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * AuditTeamUser teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.AuditTeamUser
     * @instance
     */
    AuditTeamUser.prototype.teamUid = $util.newBuffer([]);

    /**
     * AuditTeamUser enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.AuditTeamUser
     * @instance
     */
    AuditTeamUser.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * Creates a new AuditTeamUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Enterprise.IAuditTeamUser=} [properties] Properties to set
     * @returns {Enterprise.AuditTeamUser} AuditTeamUser instance
     */
    AuditTeamUser.create = function create(properties) {
      return new AuditTeamUser(properties);
    };

    /**
     * Encodes the specified AuditTeamUser message. Does not implicitly {@link Enterprise.AuditTeamUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Enterprise.IAuditTeamUser} message AuditTeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditTeamUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified AuditTeamUser message, length delimited. Does not implicitly {@link Enterprise.AuditTeamUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Enterprise.IAuditTeamUser} message AuditTeamUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AuditTeamUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AuditTeamUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.AuditTeamUser} AuditTeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditTeamUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.AuditTeamUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an AuditTeamUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.AuditTeamUser} AuditTeamUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AuditTeamUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AuditTeamUser message.
     * @function verify
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AuditTeamUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates an AuditTeamUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.AuditTeamUser} AuditTeamUser
     */
    AuditTeamUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.AuditTeamUser) return object;
      let message = new $root.Enterprise.AuditTeamUser();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(".Enterprise.AuditTeamUser.enterpriseUserIds: array expected");
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from an AuditTeamUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {Enterprise.AuditTeamUser} message AuditTeamUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AuditTeamUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserIds = [];
      if (options.defaults)
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      return object;
    };

    /**
     * Converts this AuditTeamUser to JSON.
     * @function toJSON
     * @memberof Enterprise.AuditTeamUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AuditTeamUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AuditTeamUser
     * @function getTypeUrl
     * @memberof Enterprise.AuditTeamUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AuditTeamUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.AuditTeamUser";
    };

    return AuditTeamUser;
  })();

  Enterprise.SharedFolderRecord = (function () {
    /**
     * Properties of a SharedFolderRecord.
     * @memberof Enterprise
     * @interface ISharedFolderRecord
     * @property {Uint8Array|null} [sharedFolderUid] SharedFolderRecord sharedFolderUid
     * @property {Array.<Enterprise.IRecordPermission>|null} [recordPermissions] SharedFolderRecord recordPermissions
     * @property {Array.<Enterprise.IShareAdminRecord>|null} [shareAdminRecords] SharedFolderRecord shareAdminRecords
     */

    /**
     * Constructs a new SharedFolderRecord.
     * @memberof Enterprise
     * @classdesc Represents a SharedFolderRecord.
     * @implements ISharedFolderRecord
     * @constructor
     * @param {Enterprise.ISharedFolderRecord=} [properties] Properties to set
     */
    function SharedFolderRecord(properties) {
      this.recordPermissions = [];
      this.shareAdminRecords = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SharedFolderRecord sharedFolderUid.
     * @member {Uint8Array} sharedFolderUid
     * @memberof Enterprise.SharedFolderRecord
     * @instance
     */
    SharedFolderRecord.prototype.sharedFolderUid = $util.newBuffer([]);

    /**
     * SharedFolderRecord recordPermissions.
     * @member {Array.<Enterprise.IRecordPermission>} recordPermissions
     * @memberof Enterprise.SharedFolderRecord
     * @instance
     */
    SharedFolderRecord.prototype.recordPermissions = $util.emptyArray;

    /**
     * SharedFolderRecord shareAdminRecords.
     * @member {Array.<Enterprise.IShareAdminRecord>} shareAdminRecords
     * @memberof Enterprise.SharedFolderRecord
     * @instance
     */
    SharedFolderRecord.prototype.shareAdminRecords = $util.emptyArray;

    /**
     * Creates a new SharedFolderRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Enterprise.ISharedFolderRecord=} [properties] Properties to set
     * @returns {Enterprise.SharedFolderRecord} SharedFolderRecord instance
     */
    SharedFolderRecord.create = function create(properties) {
      return new SharedFolderRecord(properties);
    };

    /**
     * Encodes the specified SharedFolderRecord message. Does not implicitly {@link Enterprise.SharedFolderRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Enterprise.ISharedFolderRecord} message SharedFolderRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.sharedFolderUid != null && Object.hasOwnProperty.call(message, "sharedFolderUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.sharedFolderUid);
      if (message.recordPermissions != null && message.recordPermissions.length)
        for (let i = 0; i < message.recordPermissions.length; ++i)
          $root.Enterprise.RecordPermission.encode(
            message.recordPermissions[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.shareAdminRecords != null && message.shareAdminRecords.length)
        for (let i = 0; i < message.shareAdminRecords.length; ++i)
          $root.Enterprise.ShareAdminRecord.encode(
            message.shareAdminRecords[i],
            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified SharedFolderRecord message, length delimited. Does not implicitly {@link Enterprise.SharedFolderRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Enterprise.ISharedFolderRecord} message SharedFolderRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SharedFolderRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SharedFolderRecord} SharedFolderRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SharedFolderRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.sharedFolderUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.recordPermissions && message.recordPermissions.length))
              message.recordPermissions = [];
            message.recordPermissions.push(
              $root.Enterprise.RecordPermission.decode(reader, reader.uint32()),
            );
            break;
          }
          case 3: {
            if (!(message.shareAdminRecords && message.shareAdminRecords.length))
              message.shareAdminRecords = [];
            message.shareAdminRecords.push(
              $root.Enterprise.ShareAdminRecord.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SharedFolderRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SharedFolderRecord} SharedFolderRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SharedFolderRecord message.
     * @function verify
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SharedFolderRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        if (
          !(
            (message.sharedFolderUid && typeof message.sharedFolderUid.length === "number") ||
            $util.isString(message.sharedFolderUid)
          )
        )
          return "sharedFolderUid: buffer expected";
      if (message.recordPermissions != null && message.hasOwnProperty("recordPermissions")) {
        if (!Array.isArray(message.recordPermissions)) return "recordPermissions: array expected";
        for (let i = 0; i < message.recordPermissions.length; ++i) {
          let error = $root.Enterprise.RecordPermission.verify(message.recordPermissions[i]);
          if (error) return "recordPermissions." + error;
        }
      }
      if (message.shareAdminRecords != null && message.hasOwnProperty("shareAdminRecords")) {
        if (!Array.isArray(message.shareAdminRecords)) return "shareAdminRecords: array expected";
        for (let i = 0; i < message.shareAdminRecords.length; ++i) {
          let error = $root.Enterprise.ShareAdminRecord.verify(message.shareAdminRecords[i]);
          if (error) return "shareAdminRecords." + error;
        }
      }
      return null;
    };

    /**
     * Creates a SharedFolderRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SharedFolderRecord} SharedFolderRecord
     */
    SharedFolderRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SharedFolderRecord) return object;
      let message = new $root.Enterprise.SharedFolderRecord();
      if (object.sharedFolderUid != null)
        if (typeof object.sharedFolderUid === "string")
          $util.base64.decode(
            object.sharedFolderUid,
            (message.sharedFolderUid = $util.newBuffer(
              $util.base64.length(object.sharedFolderUid),
            )),
            0,
          );
        else if (object.sharedFolderUid.length >= 0)
          message.sharedFolderUid = object.sharedFolderUid;
      if (object.recordPermissions) {
        if (!Array.isArray(object.recordPermissions))
          throw TypeError(".Enterprise.SharedFolderRecord.recordPermissions: array expected");
        message.recordPermissions = [];
        for (let i = 0; i < object.recordPermissions.length; ++i) {
          if (typeof object.recordPermissions[i] !== "object")
            throw TypeError(".Enterprise.SharedFolderRecord.recordPermissions: object expected");
          message.recordPermissions[i] = $root.Enterprise.RecordPermission.fromObject(
            object.recordPermissions[i],
          );
        }
      }
      if (object.shareAdminRecords) {
        if (!Array.isArray(object.shareAdminRecords))
          throw TypeError(".Enterprise.SharedFolderRecord.shareAdminRecords: array expected");
        message.shareAdminRecords = [];
        for (let i = 0; i < object.shareAdminRecords.length; ++i) {
          if (typeof object.shareAdminRecords[i] !== "object")
            throw TypeError(".Enterprise.SharedFolderRecord.shareAdminRecords: object expected");
          message.shareAdminRecords[i] = $root.Enterprise.ShareAdminRecord.fromObject(
            object.shareAdminRecords[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a SharedFolderRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {Enterprise.SharedFolderRecord} message SharedFolderRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SharedFolderRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.recordPermissions = [];
        object.shareAdminRecords = [];
      }
      if (options.defaults)
        if (options.bytes === String) object.sharedFolderUid = "";
        else {
          object.sharedFolderUid = [];
          if (options.bytes !== Array)
            object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
        }
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        object.sharedFolderUid =
          options.bytes === String
            ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.sharedFolderUid)
              : message.sharedFolderUid;
      if (message.recordPermissions && message.recordPermissions.length) {
        object.recordPermissions = [];
        for (let j = 0; j < message.recordPermissions.length; ++j)
          object.recordPermissions[j] = $root.Enterprise.RecordPermission.toObject(
            message.recordPermissions[j],
            options,
          );
      }
      if (message.shareAdminRecords && message.shareAdminRecords.length) {
        object.shareAdminRecords = [];
        for (let j = 0; j < message.shareAdminRecords.length; ++j)
          object.shareAdminRecords[j] = $root.Enterprise.ShareAdminRecord.toObject(
            message.shareAdminRecords[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this SharedFolderRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.SharedFolderRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SharedFolderRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SharedFolderRecord
     * @function getTypeUrl
     * @memberof Enterprise.SharedFolderRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SharedFolderRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SharedFolderRecord";
    };

    return SharedFolderRecord;
  })();

  Enterprise.ShareAdminRecord = (function () {
    /**
     * Properties of a ShareAdminRecord.
     * @memberof Enterprise
     * @interface IShareAdminRecord
     * @property {number|Long|null} [enterpriseUserId] ShareAdminRecord enterpriseUserId
     * @property {Array.<number>|null} [recordPermissionIndexes] ShareAdminRecord recordPermissionIndexes
     */

    /**
     * Constructs a new ShareAdminRecord.
     * @memberof Enterprise
     * @classdesc Represents a ShareAdminRecord.
     * @implements IShareAdminRecord
     * @constructor
     * @param {Enterprise.IShareAdminRecord=} [properties] Properties to set
     */
    function ShareAdminRecord(properties) {
      this.recordPermissionIndexes = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ShareAdminRecord enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.ShareAdminRecord
     * @instance
     */
    ShareAdminRecord.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * ShareAdminRecord recordPermissionIndexes.
     * @member {Array.<number>} recordPermissionIndexes
     * @memberof Enterprise.ShareAdminRecord
     * @instance
     */
    ShareAdminRecord.prototype.recordPermissionIndexes = $util.emptyArray;

    /**
     * Creates a new ShareAdminRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Enterprise.IShareAdminRecord=} [properties] Properties to set
     * @returns {Enterprise.ShareAdminRecord} ShareAdminRecord instance
     */
    ShareAdminRecord.create = function create(properties) {
      return new ShareAdminRecord(properties);
    };

    /**
     * Encodes the specified ShareAdminRecord message. Does not implicitly {@link Enterprise.ShareAdminRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Enterprise.IShareAdminRecord} message ShareAdminRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShareAdminRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.recordPermissionIndexes != null && message.recordPermissionIndexes.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.recordPermissionIndexes.length; ++i)
          writer.int32(message.recordPermissionIndexes[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified ShareAdminRecord message, length delimited. Does not implicitly {@link Enterprise.ShareAdminRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Enterprise.IShareAdminRecord} message ShareAdminRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ShareAdminRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ShareAdminRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ShareAdminRecord} ShareAdminRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShareAdminRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ShareAdminRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            if (!(message.recordPermissionIndexes && message.recordPermissionIndexes.length))
              message.recordPermissionIndexes = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.recordPermissionIndexes.push(reader.int32());
            } else message.recordPermissionIndexes.push(reader.int32());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ShareAdminRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ShareAdminRecord} ShareAdminRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ShareAdminRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ShareAdminRecord message.
     * @function verify
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ShareAdminRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (
        message.recordPermissionIndexes != null &&
        message.hasOwnProperty("recordPermissionIndexes")
      ) {
        if (!Array.isArray(message.recordPermissionIndexes))
          return "recordPermissionIndexes: array expected";
        for (let i = 0; i < message.recordPermissionIndexes.length; ++i)
          if (!$util.isInteger(message.recordPermissionIndexes[i]))
            return "recordPermissionIndexes: integer[] expected";
      }
      return null;
    };

    /**
     * Creates a ShareAdminRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ShareAdminRecord} ShareAdminRecord
     */
    ShareAdminRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ShareAdminRecord) return object;
      let message = new $root.Enterprise.ShareAdminRecord();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.recordPermissionIndexes) {
        if (!Array.isArray(object.recordPermissionIndexes))
          throw TypeError(".Enterprise.ShareAdminRecord.recordPermissionIndexes: array expected");
        message.recordPermissionIndexes = [];
        for (let i = 0; i < object.recordPermissionIndexes.length; ++i)
          message.recordPermissionIndexes[i] = object.recordPermissionIndexes[i] | 0;
      }
      return message;
    };

    /**
     * Creates a plain object from a ShareAdminRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {Enterprise.ShareAdminRecord} message ShareAdminRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ShareAdminRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.recordPermissionIndexes = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.recordPermissionIndexes && message.recordPermissionIndexes.length) {
        object.recordPermissionIndexes = [];
        for (let j = 0; j < message.recordPermissionIndexes.length; ++j)
          object.recordPermissionIndexes[j] = message.recordPermissionIndexes[j];
      }
      return object;
    };

    /**
     * Converts this ShareAdminRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.ShareAdminRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ShareAdminRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ShareAdminRecord
     * @function getTypeUrl
     * @memberof Enterprise.ShareAdminRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ShareAdminRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ShareAdminRecord";
    };

    return ShareAdminRecord;
  })();

  Enterprise.SharedFolderUser = (function () {
    /**
     * Properties of a SharedFolderUser.
     * @memberof Enterprise
     * @interface ISharedFolderUser
     * @property {Uint8Array|null} [sharedFolderUid] SharedFolderUser sharedFolderUid
     * @property {Array.<number|Long>|null} [enterpriseUserIds] SharedFolderUser enterpriseUserIds
     */

    /**
     * Constructs a new SharedFolderUser.
     * @memberof Enterprise
     * @classdesc Represents a SharedFolderUser.
     * @implements ISharedFolderUser
     * @constructor
     * @param {Enterprise.ISharedFolderUser=} [properties] Properties to set
     */
    function SharedFolderUser(properties) {
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SharedFolderUser sharedFolderUid.
     * @member {Uint8Array} sharedFolderUid
     * @memberof Enterprise.SharedFolderUser
     * @instance
     */
    SharedFolderUser.prototype.sharedFolderUid = $util.newBuffer([]);

    /**
     * SharedFolderUser enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.SharedFolderUser
     * @instance
     */
    SharedFolderUser.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * Creates a new SharedFolderUser instance using the specified properties.
     * @function create
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Enterprise.ISharedFolderUser=} [properties] Properties to set
     * @returns {Enterprise.SharedFolderUser} SharedFolderUser instance
     */
    SharedFolderUser.create = function create(properties) {
      return new SharedFolderUser(properties);
    };

    /**
     * Encodes the specified SharedFolderUser message. Does not implicitly {@link Enterprise.SharedFolderUser.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Enterprise.ISharedFolderUser} message SharedFolderUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderUser.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.sharedFolderUid != null && Object.hasOwnProperty.call(message, "sharedFolderUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.sharedFolderUid);
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified SharedFolderUser message, length delimited. Does not implicitly {@link Enterprise.SharedFolderUser.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Enterprise.ISharedFolderUser} message SharedFolderUser message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderUser.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SharedFolderUser message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SharedFolderUser} SharedFolderUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderUser.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SharedFolderUser();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.sharedFolderUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SharedFolderUser message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SharedFolderUser} SharedFolderUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderUser.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SharedFolderUser message.
     * @function verify
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SharedFolderUser.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        if (
          !(
            (message.sharedFolderUid && typeof message.sharedFolderUid.length === "number") ||
            $util.isString(message.sharedFolderUid)
          )
        )
          return "sharedFolderUid: buffer expected";
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a SharedFolderUser message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SharedFolderUser} SharedFolderUser
     */
    SharedFolderUser.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SharedFolderUser) return object;
      let message = new $root.Enterprise.SharedFolderUser();
      if (object.sharedFolderUid != null)
        if (typeof object.sharedFolderUid === "string")
          $util.base64.decode(
            object.sharedFolderUid,
            (message.sharedFolderUid = $util.newBuffer(
              $util.base64.length(object.sharedFolderUid),
            )),
            0,
          );
        else if (object.sharedFolderUid.length >= 0)
          message.sharedFolderUid = object.sharedFolderUid;
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(".Enterprise.SharedFolderUser.enterpriseUserIds: array expected");
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a SharedFolderUser message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {Enterprise.SharedFolderUser} message SharedFolderUser
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SharedFolderUser.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserIds = [];
      if (options.defaults)
        if (options.bytes === String) object.sharedFolderUid = "";
        else {
          object.sharedFolderUid = [];
          if (options.bytes !== Array)
            object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
        }
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        object.sharedFolderUid =
          options.bytes === String
            ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.sharedFolderUid)
              : message.sharedFolderUid;
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      return object;
    };

    /**
     * Converts this SharedFolderUser to JSON.
     * @function toJSON
     * @memberof Enterprise.SharedFolderUser
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SharedFolderUser.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SharedFolderUser
     * @function getTypeUrl
     * @memberof Enterprise.SharedFolderUser
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SharedFolderUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SharedFolderUser";
    };

    return SharedFolderUser;
  })();

  Enterprise.SharedFolderTeam = (function () {
    /**
     * Properties of a SharedFolderTeam.
     * @memberof Enterprise
     * @interface ISharedFolderTeam
     * @property {Uint8Array|null} [sharedFolderUid] SharedFolderTeam sharedFolderUid
     * @property {Array.<Uint8Array>|null} [teamUids] SharedFolderTeam teamUids
     */

    /**
     * Constructs a new SharedFolderTeam.
     * @memberof Enterprise
     * @classdesc Represents a SharedFolderTeam.
     * @implements ISharedFolderTeam
     * @constructor
     * @param {Enterprise.ISharedFolderTeam=} [properties] Properties to set
     */
    function SharedFolderTeam(properties) {
      this.teamUids = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SharedFolderTeam sharedFolderUid.
     * @member {Uint8Array} sharedFolderUid
     * @memberof Enterprise.SharedFolderTeam
     * @instance
     */
    SharedFolderTeam.prototype.sharedFolderUid = $util.newBuffer([]);

    /**
     * SharedFolderTeam teamUids.
     * @member {Array.<Uint8Array>} teamUids
     * @memberof Enterprise.SharedFolderTeam
     * @instance
     */
    SharedFolderTeam.prototype.teamUids = $util.emptyArray;

    /**
     * Creates a new SharedFolderTeam instance using the specified properties.
     * @function create
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Enterprise.ISharedFolderTeam=} [properties] Properties to set
     * @returns {Enterprise.SharedFolderTeam} SharedFolderTeam instance
     */
    SharedFolderTeam.create = function create(properties) {
      return new SharedFolderTeam(properties);
    };

    /**
     * Encodes the specified SharedFolderTeam message. Does not implicitly {@link Enterprise.SharedFolderTeam.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Enterprise.ISharedFolderTeam} message SharedFolderTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderTeam.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.sharedFolderUid != null && Object.hasOwnProperty.call(message, "sharedFolderUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.sharedFolderUid);
      if (message.teamUids != null && message.teamUids.length)
        for (let i = 0; i < message.teamUids.length; ++i)
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.teamUids[i]);
      return writer;
    };

    /**
     * Encodes the specified SharedFolderTeam message, length delimited. Does not implicitly {@link Enterprise.SharedFolderTeam.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Enterprise.ISharedFolderTeam} message SharedFolderTeam message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SharedFolderTeam.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SharedFolderTeam message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SharedFolderTeam} SharedFolderTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderTeam.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SharedFolderTeam();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.sharedFolderUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.teamUids && message.teamUids.length)) message.teamUids = [];
            message.teamUids.push(reader.bytes());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SharedFolderTeam message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SharedFolderTeam} SharedFolderTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SharedFolderTeam.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SharedFolderTeam message.
     * @function verify
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SharedFolderTeam.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        if (
          !(
            (message.sharedFolderUid && typeof message.sharedFolderUid.length === "number") ||
            $util.isString(message.sharedFolderUid)
          )
        )
          return "sharedFolderUid: buffer expected";
      if (message.teamUids != null && message.hasOwnProperty("teamUids")) {
        if (!Array.isArray(message.teamUids)) return "teamUids: array expected";
        for (let i = 0; i < message.teamUids.length; ++i)
          if (
            !(
              (message.teamUids[i] && typeof message.teamUids[i].length === "number") ||
              $util.isString(message.teamUids[i])
            )
          )
            return "teamUids: buffer[] expected";
      }
      return null;
    };

    /**
     * Creates a SharedFolderTeam message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SharedFolderTeam} SharedFolderTeam
     */
    SharedFolderTeam.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SharedFolderTeam) return object;
      let message = new $root.Enterprise.SharedFolderTeam();
      if (object.sharedFolderUid != null)
        if (typeof object.sharedFolderUid === "string")
          $util.base64.decode(
            object.sharedFolderUid,
            (message.sharedFolderUid = $util.newBuffer(
              $util.base64.length(object.sharedFolderUid),
            )),
            0,
          );
        else if (object.sharedFolderUid.length >= 0)
          message.sharedFolderUid = object.sharedFolderUid;
      if (object.teamUids) {
        if (!Array.isArray(object.teamUids))
          throw TypeError(".Enterprise.SharedFolderTeam.teamUids: array expected");
        message.teamUids = [];
        for (let i = 0; i < object.teamUids.length; ++i)
          if (typeof object.teamUids[i] === "string")
            $util.base64.decode(
              object.teamUids[i],
              (message.teamUids[i] = $util.newBuffer($util.base64.length(object.teamUids[i]))),
              0,
            );
          else if (object.teamUids[i].length >= 0) message.teamUids[i] = object.teamUids[i];
      }
      return message;
    };

    /**
     * Creates a plain object from a SharedFolderTeam message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {Enterprise.SharedFolderTeam} message SharedFolderTeam
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SharedFolderTeam.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.teamUids = [];
      if (options.defaults)
        if (options.bytes === String) object.sharedFolderUid = "";
        else {
          object.sharedFolderUid = [];
          if (options.bytes !== Array)
            object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
        }
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        object.sharedFolderUid =
          options.bytes === String
            ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.sharedFolderUid)
              : message.sharedFolderUid;
      if (message.teamUids && message.teamUids.length) {
        object.teamUids = [];
        for (let j = 0; j < message.teamUids.length; ++j)
          object.teamUids[j] =
            options.bytes === String
              ? $util.base64.encode(message.teamUids[j], 0, message.teamUids[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.teamUids[j])
                : message.teamUids[j];
      }
      return object;
    };

    /**
     * Converts this SharedFolderTeam to JSON.
     * @function toJSON
     * @memberof Enterprise.SharedFolderTeam
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SharedFolderTeam.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SharedFolderTeam
     * @function getTypeUrl
     * @memberof Enterprise.SharedFolderTeam
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SharedFolderTeam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SharedFolderTeam";
    };

    return SharedFolderTeam;
  })();

  Enterprise.GetComplianceReportRequest = (function () {
    /**
     * Properties of a GetComplianceReportRequest.
     * @memberof Enterprise
     * @interface IGetComplianceReportRequest
     * @property {Uint8Array|null} [reportUid] GetComplianceReportRequest reportUid
     */

    /**
     * Constructs a new GetComplianceReportRequest.
     * @memberof Enterprise
     * @classdesc Represents a GetComplianceReportRequest.
     * @implements IGetComplianceReportRequest
     * @constructor
     * @param {Enterprise.IGetComplianceReportRequest=} [properties] Properties to set
     */
    function GetComplianceReportRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetComplianceReportRequest reportUid.
     * @member {Uint8Array} reportUid
     * @memberof Enterprise.GetComplianceReportRequest
     * @instance
     */
    GetComplianceReportRequest.prototype.reportUid = $util.newBuffer([]);

    /**
     * Creates a new GetComplianceReportRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Enterprise.IGetComplianceReportRequest=} [properties] Properties to set
     * @returns {Enterprise.GetComplianceReportRequest} GetComplianceReportRequest instance
     */
    GetComplianceReportRequest.create = function create(properties) {
      return new GetComplianceReportRequest(properties);
    };

    /**
     * Encodes the specified GetComplianceReportRequest message. Does not implicitly {@link Enterprise.GetComplianceReportRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Enterprise.IGetComplianceReportRequest} message GetComplianceReportRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetComplianceReportRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.reportUid != null && Object.hasOwnProperty.call(message, "reportUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.reportUid);
      return writer;
    };

    /**
     * Encodes the specified GetComplianceReportRequest message, length delimited. Does not implicitly {@link Enterprise.GetComplianceReportRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Enterprise.IGetComplianceReportRequest} message GetComplianceReportRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetComplianceReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetComplianceReportRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetComplianceReportRequest} GetComplianceReportRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetComplianceReportRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetComplianceReportRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.reportUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetComplianceReportRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetComplianceReportRequest} GetComplianceReportRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetComplianceReportRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetComplianceReportRequest message.
     * @function verify
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetComplianceReportRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        if (
          !(
            (message.reportUid && typeof message.reportUid.length === "number") ||
            $util.isString(message.reportUid)
          )
        )
          return "reportUid: buffer expected";
      return null;
    };

    /**
     * Creates a GetComplianceReportRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetComplianceReportRequest} GetComplianceReportRequest
     */
    GetComplianceReportRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetComplianceReportRequest) return object;
      let message = new $root.Enterprise.GetComplianceReportRequest();
      if (object.reportUid != null)
        if (typeof object.reportUid === "string")
          $util.base64.decode(
            object.reportUid,
            (message.reportUid = $util.newBuffer($util.base64.length(object.reportUid))),
            0,
          );
        else if (object.reportUid.length >= 0) message.reportUid = object.reportUid;
      return message;
    };

    /**
     * Creates a plain object from a GetComplianceReportRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {Enterprise.GetComplianceReportRequest} message GetComplianceReportRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetComplianceReportRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.reportUid = "";
        else {
          object.reportUid = [];
          if (options.bytes !== Array) object.reportUid = $util.newBuffer(object.reportUid);
        }
      if (message.reportUid != null && message.hasOwnProperty("reportUid"))
        object.reportUid =
          options.bytes === String
            ? $util.base64.encode(message.reportUid, 0, message.reportUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.reportUid)
              : message.reportUid;
      return object;
    };

    /**
     * Converts this GetComplianceReportRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.GetComplianceReportRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetComplianceReportRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetComplianceReportRequest
     * @function getTypeUrl
     * @memberof Enterprise.GetComplianceReportRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetComplianceReportRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetComplianceReportRequest";
    };

    return GetComplianceReportRequest;
  })();

  Enterprise.GetComplianceReportResponse = (function () {
    /**
     * Properties of a GetComplianceReportResponse.
     * @memberof Enterprise
     * @interface IGetComplianceReportResponse
     * @property {string|null} [downloadUrl] GetComplianceReportResponse downloadUrl
     */

    /**
     * Constructs a new GetComplianceReportResponse.
     * @memberof Enterprise
     * @classdesc Represents a GetComplianceReportResponse.
     * @implements IGetComplianceReportResponse
     * @constructor
     * @param {Enterprise.IGetComplianceReportResponse=} [properties] Properties to set
     */
    function GetComplianceReportResponse(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetComplianceReportResponse downloadUrl.
     * @member {string} downloadUrl
     * @memberof Enterprise.GetComplianceReportResponse
     * @instance
     */
    GetComplianceReportResponse.prototype.downloadUrl = "";

    /**
     * Creates a new GetComplianceReportResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Enterprise.IGetComplianceReportResponse=} [properties] Properties to set
     * @returns {Enterprise.GetComplianceReportResponse} GetComplianceReportResponse instance
     */
    GetComplianceReportResponse.create = function create(properties) {
      return new GetComplianceReportResponse(properties);
    };

    /**
     * Encodes the specified GetComplianceReportResponse message. Does not implicitly {@link Enterprise.GetComplianceReportResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Enterprise.IGetComplianceReportResponse} message GetComplianceReportResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetComplianceReportResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.downloadUrl != null && Object.hasOwnProperty.call(message, "downloadUrl"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.downloadUrl);
      return writer;
    };

    /**
     * Encodes the specified GetComplianceReportResponse message, length delimited. Does not implicitly {@link Enterprise.GetComplianceReportResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Enterprise.IGetComplianceReportResponse} message GetComplianceReportResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetComplianceReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetComplianceReportResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetComplianceReportResponse} GetComplianceReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetComplianceReportResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetComplianceReportResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.downloadUrl = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetComplianceReportResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetComplianceReportResponse} GetComplianceReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetComplianceReportResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetComplianceReportResponse message.
     * @function verify
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetComplianceReportResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
        if (!$util.isString(message.downloadUrl)) return "downloadUrl: string expected";
      return null;
    };

    /**
     * Creates a GetComplianceReportResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetComplianceReportResponse} GetComplianceReportResponse
     */
    GetComplianceReportResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetComplianceReportResponse) return object;
      let message = new $root.Enterprise.GetComplianceReportResponse();
      if (object.downloadUrl != null) message.downloadUrl = String(object.downloadUrl);
      return message;
    };

    /**
     * Creates a plain object from a GetComplianceReportResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {Enterprise.GetComplianceReportResponse} message GetComplianceReportResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetComplianceReportResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) object.downloadUrl = "";
      if (message.downloadUrl != null && message.hasOwnProperty("downloadUrl"))
        object.downloadUrl = message.downloadUrl;
      return object;
    };

    /**
     * Converts this GetComplianceReportResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.GetComplianceReportResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetComplianceReportResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetComplianceReportResponse
     * @function getTypeUrl
     * @memberof Enterprise.GetComplianceReportResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetComplianceReportResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetComplianceReportResponse";
    };

    return GetComplianceReportResponse;
  })();

  Enterprise.ComplianceReportCriteriaRequest = (function () {
    /**
     * Properties of a ComplianceReportCriteriaRequest.
     * @memberof Enterprise
     * @interface IComplianceReportCriteriaRequest
     * @property {Uint8Array|null} [criteriaUid] ComplianceReportCriteriaRequest criteriaUid
     */

    /**
     * Constructs a new ComplianceReportCriteriaRequest.
     * @memberof Enterprise
     * @classdesc Represents a ComplianceReportCriteriaRequest.
     * @implements IComplianceReportCriteriaRequest
     * @constructor
     * @param {Enterprise.IComplianceReportCriteriaRequest=} [properties] Properties to set
     */
    function ComplianceReportCriteriaRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ComplianceReportCriteriaRequest criteriaUid.
     * @member {Uint8Array} criteriaUid
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @instance
     */
    ComplianceReportCriteriaRequest.prototype.criteriaUid = $util.newBuffer([]);

    /**
     * Creates a new ComplianceReportCriteriaRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Enterprise.IComplianceReportCriteriaRequest=} [properties] Properties to set
     * @returns {Enterprise.ComplianceReportCriteriaRequest} ComplianceReportCriteriaRequest instance
     */
    ComplianceReportCriteriaRequest.create = function create(properties) {
      return new ComplianceReportCriteriaRequest(properties);
    };

    /**
     * Encodes the specified ComplianceReportCriteriaRequest message. Does not implicitly {@link Enterprise.ComplianceReportCriteriaRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Enterprise.IComplianceReportCriteriaRequest} message ComplianceReportCriteriaRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteriaRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.criteriaUid != null && Object.hasOwnProperty.call(message, "criteriaUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.criteriaUid);
      return writer;
    };

    /**
     * Encodes the specified ComplianceReportCriteriaRequest message, length delimited. Does not implicitly {@link Enterprise.ComplianceReportCriteriaRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Enterprise.IComplianceReportCriteriaRequest} message ComplianceReportCriteriaRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ComplianceReportCriteriaRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ComplianceReportCriteriaRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ComplianceReportCriteriaRequest} ComplianceReportCriteriaRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteriaRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ComplianceReportCriteriaRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.criteriaUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ComplianceReportCriteriaRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ComplianceReportCriteriaRequest} ComplianceReportCriteriaRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ComplianceReportCriteriaRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ComplianceReportCriteriaRequest message.
     * @function verify
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ComplianceReportCriteriaRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        if (
          !(
            (message.criteriaUid && typeof message.criteriaUid.length === "number") ||
            $util.isString(message.criteriaUid)
          )
        )
          return "criteriaUid: buffer expected";
      return null;
    };

    /**
     * Creates a ComplianceReportCriteriaRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ComplianceReportCriteriaRequest} ComplianceReportCriteriaRequest
     */
    ComplianceReportCriteriaRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ComplianceReportCriteriaRequest) return object;
      let message = new $root.Enterprise.ComplianceReportCriteriaRequest();
      if (object.criteriaUid != null)
        if (typeof object.criteriaUid === "string")
          $util.base64.decode(
            object.criteriaUid,
            (message.criteriaUid = $util.newBuffer($util.base64.length(object.criteriaUid))),
            0,
          );
        else if (object.criteriaUid.length >= 0) message.criteriaUid = object.criteriaUid;
      return message;
    };

    /**
     * Creates a plain object from a ComplianceReportCriteriaRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {Enterprise.ComplianceReportCriteriaRequest} message ComplianceReportCriteriaRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ComplianceReportCriteriaRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.criteriaUid = "";
        else {
          object.criteriaUid = [];
          if (options.bytes !== Array) object.criteriaUid = $util.newBuffer(object.criteriaUid);
        }
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        object.criteriaUid =
          options.bytes === String
            ? $util.base64.encode(message.criteriaUid, 0, message.criteriaUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.criteriaUid)
              : message.criteriaUid;
      return object;
    };

    /**
     * Converts this ComplianceReportCriteriaRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ComplianceReportCriteriaRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ComplianceReportCriteriaRequest
     * @function getTypeUrl
     * @memberof Enterprise.ComplianceReportCriteriaRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ComplianceReportCriteriaRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ComplianceReportCriteriaRequest";
    };

    return ComplianceReportCriteriaRequest;
  })();

  Enterprise.SaveComplianceReportCriteriaResponse = (function () {
    /**
     * Properties of a SaveComplianceReportCriteriaResponse.
     * @memberof Enterprise
     * @interface ISaveComplianceReportCriteriaResponse
     * @property {Uint8Array|null} [criteriaUid] SaveComplianceReportCriteriaResponse criteriaUid
     */

    /**
     * Constructs a new SaveComplianceReportCriteriaResponse.
     * @memberof Enterprise
     * @classdesc Represents a SaveComplianceReportCriteriaResponse.
     * @implements ISaveComplianceReportCriteriaResponse
     * @constructor
     * @param {Enterprise.ISaveComplianceReportCriteriaResponse=} [properties] Properties to set
     */
    function SaveComplianceReportCriteriaResponse(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * SaveComplianceReportCriteriaResponse criteriaUid.
     * @member {Uint8Array} criteriaUid
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @instance
     */
    SaveComplianceReportCriteriaResponse.prototype.criteriaUid = $util.newBuffer([]);

    /**
     * Creates a new SaveComplianceReportCriteriaResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Enterprise.ISaveComplianceReportCriteriaResponse=} [properties] Properties to set
     * @returns {Enterprise.SaveComplianceReportCriteriaResponse} SaveComplianceReportCriteriaResponse instance
     */
    SaveComplianceReportCriteriaResponse.create = function create(properties) {
      return new SaveComplianceReportCriteriaResponse(properties);
    };

    /**
     * Encodes the specified SaveComplianceReportCriteriaResponse message. Does not implicitly {@link Enterprise.SaveComplianceReportCriteriaResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Enterprise.ISaveComplianceReportCriteriaResponse} message SaveComplianceReportCriteriaResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SaveComplianceReportCriteriaResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.criteriaUid != null && Object.hasOwnProperty.call(message, "criteriaUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.criteriaUid);
      return writer;
    };

    /**
     * Encodes the specified SaveComplianceReportCriteriaResponse message, length delimited. Does not implicitly {@link Enterprise.SaveComplianceReportCriteriaResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Enterprise.ISaveComplianceReportCriteriaResponse} message SaveComplianceReportCriteriaResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SaveComplianceReportCriteriaResponse.encodeDelimited = function encodeDelimited(
      message,
      writer,
    ) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SaveComplianceReportCriteriaResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.SaveComplianceReportCriteriaResponse} SaveComplianceReportCriteriaResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SaveComplianceReportCriteriaResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.SaveComplianceReportCriteriaResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.criteriaUid = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a SaveComplianceReportCriteriaResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.SaveComplianceReportCriteriaResponse} SaveComplianceReportCriteriaResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SaveComplianceReportCriteriaResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SaveComplianceReportCriteriaResponse message.
     * @function verify
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SaveComplianceReportCriteriaResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        if (
          !(
            (message.criteriaUid && typeof message.criteriaUid.length === "number") ||
            $util.isString(message.criteriaUid)
          )
        )
          return "criteriaUid: buffer expected";
      return null;
    };

    /**
     * Creates a SaveComplianceReportCriteriaResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.SaveComplianceReportCriteriaResponse} SaveComplianceReportCriteriaResponse
     */
    SaveComplianceReportCriteriaResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.SaveComplianceReportCriteriaResponse) return object;
      let message = new $root.Enterprise.SaveComplianceReportCriteriaResponse();
      if (object.criteriaUid != null)
        if (typeof object.criteriaUid === "string")
          $util.base64.decode(
            object.criteriaUid,
            (message.criteriaUid = $util.newBuffer($util.base64.length(object.criteriaUid))),
            0,
          );
        else if (object.criteriaUid.length >= 0) message.criteriaUid = object.criteriaUid;
      return message;
    };

    /**
     * Creates a plain object from a SaveComplianceReportCriteriaResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {Enterprise.SaveComplianceReportCriteriaResponse} message SaveComplianceReportCriteriaResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SaveComplianceReportCriteriaResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults)
        if (options.bytes === String) object.criteriaUid = "";
        else {
          object.criteriaUid = [];
          if (options.bytes !== Array) object.criteriaUid = $util.newBuffer(object.criteriaUid);
        }
      if (message.criteriaUid != null && message.hasOwnProperty("criteriaUid"))
        object.criteriaUid =
          options.bytes === String
            ? $util.base64.encode(message.criteriaUid, 0, message.criteriaUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.criteriaUid)
              : message.criteriaUid;
      return object;
    };

    /**
     * Converts this SaveComplianceReportCriteriaResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SaveComplianceReportCriteriaResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SaveComplianceReportCriteriaResponse
     * @function getTypeUrl
     * @memberof Enterprise.SaveComplianceReportCriteriaResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SaveComplianceReportCriteriaResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.SaveComplianceReportCriteriaResponse";
    };

    return SaveComplianceReportCriteriaResponse;
  })();

  Enterprise.LinkedRecord = (function () {
    /**
     * Properties of a LinkedRecord.
     * @memberof Enterprise
     * @interface ILinkedRecord
     * @property {Uint8Array|null} [ownerUid] LinkedRecord ownerUid
     * @property {Array.<Uint8Array>|null} [recordUids] LinkedRecord recordUids
     */

    /**
     * Constructs a new LinkedRecord.
     * @memberof Enterprise
     * @classdesc Represents a LinkedRecord.
     * @implements ILinkedRecord
     * @constructor
     * @param {Enterprise.ILinkedRecord=} [properties] Properties to set
     */
    function LinkedRecord(properties) {
      this.recordUids = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * LinkedRecord ownerUid.
     * @member {Uint8Array} ownerUid
     * @memberof Enterprise.LinkedRecord
     * @instance
     */
    LinkedRecord.prototype.ownerUid = $util.newBuffer([]);

    /**
     * LinkedRecord recordUids.
     * @member {Array.<Uint8Array>} recordUids
     * @memberof Enterprise.LinkedRecord
     * @instance
     */
    LinkedRecord.prototype.recordUids = $util.emptyArray;

    /**
     * Creates a new LinkedRecord instance using the specified properties.
     * @function create
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Enterprise.ILinkedRecord=} [properties] Properties to set
     * @returns {Enterprise.LinkedRecord} LinkedRecord instance
     */
    LinkedRecord.create = function create(properties) {
      return new LinkedRecord(properties);
    };

    /**
     * Encodes the specified LinkedRecord message. Does not implicitly {@link Enterprise.LinkedRecord.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Enterprise.ILinkedRecord} message LinkedRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LinkedRecord.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.ownerUid != null && Object.hasOwnProperty.call(message, "ownerUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.ownerUid);
      if (message.recordUids != null && message.recordUids.length)
        for (let i = 0; i < message.recordUids.length; ++i)
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.recordUids[i]);
      return writer;
    };

    /**
     * Encodes the specified LinkedRecord message, length delimited. Does not implicitly {@link Enterprise.LinkedRecord.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Enterprise.ILinkedRecord} message LinkedRecord message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LinkedRecord.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LinkedRecord message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.LinkedRecord} LinkedRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LinkedRecord.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.LinkedRecord();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.ownerUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.recordUids && message.recordUids.length)) message.recordUids = [];
            message.recordUids.push(reader.bytes());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a LinkedRecord message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.LinkedRecord} LinkedRecord
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LinkedRecord.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LinkedRecord message.
     * @function verify
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LinkedRecord.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.ownerUid != null && message.hasOwnProperty("ownerUid"))
        if (
          !(
            (message.ownerUid && typeof message.ownerUid.length === "number") ||
            $util.isString(message.ownerUid)
          )
        )
          return "ownerUid: buffer expected";
      if (message.recordUids != null && message.hasOwnProperty("recordUids")) {
        if (!Array.isArray(message.recordUids)) return "recordUids: array expected";
        for (let i = 0; i < message.recordUids.length; ++i)
          if (
            !(
              (message.recordUids[i] && typeof message.recordUids[i].length === "number") ||
              $util.isString(message.recordUids[i])
            )
          )
            return "recordUids: buffer[] expected";
      }
      return null;
    };

    /**
     * Creates a LinkedRecord message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.LinkedRecord} LinkedRecord
     */
    LinkedRecord.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.LinkedRecord) return object;
      let message = new $root.Enterprise.LinkedRecord();
      if (object.ownerUid != null)
        if (typeof object.ownerUid === "string")
          $util.base64.decode(
            object.ownerUid,
            (message.ownerUid = $util.newBuffer($util.base64.length(object.ownerUid))),
            0,
          );
        else if (object.ownerUid.length >= 0) message.ownerUid = object.ownerUid;
      if (object.recordUids) {
        if (!Array.isArray(object.recordUids))
          throw TypeError(".Enterprise.LinkedRecord.recordUids: array expected");
        message.recordUids = [];
        for (let i = 0; i < object.recordUids.length; ++i)
          if (typeof object.recordUids[i] === "string")
            $util.base64.decode(
              object.recordUids[i],
              (message.recordUids[i] = $util.newBuffer($util.base64.length(object.recordUids[i]))),
              0,
            );
          else if (object.recordUids[i].length >= 0) message.recordUids[i] = object.recordUids[i];
      }
      return message;
    };

    /**
     * Creates a plain object from a LinkedRecord message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {Enterprise.LinkedRecord} message LinkedRecord
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LinkedRecord.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.recordUids = [];
      if (options.defaults)
        if (options.bytes === String) object.ownerUid = "";
        else {
          object.ownerUid = [];
          if (options.bytes !== Array) object.ownerUid = $util.newBuffer(object.ownerUid);
        }
      if (message.ownerUid != null && message.hasOwnProperty("ownerUid"))
        object.ownerUid =
          options.bytes === String
            ? $util.base64.encode(message.ownerUid, 0, message.ownerUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.ownerUid)
              : message.ownerUid;
      if (message.recordUids && message.recordUids.length) {
        object.recordUids = [];
        for (let j = 0; j < message.recordUids.length; ++j)
          object.recordUids[j] =
            options.bytes === String
              ? $util.base64.encode(message.recordUids[j], 0, message.recordUids[j].length)
              : options.bytes === Array
                ? Array.prototype.slice.call(message.recordUids[j])
                : message.recordUids[j];
      }
      return object;
    };

    /**
     * Converts this LinkedRecord to JSON.
     * @function toJSON
     * @memberof Enterprise.LinkedRecord
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LinkedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for LinkedRecord
     * @function getTypeUrl
     * @memberof Enterprise.LinkedRecord
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    LinkedRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.LinkedRecord";
    };

    return LinkedRecord;
  })();

  Enterprise.GetSharingAdminsRequest = (function () {
    /**
     * Properties of a GetSharingAdminsRequest.
     * @memberof Enterprise
     * @interface IGetSharingAdminsRequest
     * @property {Uint8Array|null} [sharedFolderUid] GetSharingAdminsRequest sharedFolderUid
     * @property {Uint8Array|null} [recordUid] GetSharingAdminsRequest recordUid
     * @property {string|null} [username] GetSharingAdminsRequest username
     */

    /**
     * Constructs a new GetSharingAdminsRequest.
     * @memberof Enterprise
     * @classdesc Represents a GetSharingAdminsRequest.
     * @implements IGetSharingAdminsRequest
     * @constructor
     * @param {Enterprise.IGetSharingAdminsRequest=} [properties] Properties to set
     */
    function GetSharingAdminsRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSharingAdminsRequest sharedFolderUid.
     * @member {Uint8Array} sharedFolderUid
     * @memberof Enterprise.GetSharingAdminsRequest
     * @instance
     */
    GetSharingAdminsRequest.prototype.sharedFolderUid = $util.newBuffer([]);

    /**
     * GetSharingAdminsRequest recordUid.
     * @member {Uint8Array} recordUid
     * @memberof Enterprise.GetSharingAdminsRequest
     * @instance
     */
    GetSharingAdminsRequest.prototype.recordUid = $util.newBuffer([]);

    /**
     * GetSharingAdminsRequest username.
     * @member {string} username
     * @memberof Enterprise.GetSharingAdminsRequest
     * @instance
     */
    GetSharingAdminsRequest.prototype.username = "";

    /**
     * Creates a new GetSharingAdminsRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Enterprise.IGetSharingAdminsRequest=} [properties] Properties to set
     * @returns {Enterprise.GetSharingAdminsRequest} GetSharingAdminsRequest instance
     */
    GetSharingAdminsRequest.create = function create(properties) {
      return new GetSharingAdminsRequest(properties);
    };

    /**
     * Encodes the specified GetSharingAdminsRequest message. Does not implicitly {@link Enterprise.GetSharingAdminsRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Enterprise.IGetSharingAdminsRequest} message GetSharingAdminsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingAdminsRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.sharedFolderUid != null && Object.hasOwnProperty.call(message, "sharedFolderUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.sharedFolderUid);
      if (message.recordUid != null && Object.hasOwnProperty.call(message, "recordUid"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.recordUid);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.username);
      return writer;
    };

    /**
     * Encodes the specified GetSharingAdminsRequest message, length delimited. Does not implicitly {@link Enterprise.GetSharingAdminsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Enterprise.IGetSharingAdminsRequest} message GetSharingAdminsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingAdminsRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSharingAdminsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetSharingAdminsRequest} GetSharingAdminsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingAdminsRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetSharingAdminsRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.sharedFolderUid = reader.bytes();
            break;
          }
          case 2: {
            message.recordUid = reader.bytes();
            break;
          }
          case 3: {
            message.username = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetSharingAdminsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetSharingAdminsRequest} GetSharingAdminsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingAdminsRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSharingAdminsRequest message.
     * @function verify
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSharingAdminsRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        if (
          !(
            (message.sharedFolderUid && typeof message.sharedFolderUid.length === "number") ||
            $util.isString(message.sharedFolderUid)
          )
        )
          return "sharedFolderUid: buffer expected";
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        if (
          !(
            (message.recordUid && typeof message.recordUid.length === "number") ||
            $util.isString(message.recordUid)
          )
        )
          return "recordUid: buffer expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      return null;
    };

    /**
     * Creates a GetSharingAdminsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetSharingAdminsRequest} GetSharingAdminsRequest
     */
    GetSharingAdminsRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetSharingAdminsRequest) return object;
      let message = new $root.Enterprise.GetSharingAdminsRequest();
      if (object.sharedFolderUid != null)
        if (typeof object.sharedFolderUid === "string")
          $util.base64.decode(
            object.sharedFolderUid,
            (message.sharedFolderUid = $util.newBuffer(
              $util.base64.length(object.sharedFolderUid),
            )),
            0,
          );
        else if (object.sharedFolderUid.length >= 0)
          message.sharedFolderUid = object.sharedFolderUid;
      if (object.recordUid != null)
        if (typeof object.recordUid === "string")
          $util.base64.decode(
            object.recordUid,
            (message.recordUid = $util.newBuffer($util.base64.length(object.recordUid))),
            0,
          );
        else if (object.recordUid.length >= 0) message.recordUid = object.recordUid;
      if (object.username != null) message.username = String(object.username);
      return message;
    };

    /**
     * Creates a plain object from a GetSharingAdminsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {Enterprise.GetSharingAdminsRequest} message GetSharingAdminsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSharingAdminsRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.sharedFolderUid = "";
        else {
          object.sharedFolderUid = [];
          if (options.bytes !== Array)
            object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
        }
        if (options.bytes === String) object.recordUid = "";
        else {
          object.recordUid = [];
          if (options.bytes !== Array) object.recordUid = $util.newBuffer(object.recordUid);
        }
        object.username = "";
      }
      if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
        object.sharedFolderUid =
          options.bytes === String
            ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.sharedFolderUid)
              : message.sharedFolderUid;
      if (message.recordUid != null && message.hasOwnProperty("recordUid"))
        object.recordUid =
          options.bytes === String
            ? $util.base64.encode(message.recordUid, 0, message.recordUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.recordUid)
              : message.recordUid;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      return object;
    };

    /**
     * Converts this GetSharingAdminsRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.GetSharingAdminsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSharingAdminsRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetSharingAdminsRequest
     * @function getTypeUrl
     * @memberof Enterprise.GetSharingAdminsRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetSharingAdminsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetSharingAdminsRequest";
    };

    return GetSharingAdminsRequest;
  })();

  Enterprise.UserProfileExt = (function () {
    /**
     * Properties of a UserProfileExt.
     * @memberof Enterprise
     * @interface IUserProfileExt
     * @property {string|null} [email] UserProfileExt email
     * @property {string|null} [fullName] UserProfileExt fullName
     * @property {string|null} [jobTitle] UserProfileExt jobTitle
     * @property {boolean|null} [isMSPMCAdmin] UserProfileExt isMSPMCAdmin
     * @property {boolean|null} [isInSharedFolder] UserProfileExt isInSharedFolder
     * @property {boolean|null} [isShareAdminForRequestedObject] UserProfileExt isShareAdminForRequestedObject
     * @property {boolean|null} [isShareAdminForSharedFolderOwner] UserProfileExt isShareAdminForSharedFolderOwner
     * @property {boolean|null} [hasAccessToObject] UserProfileExt hasAccessToObject
     */

    /**
     * Constructs a new UserProfileExt.
     * @memberof Enterprise
     * @classdesc Represents a UserProfileExt.
     * @implements IUserProfileExt
     * @constructor
     * @param {Enterprise.IUserProfileExt=} [properties] Properties to set
     */
    function UserProfileExt(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserProfileExt email.
     * @member {string} email
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.email = "";

    /**
     * UserProfileExt fullName.
     * @member {string} fullName
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.fullName = "";

    /**
     * UserProfileExt jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.jobTitle = "";

    /**
     * UserProfileExt isMSPMCAdmin.
     * @member {boolean} isMSPMCAdmin
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.isMSPMCAdmin = false;

    /**
     * UserProfileExt isInSharedFolder.
     * @member {boolean} isInSharedFolder
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.isInSharedFolder = false;

    /**
     * UserProfileExt isShareAdminForRequestedObject.
     * @member {boolean} isShareAdminForRequestedObject
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.isShareAdminForRequestedObject = false;

    /**
     * UserProfileExt isShareAdminForSharedFolderOwner.
     * @member {boolean} isShareAdminForSharedFolderOwner
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.isShareAdminForSharedFolderOwner = false;

    /**
     * UserProfileExt hasAccessToObject.
     * @member {boolean} hasAccessToObject
     * @memberof Enterprise.UserProfileExt
     * @instance
     */
    UserProfileExt.prototype.hasAccessToObject = false;

    /**
     * Creates a new UserProfileExt instance using the specified properties.
     * @function create
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Enterprise.IUserProfileExt=} [properties] Properties to set
     * @returns {Enterprise.UserProfileExt} UserProfileExt instance
     */
    UserProfileExt.create = function create(properties) {
      return new UserProfileExt(properties);
    };

    /**
     * Encodes the specified UserProfileExt message. Does not implicitly {@link Enterprise.UserProfileExt.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Enterprise.IUserProfileExt} message UserProfileExt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfileExt.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.email != null && Object.hasOwnProperty.call(message, "email"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.email);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.jobTitle);
      if (message.isMSPMCAdmin != null && Object.hasOwnProperty.call(message, "isMSPMCAdmin"))
        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.isMSPMCAdmin);
      if (
        message.isInSharedFolder != null &&
        Object.hasOwnProperty.call(message, "isInSharedFolder")
      )
        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.isInSharedFolder);
      if (
        message.isShareAdminForRequestedObject != null &&
        Object.hasOwnProperty.call(message, "isShareAdminForRequestedObject")
      )
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.isShareAdminForRequestedObject);
      if (
        message.isShareAdminForSharedFolderOwner != null &&
        Object.hasOwnProperty.call(message, "isShareAdminForSharedFolderOwner")
      )
        writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.isShareAdminForSharedFolderOwner);
      if (
        message.hasAccessToObject != null &&
        Object.hasOwnProperty.call(message, "hasAccessToObject")
      )
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.hasAccessToObject);
      return writer;
    };

    /**
     * Encodes the specified UserProfileExt message, length delimited. Does not implicitly {@link Enterprise.UserProfileExt.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Enterprise.IUserProfileExt} message UserProfileExt message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserProfileExt.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserProfileExt message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UserProfileExt} UserProfileExt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfileExt.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UserProfileExt();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.email = reader.string();
            break;
          }
          case 2: {
            message.fullName = reader.string();
            break;
          }
          case 3: {
            message.jobTitle = reader.string();
            break;
          }
          case 4: {
            message.isMSPMCAdmin = reader.bool();
            break;
          }
          case 5: {
            message.isInSharedFolder = reader.bool();
            break;
          }
          case 6: {
            message.isShareAdminForRequestedObject = reader.bool();
            break;
          }
          case 7: {
            message.isShareAdminForSharedFolderOwner = reader.bool();
            break;
          }
          case 8: {
            message.hasAccessToObject = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a UserProfileExt message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UserProfileExt} UserProfileExt
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserProfileExt.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserProfileExt message.
     * @function verify
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserProfileExt.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.email != null && message.hasOwnProperty("email"))
        if (!$util.isString(message.email)) return "email: string expected";
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.isMSPMCAdmin != null && message.hasOwnProperty("isMSPMCAdmin"))
        if (typeof message.isMSPMCAdmin !== "boolean") return "isMSPMCAdmin: boolean expected";
      if (message.isInSharedFolder != null && message.hasOwnProperty("isInSharedFolder"))
        if (typeof message.isInSharedFolder !== "boolean")
          return "isInSharedFolder: boolean expected";
      if (
        message.isShareAdminForRequestedObject != null &&
        message.hasOwnProperty("isShareAdminForRequestedObject")
      )
        if (typeof message.isShareAdminForRequestedObject !== "boolean")
          return "isShareAdminForRequestedObject: boolean expected";
      if (
        message.isShareAdminForSharedFolderOwner != null &&
        message.hasOwnProperty("isShareAdminForSharedFolderOwner")
      )
        if (typeof message.isShareAdminForSharedFolderOwner !== "boolean")
          return "isShareAdminForSharedFolderOwner: boolean expected";
      if (message.hasAccessToObject != null && message.hasOwnProperty("hasAccessToObject"))
        if (typeof message.hasAccessToObject !== "boolean")
          return "hasAccessToObject: boolean expected";
      return null;
    };

    /**
     * Creates a UserProfileExt message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UserProfileExt} UserProfileExt
     */
    UserProfileExt.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UserProfileExt) return object;
      let message = new $root.Enterprise.UserProfileExt();
      if (object.email != null) message.email = String(object.email);
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.isMSPMCAdmin != null) message.isMSPMCAdmin = Boolean(object.isMSPMCAdmin);
      if (object.isInSharedFolder != null)
        message.isInSharedFolder = Boolean(object.isInSharedFolder);
      if (object.isShareAdminForRequestedObject != null)
        message.isShareAdminForRequestedObject = Boolean(object.isShareAdminForRequestedObject);
      if (object.isShareAdminForSharedFolderOwner != null)
        message.isShareAdminForSharedFolderOwner = Boolean(object.isShareAdminForSharedFolderOwner);
      if (object.hasAccessToObject != null)
        message.hasAccessToObject = Boolean(object.hasAccessToObject);
      return message;
    };

    /**
     * Creates a plain object from a UserProfileExt message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {Enterprise.UserProfileExt} message UserProfileExt
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserProfileExt.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.email = "";
        object.fullName = "";
        object.jobTitle = "";
        object.isMSPMCAdmin = false;
        object.isInSharedFolder = false;
        object.isShareAdminForRequestedObject = false;
        object.isShareAdminForSharedFolderOwner = false;
        object.hasAccessToObject = false;
      }
      if (message.email != null && message.hasOwnProperty("email")) object.email = message.email;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.isMSPMCAdmin != null && message.hasOwnProperty("isMSPMCAdmin"))
        object.isMSPMCAdmin = message.isMSPMCAdmin;
      if (message.isInSharedFolder != null && message.hasOwnProperty("isInSharedFolder"))
        object.isInSharedFolder = message.isInSharedFolder;
      if (
        message.isShareAdminForRequestedObject != null &&
        message.hasOwnProperty("isShareAdminForRequestedObject")
      )
        object.isShareAdminForRequestedObject = message.isShareAdminForRequestedObject;
      if (
        message.isShareAdminForSharedFolderOwner != null &&
        message.hasOwnProperty("isShareAdminForSharedFolderOwner")
      )
        object.isShareAdminForSharedFolderOwner = message.isShareAdminForSharedFolderOwner;
      if (message.hasAccessToObject != null && message.hasOwnProperty("hasAccessToObject"))
        object.hasAccessToObject = message.hasAccessToObject;
      return object;
    };

    /**
     * Converts this UserProfileExt to JSON.
     * @function toJSON
     * @memberof Enterprise.UserProfileExt
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserProfileExt.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UserProfileExt
     * @function getTypeUrl
     * @memberof Enterprise.UserProfileExt
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UserProfileExt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UserProfileExt";
    };

    return UserProfileExt;
  })();

  Enterprise.GetSharingAdminsResponse = (function () {
    /**
     * Properties of a GetSharingAdminsResponse.
     * @memberof Enterprise
     * @interface IGetSharingAdminsResponse
     * @property {Array.<Enterprise.IUserProfileExt>|null} [userProfileExts] GetSharingAdminsResponse userProfileExts
     */

    /**
     * Constructs a new GetSharingAdminsResponse.
     * @memberof Enterprise
     * @classdesc Represents a GetSharingAdminsResponse.
     * @implements IGetSharingAdminsResponse
     * @constructor
     * @param {Enterprise.IGetSharingAdminsResponse=} [properties] Properties to set
     */
    function GetSharingAdminsResponse(properties) {
      this.userProfileExts = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSharingAdminsResponse userProfileExts.
     * @member {Array.<Enterprise.IUserProfileExt>} userProfileExts
     * @memberof Enterprise.GetSharingAdminsResponse
     * @instance
     */
    GetSharingAdminsResponse.prototype.userProfileExts = $util.emptyArray;

    /**
     * Creates a new GetSharingAdminsResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Enterprise.IGetSharingAdminsResponse=} [properties] Properties to set
     * @returns {Enterprise.GetSharingAdminsResponse} GetSharingAdminsResponse instance
     */
    GetSharingAdminsResponse.create = function create(properties) {
      return new GetSharingAdminsResponse(properties);
    };

    /**
     * Encodes the specified GetSharingAdminsResponse message. Does not implicitly {@link Enterprise.GetSharingAdminsResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Enterprise.IGetSharingAdminsResponse} message GetSharingAdminsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingAdminsResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.userProfileExts != null && message.userProfileExts.length)
        for (let i = 0; i < message.userProfileExts.length; ++i)
          $root.Enterprise.UserProfileExt.encode(
            message.userProfileExts[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified GetSharingAdminsResponse message, length delimited. Does not implicitly {@link Enterprise.GetSharingAdminsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Enterprise.IGetSharingAdminsResponse} message GetSharingAdminsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSharingAdminsResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSharingAdminsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.GetSharingAdminsResponse} GetSharingAdminsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingAdminsResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.GetSharingAdminsResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.userProfileExts && message.userProfileExts.length))
              message.userProfileExts = [];
            message.userProfileExts.push(
              $root.Enterprise.UserProfileExt.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a GetSharingAdminsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.GetSharingAdminsResponse} GetSharingAdminsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSharingAdminsResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSharingAdminsResponse message.
     * @function verify
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSharingAdminsResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.userProfileExts != null && message.hasOwnProperty("userProfileExts")) {
        if (!Array.isArray(message.userProfileExts)) return "userProfileExts: array expected";
        for (let i = 0; i < message.userProfileExts.length; ++i) {
          let error = $root.Enterprise.UserProfileExt.verify(message.userProfileExts[i]);
          if (error) return "userProfileExts." + error;
        }
      }
      return null;
    };

    /**
     * Creates a GetSharingAdminsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.GetSharingAdminsResponse} GetSharingAdminsResponse
     */
    GetSharingAdminsResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.GetSharingAdminsResponse) return object;
      let message = new $root.Enterprise.GetSharingAdminsResponse();
      if (object.userProfileExts) {
        if (!Array.isArray(object.userProfileExts))
          throw TypeError(".Enterprise.GetSharingAdminsResponse.userProfileExts: array expected");
        message.userProfileExts = [];
        for (let i = 0; i < object.userProfileExts.length; ++i) {
          if (typeof object.userProfileExts[i] !== "object")
            throw TypeError(
              ".Enterprise.GetSharingAdminsResponse.userProfileExts: object expected",
            );
          message.userProfileExts[i] = $root.Enterprise.UserProfileExt.fromObject(
            object.userProfileExts[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a GetSharingAdminsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {Enterprise.GetSharingAdminsResponse} message GetSharingAdminsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSharingAdminsResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.userProfileExts = [];
      if (message.userProfileExts && message.userProfileExts.length) {
        object.userProfileExts = [];
        for (let j = 0; j < message.userProfileExts.length; ++j)
          object.userProfileExts[j] = $root.Enterprise.UserProfileExt.toObject(
            message.userProfileExts[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this GetSharingAdminsResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.GetSharingAdminsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSharingAdminsResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for GetSharingAdminsResponse
     * @function getTypeUrl
     * @memberof Enterprise.GetSharingAdminsResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    GetSharingAdminsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.GetSharingAdminsResponse";
    };

    return GetSharingAdminsResponse;
  })();

  Enterprise.TeamsEnterpriseUsersAddRequest = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddRequest.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddRequest
     * @property {Array.<Enterprise.ITeamsEnterpriseUsersAddTeamRequest>|null} [teams] TeamsEnterpriseUsersAddRequest teams
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddRequest.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddRequest.
     * @implements ITeamsEnterpriseUsersAddRequest
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddRequest=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddRequest(properties) {
      this.teams = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddRequest teams.
     * @member {Array.<Enterprise.ITeamsEnterpriseUsersAddTeamRequest>} teams
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @instance
     */
    TeamsEnterpriseUsersAddRequest.prototype.teams = $util.emptyArray;

    /**
     * Creates a new TeamsEnterpriseUsersAddRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddRequest=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddRequest} TeamsEnterpriseUsersAddRequest instance
     */
    TeamsEnterpriseUsersAddRequest.create = function create(properties) {
      return new TeamsEnterpriseUsersAddRequest(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddRequest message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddRequest} message TeamsEnterpriseUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teams != null && message.teams.length)
        for (let i = 0; i < message.teams.length; ++i)
          $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest.encode(
            message.teams[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddRequest message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddRequest} message TeamsEnterpriseUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddRequest} TeamsEnterpriseUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.teams && message.teams.length)) message.teams = [];
            message.teams.push(
              $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddRequest} TeamsEnterpriseUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddRequest message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teams != null && message.hasOwnProperty("teams")) {
        if (!Array.isArray(message.teams)) return "teams: array expected";
        for (let i = 0; i < message.teams.length; ++i) {
          let error = $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest.verify(message.teams[i]);
          if (error) return "teams." + error;
        }
      }
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddRequest} TeamsEnterpriseUsersAddRequest
     */
    TeamsEnterpriseUsersAddRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddRequest) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddRequest();
      if (object.teams) {
        if (!Array.isArray(object.teams))
          throw TypeError(".Enterprise.TeamsEnterpriseUsersAddRequest.teams: array expected");
        message.teams = [];
        for (let i = 0; i < object.teams.length; ++i) {
          if (typeof object.teams[i] !== "object")
            throw TypeError(".Enterprise.TeamsEnterpriseUsersAddRequest.teams: object expected");
          message.teams[i] = $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest.fromObject(
            object.teams[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddRequest} message TeamsEnterpriseUsersAddRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.teams = [];
      if (message.teams && message.teams.length) {
        object.teams = [];
        for (let j = 0; j < message.teams.length; ++j)
          object.teams[j] = $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest.toObject(
            message.teams[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddRequest
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddRequest";
    };

    return TeamsEnterpriseUsersAddRequest;
  })();

  Enterprise.TeamsEnterpriseUsersAddTeamRequest = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddTeamRequest.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddTeamRequest
     * @property {Uint8Array|null} [teamUid] TeamsEnterpriseUsersAddTeamRequest teamUid
     * @property {Array.<Enterprise.ITeamsEnterpriseUsersAddUserRequest>|null} [users] TeamsEnterpriseUsersAddTeamRequest users
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddTeamRequest.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddTeamRequest.
     * @implements ITeamsEnterpriseUsersAddTeamRequest
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamRequest=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddTeamRequest(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddTeamRequest teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @instance
     */
    TeamsEnterpriseUsersAddTeamRequest.prototype.teamUid = $util.newBuffer([]);

    /**
     * TeamsEnterpriseUsersAddTeamRequest users.
     * @member {Array.<Enterprise.ITeamsEnterpriseUsersAddUserRequest>} users
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @instance
     */
    TeamsEnterpriseUsersAddTeamRequest.prototype.users = $util.emptyArray;

    /**
     * Creates a new TeamsEnterpriseUsersAddTeamRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamRequest=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamRequest} TeamsEnterpriseUsersAddTeamRequest instance
     */
    TeamsEnterpriseUsersAddTeamRequest.create = function create(properties) {
      return new TeamsEnterpriseUsersAddTeamRequest(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddTeamRequest message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddTeamRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamRequest} message TeamsEnterpriseUsersAddTeamRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddTeamRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.TeamsEnterpriseUsersAddUserRequest.encode(
            message.users[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddTeamRequest message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddTeamRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamRequest} message TeamsEnterpriseUsersAddTeamRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddTeamRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddTeamRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamRequest} TeamsEnterpriseUsersAddTeamRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddTeamRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push(
              $root.Enterprise.TeamsEnterpriseUsersAddUserRequest.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddTeamRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamRequest} TeamsEnterpriseUsersAddTeamRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddTeamRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddTeamRequest message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddTeamRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.TeamsEnterpriseUsersAddUserRequest.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddTeamRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamRequest} TeamsEnterpriseUsersAddTeamRequest
     */
    TeamsEnterpriseUsersAddTeamRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddTeamRequest();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.TeamsEnterpriseUsersAddTeamRequest.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(
              ".Enterprise.TeamsEnterpriseUsersAddTeamRequest.users: object expected",
            );
          message.users[i] = $root.Enterprise.TeamsEnterpriseUsersAddUserRequest.fromObject(
            object.users[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddTeamRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddTeamRequest} message TeamsEnterpriseUsersAddTeamRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddTeamRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (options.defaults)
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.TeamsEnterpriseUsersAddUserRequest.toObject(
            message.users[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddTeamRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddTeamRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddTeamRequest
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddTeamRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddTeamRequest";
    };

    return TeamsEnterpriseUsersAddTeamRequest;
  })();

  Enterprise.TeamsEnterpriseUsersAddUserRequest = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddUserRequest.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddUserRequest
     * @property {number|Long|null} [enterpriseUserId] TeamsEnterpriseUsersAddUserRequest enterpriseUserId
     * @property {Enterprise.TeamUserType|null} [userType] TeamsEnterpriseUsersAddUserRequest userType
     * @property {string|null} [teamKey] TeamsEnterpriseUsersAddUserRequest teamKey
     * @property {Enterprise.ITypedKey|null} [typedTeamKey] TeamsEnterpriseUsersAddUserRequest typedTeamKey
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddUserRequest.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddUserRequest.
     * @implements ITeamsEnterpriseUsersAddUserRequest
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserRequest=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddUserRequest(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddUserRequest enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @instance
     */
    TeamsEnterpriseUsersAddUserRequest.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * TeamsEnterpriseUsersAddUserRequest userType.
     * @member {Enterprise.TeamUserType} userType
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @instance
     */
    TeamsEnterpriseUsersAddUserRequest.prototype.userType = 0;

    /**
     * TeamsEnterpriseUsersAddUserRequest teamKey.
     * @member {string} teamKey
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @instance
     */
    TeamsEnterpriseUsersAddUserRequest.prototype.teamKey = "";

    /**
     * TeamsEnterpriseUsersAddUserRequest typedTeamKey.
     * @member {Enterprise.ITypedKey|null|undefined} typedTeamKey
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @instance
     */
    TeamsEnterpriseUsersAddUserRequest.prototype.typedTeamKey = null;

    /**
     * Creates a new TeamsEnterpriseUsersAddUserRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserRequest=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserRequest} TeamsEnterpriseUsersAddUserRequest instance
     */
    TeamsEnterpriseUsersAddUserRequest.create = function create(properties) {
      return new TeamsEnterpriseUsersAddUserRequest(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddUserRequest message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddUserRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserRequest} message TeamsEnterpriseUsersAddUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddUserRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.userType != null && Object.hasOwnProperty.call(message, "userType"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.userType);
      if (message.teamKey != null && Object.hasOwnProperty.call(message, "teamKey"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.teamKey);
      if (message.typedTeamKey != null && Object.hasOwnProperty.call(message, "typedTeamKey"))
        $root.Enterprise.TypedKey.encode(
          message.typedTeamKey,
          writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
        ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddUserRequest message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddUserRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserRequest} message TeamsEnterpriseUsersAddUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddUserRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserRequest} TeamsEnterpriseUsersAddUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddUserRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddUserRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.userType = reader.int32();
            break;
          }
          case 3: {
            message.teamKey = reader.string();
            break;
          }
          case 4: {
            message.typedTeamKey = $root.Enterprise.TypedKey.decode(reader, reader.uint32());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddUserRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserRequest} TeamsEnterpriseUsersAddUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddUserRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddUserRequest message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddUserRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.userType != null && message.hasOwnProperty("userType"))
        switch (message.userType) {
          default:
            return "userType: enum value expected";
          case 0:
          case 1:
          case 2:
            break;
        }
      if (message.teamKey != null && message.hasOwnProperty("teamKey"))
        if (!$util.isString(message.teamKey)) return "teamKey: string expected";
      if (message.typedTeamKey != null && message.hasOwnProperty("typedTeamKey")) {
        let error = $root.Enterprise.TypedKey.verify(message.typedTeamKey);
        if (error) return "typedTeamKey." + error;
      }
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddUserRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserRequest} TeamsEnterpriseUsersAddUserRequest
     */
    TeamsEnterpriseUsersAddUserRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddUserRequest) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddUserRequest();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      switch (object.userType) {
        default:
          if (typeof object.userType === "number") {
            message.userType = object.userType;
            break;
          }
          break;
        case "USER":
        case 0:
          message.userType = 0;
          break;
        case "ADMIN":
        case 1:
          message.userType = 1;
          break;
        case "ADMIN_ONLY":
        case 2:
          message.userType = 2;
          break;
      }
      if (object.teamKey != null) message.teamKey = String(object.teamKey);
      if (object.typedTeamKey != null) {
        if (typeof object.typedTeamKey !== "object")
          throw TypeError(
            ".Enterprise.TeamsEnterpriseUsersAddUserRequest.typedTeamKey: object expected",
          );
        message.typedTeamKey = $root.Enterprise.TypedKey.fromObject(object.typedTeamKey);
      }
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddUserRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddUserRequest} message TeamsEnterpriseUsersAddUserRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddUserRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.userType = options.enums === String ? "USER" : 0;
        object.teamKey = "";
        object.typedTeamKey = null;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.userType != null && message.hasOwnProperty("userType"))
        object.userType =
          options.enums === String
            ? $root.Enterprise.TeamUserType[message.userType] === undefined
              ? message.userType
              : $root.Enterprise.TeamUserType[message.userType]
            : message.userType;
      if (message.teamKey != null && message.hasOwnProperty("teamKey"))
        object.teamKey = message.teamKey;
      if (message.typedTeamKey != null && message.hasOwnProperty("typedTeamKey"))
        object.typedTeamKey = $root.Enterprise.TypedKey.toObject(message.typedTeamKey, options);
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddUserRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddUserRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddUserRequest
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddUserRequest";
    };

    return TeamsEnterpriseUsersAddUserRequest;
  })();

  Enterprise.TypedKey = (function () {
    /**
     * Properties of a TypedKey.
     * @memberof Enterprise
     * @interface ITypedKey
     * @property {Uint8Array|null} [key] TypedKey key
     * @property {Enterprise.EncryptedKeyType|null} [keyType] TypedKey keyType
     */

    /**
     * Constructs a new TypedKey.
     * @memberof Enterprise
     * @classdesc Represents a TypedKey.
     * @implements ITypedKey
     * @constructor
     * @param {Enterprise.ITypedKey=} [properties] Properties to set
     */
    function TypedKey(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TypedKey key.
     * @member {Uint8Array} key
     * @memberof Enterprise.TypedKey
     * @instance
     */
    TypedKey.prototype.key = $util.newBuffer([]);

    /**
     * TypedKey keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.TypedKey
     * @instance
     */
    TypedKey.prototype.keyType = 0;

    /**
     * Creates a new TypedKey instance using the specified properties.
     * @function create
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Enterprise.ITypedKey=} [properties] Properties to set
     * @returns {Enterprise.TypedKey} TypedKey instance
     */
    TypedKey.create = function create(properties) {
      return new TypedKey(properties);
    };

    /**
     * Encodes the specified TypedKey message. Does not implicitly {@link Enterprise.TypedKey.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Enterprise.ITypedKey} message TypedKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypedKey.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.key != null && Object.hasOwnProperty.call(message, "key"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.keyType);
      return writer;
    };

    /**
     * Encodes the specified TypedKey message, length delimited. Does not implicitly {@link Enterprise.TypedKey.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Enterprise.ITypedKey} message TypedKey message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypedKey.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TypedKey message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TypedKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TypedKey} TypedKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypedKey.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TypedKey();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.key = reader.bytes();
            break;
          }
          case 2: {
            message.keyType = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TypedKey message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TypedKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TypedKey} TypedKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypedKey.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TypedKey message.
     * @function verify
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TypedKey.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.key != null && message.hasOwnProperty("key"))
        if (
          !((message.key && typeof message.key.length === "number") || $util.isString(message.key))
        )
          return "key: buffer expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a TypedKey message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TypedKey} TypedKey
     */
    TypedKey.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TypedKey) return object;
      let message = new $root.Enterprise.TypedKey();
      if (object.key != null)
        if (typeof object.key === "string")
          $util.base64.decode(
            object.key,
            (message.key = $util.newBuffer($util.base64.length(object.key))),
            0,
          );
        else if (object.key.length >= 0) message.key = object.key;
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a TypedKey message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TypedKey
     * @static
     * @param {Enterprise.TypedKey} message TypedKey
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TypedKey.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String) object.key = "";
        else {
          object.key = [];
          if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
        }
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
      }
      if (message.key != null && message.hasOwnProperty("key"))
        object.key =
          options.bytes === String
            ? $util.base64.encode(message.key, 0, message.key.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.key)
              : message.key;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      return object;
    };

    /**
     * Converts this TypedKey to JSON.
     * @function toJSON
     * @memberof Enterprise.TypedKey
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TypedKey.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TypedKey
     * @function getTypeUrl
     * @memberof Enterprise.TypedKey
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TypedKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TypedKey";
    };

    return TypedKey;
  })();

  Enterprise.TeamsEnterpriseUsersAddResponse = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddResponse.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddResponse
     * @property {Array.<Enterprise.ITeamsEnterpriseUsersAddTeamResponse>|null} [teams] TeamsEnterpriseUsersAddResponse teams
     * @property {number|Long|null} [revision] TeamsEnterpriseUsersAddResponse revision
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddResponse.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddResponse.
     * @implements ITeamsEnterpriseUsersAddResponse
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddResponse=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddResponse(properties) {
      this.teams = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddResponse teams.
     * @member {Array.<Enterprise.ITeamsEnterpriseUsersAddTeamResponse>} teams
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @instance
     */
    TeamsEnterpriseUsersAddResponse.prototype.teams = $util.emptyArray;

    /**
     * TeamsEnterpriseUsersAddResponse revision.
     * @member {number|Long} revision
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @instance
     */
    TeamsEnterpriseUsersAddResponse.prototype.revision = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * Creates a new TeamsEnterpriseUsersAddResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddResponse=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddResponse} TeamsEnterpriseUsersAddResponse instance
     */
    TeamsEnterpriseUsersAddResponse.create = function create(properties) {
      return new TeamsEnterpriseUsersAddResponse(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddResponse message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddResponse} message TeamsEnterpriseUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teams != null && message.teams.length)
        for (let i = 0; i < message.teams.length; ++i)
          $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse.encode(
            message.teams[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.revision);
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddResponse message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddResponse} message TeamsEnterpriseUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddResponse} TeamsEnterpriseUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.teams && message.teams.length)) message.teams = [];
            message.teams.push(
              $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            message.revision = reader.int64();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddResponse} TeamsEnterpriseUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddResponse message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teams != null && message.hasOwnProperty("teams")) {
        if (!Array.isArray(message.teams)) return "teams: array expected";
        for (let i = 0; i < message.teams.length; ++i) {
          let error = $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse.verify(message.teams[i]);
          if (error) return "teams." + error;
        }
      }
      if (message.revision != null && message.hasOwnProperty("revision"))
        if (
          !$util.isInteger(message.revision) &&
          !(
            message.revision &&
            $util.isInteger(message.revision.low) &&
            $util.isInteger(message.revision.high)
          )
        )
          return "revision: integer|Long expected";
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddResponse} TeamsEnterpriseUsersAddResponse
     */
    TeamsEnterpriseUsersAddResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddResponse) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddResponse();
      if (object.teams) {
        if (!Array.isArray(object.teams))
          throw TypeError(".Enterprise.TeamsEnterpriseUsersAddResponse.teams: array expected");
        message.teams = [];
        for (let i = 0; i < object.teams.length; ++i) {
          if (typeof object.teams[i] !== "object")
            throw TypeError(".Enterprise.TeamsEnterpriseUsersAddResponse.teams: object expected");
          message.teams[i] = $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse.fromObject(
            object.teams[i],
          );
        }
      }
      if (object.revision != null)
        if ($util.Long) (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
        else if (typeof object.revision === "string")
          message.revision = parseInt(object.revision, 10);
        else if (typeof object.revision === "number") message.revision = object.revision;
        else if (typeof object.revision === "object")
          message.revision = new $util.LongBits(
            object.revision.low >>> 0,
            object.revision.high >>> 0,
          ).toNumber();
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddResponse} message TeamsEnterpriseUsersAddResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.teams = [];
      if (options.defaults)
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.revision =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.revision = options.longs === String ? "0" : 0;
      if (message.teams && message.teams.length) {
        object.teams = [];
        for (let j = 0; j < message.teams.length; ++j)
          object.teams[j] = $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse.toObject(
            message.teams[j],
            options,
          );
      }
      if (message.revision != null && message.hasOwnProperty("revision"))
        if (typeof message.revision === "number")
          object.revision = options.longs === String ? String(message.revision) : message.revision;
        else
          object.revision =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.revision)
              : options.longs === Number
                ? new $util.LongBits(
                    message.revision.low >>> 0,
                    message.revision.high >>> 0,
                  ).toNumber()
                : message.revision;
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddResponse
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddResponse";
    };

    return TeamsEnterpriseUsersAddResponse;
  })();

  Enterprise.TeamsEnterpriseUsersAddTeamResponse = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddTeamResponse.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddTeamResponse
     * @property {Uint8Array|null} [teamUid] TeamsEnterpriseUsersAddTeamResponse teamUid
     * @property {Array.<Enterprise.ITeamsEnterpriseUsersAddUserResponse>|null} [users] TeamsEnterpriseUsersAddTeamResponse users
     * @property {boolean|null} [success] TeamsEnterpriseUsersAddTeamResponse success
     * @property {string|null} [message] TeamsEnterpriseUsersAddTeamResponse message
     * @property {string|null} [resultCode] TeamsEnterpriseUsersAddTeamResponse resultCode
     * @property {string|null} [additionalInfo] TeamsEnterpriseUsersAddTeamResponse additionalInfo
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddTeamResponse.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddTeamResponse.
     * @implements ITeamsEnterpriseUsersAddTeamResponse
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamResponse=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddTeamResponse(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddTeamResponse teamUid.
     * @member {Uint8Array} teamUid
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.teamUid = $util.newBuffer([]);

    /**
     * TeamsEnterpriseUsersAddTeamResponse users.
     * @member {Array.<Enterprise.ITeamsEnterpriseUsersAddUserResponse>} users
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.users = $util.emptyArray;

    /**
     * TeamsEnterpriseUsersAddTeamResponse success.
     * @member {boolean} success
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.success = false;

    /**
     * TeamsEnterpriseUsersAddTeamResponse message.
     * @member {string} message
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.message = "";

    /**
     * TeamsEnterpriseUsersAddTeamResponse resultCode.
     * @member {string} resultCode
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.resultCode = "";

    /**
     * TeamsEnterpriseUsersAddTeamResponse additionalInfo.
     * @member {string} additionalInfo
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.additionalInfo = "";

    /**
     * Creates a new TeamsEnterpriseUsersAddTeamResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamResponse=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamResponse} TeamsEnterpriseUsersAddTeamResponse instance
     */
    TeamsEnterpriseUsersAddTeamResponse.create = function create(properties) {
      return new TeamsEnterpriseUsersAddTeamResponse(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddTeamResponse message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddTeamResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamResponse} message TeamsEnterpriseUsersAddTeamResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddTeamResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.teamUid != null && Object.hasOwnProperty.call(message, "teamUid"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.teamUid);
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.TeamsEnterpriseUsersAddUserResponse.encode(
            message.users[i],
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
      if (message.success != null && Object.hasOwnProperty.call(message, "success"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.success);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      if (message.resultCode != null && Object.hasOwnProperty.call(message, "resultCode"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.resultCode);
      if (message.additionalInfo != null && Object.hasOwnProperty.call(message, "additionalInfo"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.additionalInfo);
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddTeamResponse message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddTeamResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddTeamResponse} message TeamsEnterpriseUsersAddTeamResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddTeamResponse.encodeDelimited = function encodeDelimited(
      message,
      writer,
    ) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddTeamResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamResponse} TeamsEnterpriseUsersAddTeamResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddTeamResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.teamUid = reader.bytes();
            break;
          }
          case 2: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push(
              $root.Enterprise.TeamsEnterpriseUsersAddUserResponse.decode(reader, reader.uint32()),
            );
            break;
          }
          case 3: {
            message.success = reader.bool();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          case 5: {
            message.resultCode = reader.string();
            break;
          }
          case 6: {
            message.additionalInfo = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddTeamResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamResponse} TeamsEnterpriseUsersAddTeamResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddTeamResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddTeamResponse message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddTeamResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        if (
          !(
            (message.teamUid && typeof message.teamUid.length === "number") ||
            $util.isString(message.teamUid)
          )
        )
          return "teamUid: buffer expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.TeamsEnterpriseUsersAddUserResponse.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      if (message.success != null && message.hasOwnProperty("success"))
        if (typeof message.success !== "boolean") return "success: boolean expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      if (message.resultCode != null && message.hasOwnProperty("resultCode"))
        if (!$util.isString(message.resultCode)) return "resultCode: string expected";
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        if (!$util.isString(message.additionalInfo)) return "additionalInfo: string expected";
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddTeamResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddTeamResponse} TeamsEnterpriseUsersAddTeamResponse
     */
    TeamsEnterpriseUsersAddTeamResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddTeamResponse();
      if (object.teamUid != null)
        if (typeof object.teamUid === "string")
          $util.base64.decode(
            object.teamUid,
            (message.teamUid = $util.newBuffer($util.base64.length(object.teamUid))),
            0,
          );
        else if (object.teamUid.length >= 0) message.teamUid = object.teamUid;
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.TeamsEnterpriseUsersAddTeamResponse.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(
              ".Enterprise.TeamsEnterpriseUsersAddTeamResponse.users: object expected",
            );
          message.users[i] = $root.Enterprise.TeamsEnterpriseUsersAddUserResponse.fromObject(
            object.users[i],
          );
        }
      }
      if (object.success != null) message.success = Boolean(object.success);
      if (object.message != null) message.message = String(object.message);
      if (object.resultCode != null) message.resultCode = String(object.resultCode);
      if (object.additionalInfo != null) message.additionalInfo = String(object.additionalInfo);
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddTeamResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddTeamResponse} message TeamsEnterpriseUsersAddTeamResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddTeamResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (options.defaults) {
        if (options.bytes === String) object.teamUid = "";
        else {
          object.teamUid = [];
          if (options.bytes !== Array) object.teamUid = $util.newBuffer(object.teamUid);
        }
        object.success = false;
        object.message = "";
        object.resultCode = "";
        object.additionalInfo = "";
      }
      if (message.teamUid != null && message.hasOwnProperty("teamUid"))
        object.teamUid =
          options.bytes === String
            ? $util.base64.encode(message.teamUid, 0, message.teamUid.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.teamUid)
              : message.teamUid;
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.TeamsEnterpriseUsersAddUserResponse.toObject(
            message.users[j],
            options,
          );
      }
      if (message.success != null && message.hasOwnProperty("success"))
        object.success = message.success;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      if (message.resultCode != null && message.hasOwnProperty("resultCode"))
        object.resultCode = message.resultCode;
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        object.additionalInfo = message.additionalInfo;
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddTeamResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddTeamResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddTeamResponse
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddTeamResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddTeamResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddTeamResponse";
    };

    return TeamsEnterpriseUsersAddTeamResponse;
  })();

  Enterprise.TeamsEnterpriseUsersAddUserResponse = (function () {
    /**
     * Properties of a TeamsEnterpriseUsersAddUserResponse.
     * @memberof Enterprise
     * @interface ITeamsEnterpriseUsersAddUserResponse
     * @property {number|Long|null} [enterpriseUserId] TeamsEnterpriseUsersAddUserResponse enterpriseUserId
     * @property {number|Long|null} [revision] TeamsEnterpriseUsersAddUserResponse revision
     * @property {boolean|null} [success] TeamsEnterpriseUsersAddUserResponse success
     * @property {string|null} [message] TeamsEnterpriseUsersAddUserResponse message
     * @property {string|null} [resultCode] TeamsEnterpriseUsersAddUserResponse resultCode
     * @property {string|null} [additionalInfo] TeamsEnterpriseUsersAddUserResponse additionalInfo
     */

    /**
     * Constructs a new TeamsEnterpriseUsersAddUserResponse.
     * @memberof Enterprise
     * @classdesc Represents a TeamsEnterpriseUsersAddUserResponse.
     * @implements ITeamsEnterpriseUsersAddUserResponse
     * @constructor
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserResponse=} [properties] Properties to set
     */
    function TeamsEnterpriseUsersAddUserResponse(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeamsEnterpriseUsersAddUserResponse enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * TeamsEnterpriseUsersAddUserResponse revision.
     * @member {number|Long} revision
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.revision = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * TeamsEnterpriseUsersAddUserResponse success.
     * @member {boolean} success
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.success = false;

    /**
     * TeamsEnterpriseUsersAddUserResponse message.
     * @member {string} message
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.message = "";

    /**
     * TeamsEnterpriseUsersAddUserResponse resultCode.
     * @member {string} resultCode
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.resultCode = "";

    /**
     * TeamsEnterpriseUsersAddUserResponse additionalInfo.
     * @member {string} additionalInfo
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.additionalInfo = "";

    /**
     * Creates a new TeamsEnterpriseUsersAddUserResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserResponse=} [properties] Properties to set
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserResponse} TeamsEnterpriseUsersAddUserResponse instance
     */
    TeamsEnterpriseUsersAddUserResponse.create = function create(properties) {
      return new TeamsEnterpriseUsersAddUserResponse(properties);
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddUserResponse message. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddUserResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserResponse} message TeamsEnterpriseUsersAddUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddUserResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.revision);
      if (message.success != null && Object.hasOwnProperty.call(message, "success"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.success);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      if (message.resultCode != null && Object.hasOwnProperty.call(message, "resultCode"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.resultCode);
      if (message.additionalInfo != null && Object.hasOwnProperty.call(message, "additionalInfo"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.additionalInfo);
      return writer;
    };

    /**
     * Encodes the specified TeamsEnterpriseUsersAddUserResponse message, length delimited. Does not implicitly {@link Enterprise.TeamsEnterpriseUsersAddUserResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Enterprise.ITeamsEnterpriseUsersAddUserResponse} message TeamsEnterpriseUsersAddUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeamsEnterpriseUsersAddUserResponse.encodeDelimited = function encodeDelimited(
      message,
      writer,
    ) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddUserResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserResponse} TeamsEnterpriseUsersAddUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddUserResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.TeamsEnterpriseUsersAddUserResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.revision = reader.int64();
            break;
          }
          case 3: {
            message.success = reader.bool();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          case 5: {
            message.resultCode = reader.string();
            break;
          }
          case 6: {
            message.additionalInfo = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a TeamsEnterpriseUsersAddUserResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserResponse} TeamsEnterpriseUsersAddUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeamsEnterpriseUsersAddUserResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeamsEnterpriseUsersAddUserResponse message.
     * @function verify
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeamsEnterpriseUsersAddUserResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.revision != null && message.hasOwnProperty("revision"))
        if (
          !$util.isInteger(message.revision) &&
          !(
            message.revision &&
            $util.isInteger(message.revision.low) &&
            $util.isInteger(message.revision.high)
          )
        )
          return "revision: integer|Long expected";
      if (message.success != null && message.hasOwnProperty("success"))
        if (typeof message.success !== "boolean") return "success: boolean expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      if (message.resultCode != null && message.hasOwnProperty("resultCode"))
        if (!$util.isString(message.resultCode)) return "resultCode: string expected";
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        if (!$util.isString(message.additionalInfo)) return "additionalInfo: string expected";
      return null;
    };

    /**
     * Creates a TeamsEnterpriseUsersAddUserResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.TeamsEnterpriseUsersAddUserResponse} TeamsEnterpriseUsersAddUserResponse
     */
    TeamsEnterpriseUsersAddUserResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.TeamsEnterpriseUsersAddUserResponse) return object;
      let message = new $root.Enterprise.TeamsEnterpriseUsersAddUserResponse();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.revision != null)
        if ($util.Long) (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
        else if (typeof object.revision === "string")
          message.revision = parseInt(object.revision, 10);
        else if (typeof object.revision === "number") message.revision = object.revision;
        else if (typeof object.revision === "object")
          message.revision = new $util.LongBits(
            object.revision.low >>> 0,
            object.revision.high >>> 0,
          ).toNumber();
      if (object.success != null) message.success = Boolean(object.success);
      if (object.message != null) message.message = String(object.message);
      if (object.resultCode != null) message.resultCode = String(object.resultCode);
      if (object.additionalInfo != null) message.additionalInfo = String(object.additionalInfo);
      return message;
    };

    /**
     * Creates a plain object from a TeamsEnterpriseUsersAddUserResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {Enterprise.TeamsEnterpriseUsersAddUserResponse} message TeamsEnterpriseUsersAddUserResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeamsEnterpriseUsersAddUserResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.revision =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.revision = options.longs === String ? "0" : 0;
        object.success = false;
        object.message = "";
        object.resultCode = "";
        object.additionalInfo = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.revision != null && message.hasOwnProperty("revision"))
        if (typeof message.revision === "number")
          object.revision = options.longs === String ? String(message.revision) : message.revision;
        else
          object.revision =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.revision)
              : options.longs === Number
                ? new $util.LongBits(
                    message.revision.low >>> 0,
                    message.revision.high >>> 0,
                  ).toNumber()
                : message.revision;
      if (message.success != null && message.hasOwnProperty("success"))
        object.success = message.success;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      if (message.resultCode != null && message.hasOwnProperty("resultCode"))
        object.resultCode = message.resultCode;
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        object.additionalInfo = message.additionalInfo;
      return object;
    };

    /**
     * Converts this TeamsEnterpriseUsersAddUserResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeamsEnterpriseUsersAddUserResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeamsEnterpriseUsersAddUserResponse
     * @function getTypeUrl
     * @memberof Enterprise.TeamsEnterpriseUsersAddUserResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeamsEnterpriseUsersAddUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.TeamsEnterpriseUsersAddUserResponse";
    };

    return TeamsEnterpriseUsersAddUserResponse;
  })();

  Enterprise.DomainAlias = (function () {
    /**
     * Properties of a DomainAlias.
     * @memberof Enterprise
     * @interface IDomainAlias
     * @property {string|null} [domain] DomainAlias domain
     * @property {string|null} [alias] DomainAlias alias
     * @property {number|null} [status] DomainAlias status
     * @property {string|null} [message] DomainAlias message
     */

    /**
     * Constructs a new DomainAlias.
     * @memberof Enterprise
     * @classdesc Represents a DomainAlias.
     * @implements IDomainAlias
     * @constructor
     * @param {Enterprise.IDomainAlias=} [properties] Properties to set
     */
    function DomainAlias(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainAlias domain.
     * @member {string} domain
     * @memberof Enterprise.DomainAlias
     * @instance
     */
    DomainAlias.prototype.domain = "";

    /**
     * DomainAlias alias.
     * @member {string} alias
     * @memberof Enterprise.DomainAlias
     * @instance
     */
    DomainAlias.prototype.alias = "";

    /**
     * DomainAlias status.
     * @member {number} status
     * @memberof Enterprise.DomainAlias
     * @instance
     */
    DomainAlias.prototype.status = 0;

    /**
     * DomainAlias message.
     * @member {string} message
     * @memberof Enterprise.DomainAlias
     * @instance
     */
    DomainAlias.prototype.message = "";

    /**
     * Creates a new DomainAlias instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Enterprise.IDomainAlias=} [properties] Properties to set
     * @returns {Enterprise.DomainAlias} DomainAlias instance
     */
    DomainAlias.create = function create(properties) {
      return new DomainAlias(properties);
    };

    /**
     * Encodes the specified DomainAlias message. Does not implicitly {@link Enterprise.DomainAlias.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Enterprise.IDomainAlias} message DomainAlias message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAlias.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.domain);
      if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.alias);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.status);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      return writer;
    };

    /**
     * Encodes the specified DomainAlias message, length delimited. Does not implicitly {@link Enterprise.DomainAlias.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Enterprise.IDomainAlias} message DomainAlias message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAlias.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainAlias message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainAlias} DomainAlias
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAlias.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainAlias();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.domain = reader.string();
            break;
          }
          case 2: {
            message.alias = reader.string();
            break;
          }
          case 3: {
            message.status = reader.int32();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainAlias message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainAlias} DomainAlias
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAlias.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainAlias message.
     * @function verify
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainAlias.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.domain != null && message.hasOwnProperty("domain"))
        if (!$util.isString(message.domain)) return "domain: string expected";
      if (message.alias != null && message.hasOwnProperty("alias"))
        if (!$util.isString(message.alias)) return "alias: string expected";
      if (message.status != null && message.hasOwnProperty("status"))
        if (!$util.isInteger(message.status)) return "status: integer expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      return null;
    };

    /**
     * Creates a DomainAlias message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainAlias} DomainAlias
     */
    DomainAlias.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainAlias) return object;
      let message = new $root.Enterprise.DomainAlias();
      if (object.domain != null) message.domain = String(object.domain);
      if (object.alias != null) message.alias = String(object.alias);
      if (object.status != null) message.status = object.status | 0;
      if (object.message != null) message.message = String(object.message);
      return message;
    };

    /**
     * Creates a plain object from a DomainAlias message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {Enterprise.DomainAlias} message DomainAlias
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainAlias.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        object.domain = "";
        object.alias = "";
        object.status = 0;
        object.message = "";
      }
      if (message.domain != null && message.hasOwnProperty("domain"))
        object.domain = message.domain;
      if (message.alias != null && message.hasOwnProperty("alias")) object.alias = message.alias;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status = message.status;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      return object;
    };

    /**
     * Converts this DomainAlias to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainAlias
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainAlias.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainAlias
     * @function getTypeUrl
     * @memberof Enterprise.DomainAlias
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainAlias.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainAlias";
    };

    return DomainAlias;
  })();

  Enterprise.DomainAliasRequest = (function () {
    /**
     * Properties of a DomainAliasRequest.
     * @memberof Enterprise
     * @interface IDomainAliasRequest
     * @property {Array.<Enterprise.IDomainAlias>|null} [domainAlias] DomainAliasRequest domainAlias
     */

    /**
     * Constructs a new DomainAliasRequest.
     * @memberof Enterprise
     * @classdesc Represents a DomainAliasRequest.
     * @implements IDomainAliasRequest
     * @constructor
     * @param {Enterprise.IDomainAliasRequest=} [properties] Properties to set
     */
    function DomainAliasRequest(properties) {
      this.domainAlias = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainAliasRequest domainAlias.
     * @member {Array.<Enterprise.IDomainAlias>} domainAlias
     * @memberof Enterprise.DomainAliasRequest
     * @instance
     */
    DomainAliasRequest.prototype.domainAlias = $util.emptyArray;

    /**
     * Creates a new DomainAliasRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Enterprise.IDomainAliasRequest=} [properties] Properties to set
     * @returns {Enterprise.DomainAliasRequest} DomainAliasRequest instance
     */
    DomainAliasRequest.create = function create(properties) {
      return new DomainAliasRequest(properties);
    };

    /**
     * Encodes the specified DomainAliasRequest message. Does not implicitly {@link Enterprise.DomainAliasRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Enterprise.IDomainAliasRequest} message DomainAliasRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAliasRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.domainAlias != null && message.domainAlias.length)
        for (let i = 0; i < message.domainAlias.length; ++i)
          $root.Enterprise.DomainAlias.encode(
            message.domainAlias[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified DomainAliasRequest message, length delimited. Does not implicitly {@link Enterprise.DomainAliasRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Enterprise.IDomainAliasRequest} message DomainAliasRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAliasRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainAliasRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainAliasRequest} DomainAliasRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAliasRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainAliasRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.domainAlias && message.domainAlias.length)) message.domainAlias = [];
            message.domainAlias.push($root.Enterprise.DomainAlias.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainAliasRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainAliasRequest} DomainAliasRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAliasRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainAliasRequest message.
     * @function verify
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainAliasRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.domainAlias != null && message.hasOwnProperty("domainAlias")) {
        if (!Array.isArray(message.domainAlias)) return "domainAlias: array expected";
        for (let i = 0; i < message.domainAlias.length; ++i) {
          let error = $root.Enterprise.DomainAlias.verify(message.domainAlias[i]);
          if (error) return "domainAlias." + error;
        }
      }
      return null;
    };

    /**
     * Creates a DomainAliasRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainAliasRequest} DomainAliasRequest
     */
    DomainAliasRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainAliasRequest) return object;
      let message = new $root.Enterprise.DomainAliasRequest();
      if (object.domainAlias) {
        if (!Array.isArray(object.domainAlias))
          throw TypeError(".Enterprise.DomainAliasRequest.domainAlias: array expected");
        message.domainAlias = [];
        for (let i = 0; i < object.domainAlias.length; ++i) {
          if (typeof object.domainAlias[i] !== "object")
            throw TypeError(".Enterprise.DomainAliasRequest.domainAlias: object expected");
          message.domainAlias[i] = $root.Enterprise.DomainAlias.fromObject(object.domainAlias[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a DomainAliasRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {Enterprise.DomainAliasRequest} message DomainAliasRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainAliasRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.domainAlias = [];
      if (message.domainAlias && message.domainAlias.length) {
        object.domainAlias = [];
        for (let j = 0; j < message.domainAlias.length; ++j)
          object.domainAlias[j] = $root.Enterprise.DomainAlias.toObject(
            message.domainAlias[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this DomainAliasRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainAliasRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainAliasRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainAliasRequest
     * @function getTypeUrl
     * @memberof Enterprise.DomainAliasRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainAliasRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainAliasRequest";
    };

    return DomainAliasRequest;
  })();

  Enterprise.DomainAliasResponse = (function () {
    /**
     * Properties of a DomainAliasResponse.
     * @memberof Enterprise
     * @interface IDomainAliasResponse
     * @property {Array.<Enterprise.IDomainAlias>|null} [domainAlias] DomainAliasResponse domainAlias
     */

    /**
     * Constructs a new DomainAliasResponse.
     * @memberof Enterprise
     * @classdesc Represents a DomainAliasResponse.
     * @implements IDomainAliasResponse
     * @constructor
     * @param {Enterprise.IDomainAliasResponse=} [properties] Properties to set
     */
    function DomainAliasResponse(properties) {
      this.domainAlias = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DomainAliasResponse domainAlias.
     * @member {Array.<Enterprise.IDomainAlias>} domainAlias
     * @memberof Enterprise.DomainAliasResponse
     * @instance
     */
    DomainAliasResponse.prototype.domainAlias = $util.emptyArray;

    /**
     * Creates a new DomainAliasResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Enterprise.IDomainAliasResponse=} [properties] Properties to set
     * @returns {Enterprise.DomainAliasResponse} DomainAliasResponse instance
     */
    DomainAliasResponse.create = function create(properties) {
      return new DomainAliasResponse(properties);
    };

    /**
     * Encodes the specified DomainAliasResponse message. Does not implicitly {@link Enterprise.DomainAliasResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Enterprise.IDomainAliasResponse} message DomainAliasResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAliasResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.domainAlias != null && message.domainAlias.length)
        for (let i = 0; i < message.domainAlias.length; ++i)
          $root.Enterprise.DomainAlias.encode(
            message.domainAlias[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified DomainAliasResponse message, length delimited. Does not implicitly {@link Enterprise.DomainAliasResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Enterprise.IDomainAliasResponse} message DomainAliasResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DomainAliasResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DomainAliasResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DomainAliasResponse} DomainAliasResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAliasResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DomainAliasResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.domainAlias && message.domainAlias.length)) message.domainAlias = [];
            message.domainAlias.push($root.Enterprise.DomainAlias.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DomainAliasResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DomainAliasResponse} DomainAliasResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DomainAliasResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DomainAliasResponse message.
     * @function verify
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DomainAliasResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.domainAlias != null && message.hasOwnProperty("domainAlias")) {
        if (!Array.isArray(message.domainAlias)) return "domainAlias: array expected";
        for (let i = 0; i < message.domainAlias.length; ++i) {
          let error = $root.Enterprise.DomainAlias.verify(message.domainAlias[i]);
          if (error) return "domainAlias." + error;
        }
      }
      return null;
    };

    /**
     * Creates a DomainAliasResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DomainAliasResponse} DomainAliasResponse
     */
    DomainAliasResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DomainAliasResponse) return object;
      let message = new $root.Enterprise.DomainAliasResponse();
      if (object.domainAlias) {
        if (!Array.isArray(object.domainAlias))
          throw TypeError(".Enterprise.DomainAliasResponse.domainAlias: array expected");
        message.domainAlias = [];
        for (let i = 0; i < object.domainAlias.length; ++i) {
          if (typeof object.domainAlias[i] !== "object")
            throw TypeError(".Enterprise.DomainAliasResponse.domainAlias: object expected");
          message.domainAlias[i] = $root.Enterprise.DomainAlias.fromObject(object.domainAlias[i]);
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a DomainAliasResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {Enterprise.DomainAliasResponse} message DomainAliasResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DomainAliasResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.domainAlias = [];
      if (message.domainAlias && message.domainAlias.length) {
        object.domainAlias = [];
        for (let j = 0; j < message.domainAlias.length; ++j)
          object.domainAlias[j] = $root.Enterprise.DomainAlias.toObject(
            message.domainAlias[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this DomainAliasResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.DomainAliasResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DomainAliasResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DomainAliasResponse
     * @function getTypeUrl
     * @memberof Enterprise.DomainAliasResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DomainAliasResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DomainAliasResponse";
    };

    return DomainAliasResponse;
  })();

  Enterprise.EnterpriseUsersProvisionRequest = (function () {
    /**
     * Properties of an EnterpriseUsersProvisionRequest.
     * @memberof Enterprise
     * @interface IEnterpriseUsersProvisionRequest
     * @property {Array.<Enterprise.IEnterpriseUsersProvision>|null} [users] EnterpriseUsersProvisionRequest users
     * @property {string|null} [clientVersion] EnterpriseUsersProvisionRequest clientVersion
     */

    /**
     * Constructs a new EnterpriseUsersProvisionRequest.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersProvisionRequest.
     * @implements IEnterpriseUsersProvisionRequest
     * @constructor
     * @param {Enterprise.IEnterpriseUsersProvisionRequest=} [properties] Properties to set
     */
    function EnterpriseUsersProvisionRequest(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersProvisionRequest users.
     * @member {Array.<Enterprise.IEnterpriseUsersProvision>} users
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @instance
     */
    EnterpriseUsersProvisionRequest.prototype.users = $util.emptyArray;

    /**
     * EnterpriseUsersProvisionRequest clientVersion.
     * @member {string} clientVersion
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @instance
     */
    EnterpriseUsersProvisionRequest.prototype.clientVersion = "";

    /**
     * Creates a new EnterpriseUsersProvisionRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionRequest=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersProvisionRequest} EnterpriseUsersProvisionRequest instance
     */
    EnterpriseUsersProvisionRequest.create = function create(properties) {
      return new EnterpriseUsersProvisionRequest(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionRequest message. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionRequest} message EnterpriseUsersProvisionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.EnterpriseUsersProvision.encode(
            message.users[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.clientVersion);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionRequest} message EnterpriseUsersProvisionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersProvisionRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersProvisionRequest} EnterpriseUsersProvisionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersProvisionRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push(
              $root.Enterprise.EnterpriseUsersProvision.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            message.clientVersion = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersProvisionRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersProvisionRequest} EnterpriseUsersProvisionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersProvisionRequest message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersProvisionRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.EnterpriseUsersProvision.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        if (!$util.isString(message.clientVersion)) return "clientVersion: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersProvisionRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersProvisionRequest} EnterpriseUsersProvisionRequest
     */
    EnterpriseUsersProvisionRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersProvisionRequest) return object;
      let message = new $root.Enterprise.EnterpriseUsersProvisionRequest();
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.EnterpriseUsersProvisionRequest.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseUsersProvisionRequest.users: object expected");
          message.users[i] = $root.Enterprise.EnterpriseUsersProvision.fromObject(object.users[i]);
        }
      }
      if (object.clientVersion != null) message.clientVersion = String(object.clientVersion);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersProvisionRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {Enterprise.EnterpriseUsersProvisionRequest} message EnterpriseUsersProvisionRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersProvisionRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (options.defaults) object.clientVersion = "";
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.EnterpriseUsersProvision.toObject(
            message.users[j],
            options,
          );
      }
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        object.clientVersion = message.clientVersion;
      return object;
    };

    /**
     * Converts this EnterpriseUsersProvisionRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersProvisionRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersProvisionRequest
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersProvisionRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersProvisionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersProvisionRequest";
    };

    return EnterpriseUsersProvisionRequest;
  })();

  Enterprise.EnterpriseUsersProvision = (function () {
    /**
     * Properties of an EnterpriseUsersProvision.
     * @memberof Enterprise
     * @interface IEnterpriseUsersProvision
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUsersProvision enterpriseUserId
     * @property {string|null} [username] EnterpriseUsersProvision username
     * @property {number|Long|null} [nodeId] EnterpriseUsersProvision nodeId
     * @property {string|null} [encryptedData] EnterpriseUsersProvision encryptedData
     * @property {Enterprise.EncryptedKeyType|null} [keyType] EnterpriseUsersProvision keyType
     * @property {string|null} [fullName] EnterpriseUsersProvision fullName
     * @property {string|null} [jobTitle] EnterpriseUsersProvision jobTitle
     * @property {Uint8Array|null} [enterpriseUsersDataKey] EnterpriseUsersProvision enterpriseUsersDataKey
     * @property {Uint8Array|null} [authVerifier] EnterpriseUsersProvision authVerifier
     * @property {Uint8Array|null} [encryptionParams] EnterpriseUsersProvision encryptionParams
     * @property {Uint8Array|null} [rsaPublicKey] EnterpriseUsersProvision rsaPublicKey
     * @property {Uint8Array|null} [rsaEncryptedPrivateKey] EnterpriseUsersProvision rsaEncryptedPrivateKey
     * @property {Uint8Array|null} [eccPublicKey] EnterpriseUsersProvision eccPublicKey
     * @property {Uint8Array|null} [eccEncryptedPrivateKey] EnterpriseUsersProvision eccEncryptedPrivateKey
     * @property {Uint8Array|null} [encryptedDeviceToken] EnterpriseUsersProvision encryptedDeviceToken
     * @property {Uint8Array|null} [encryptedClientKey] EnterpriseUsersProvision encryptedClientKey
     */

    /**
     * Constructs a new EnterpriseUsersProvision.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersProvision.
     * @implements IEnterpriseUsersProvision
     * @constructor
     * @param {Enterprise.IEnterpriseUsersProvision=} [properties] Properties to set
     */
    function EnterpriseUsersProvision(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersProvision enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUsersProvision username.
     * @member {string} username
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.username = "";

    /**
     * EnterpriseUsersProvision nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * EnterpriseUsersProvision encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.encryptedData = "";

    /**
     * EnterpriseUsersProvision keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.keyType = 0;

    /**
     * EnterpriseUsersProvision fullName.
     * @member {string} fullName
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.fullName = "";

    /**
     * EnterpriseUsersProvision jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.jobTitle = "";

    /**
     * EnterpriseUsersProvision enterpriseUsersDataKey.
     * @member {Uint8Array} enterpriseUsersDataKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.enterpriseUsersDataKey = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision authVerifier.
     * @member {Uint8Array} authVerifier
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.authVerifier = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision encryptionParams.
     * @member {Uint8Array} encryptionParams
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.encryptionParams = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision rsaPublicKey.
     * @member {Uint8Array} rsaPublicKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.rsaPublicKey = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision rsaEncryptedPrivateKey.
     * @member {Uint8Array} rsaEncryptedPrivateKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.rsaEncryptedPrivateKey = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision eccPublicKey.
     * @member {Uint8Array} eccPublicKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.eccPublicKey = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision eccEncryptedPrivateKey.
     * @member {Uint8Array} eccEncryptedPrivateKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.eccEncryptedPrivateKey = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision encryptedDeviceToken.
     * @member {Uint8Array} encryptedDeviceToken
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.encryptedDeviceToken = $util.newBuffer([]);

    /**
     * EnterpriseUsersProvision encryptedClientKey.
     * @member {Uint8Array} encryptedClientKey
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     */
    EnterpriseUsersProvision.prototype.encryptedClientKey = $util.newBuffer([]);

    /**
     * Creates a new EnterpriseUsersProvision instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Enterprise.IEnterpriseUsersProvision=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersProvision} EnterpriseUsersProvision instance
     */
    EnterpriseUsersProvision.create = function create(properties) {
      return new EnterpriseUsersProvision(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersProvision message. Does not implicitly {@link Enterprise.EnterpriseUsersProvision.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Enterprise.IEnterpriseUsersProvision} message EnterpriseUsersProvision message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvision.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.username);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.keyType);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.jobTitle);
      if (
        message.enterpriseUsersDataKey != null &&
        Object.hasOwnProperty.call(message, "enterpriseUsersDataKey")
      )
        writer.uint32(/* id 8, wireType 2 =*/ 66).bytes(message.enterpriseUsersDataKey);
      if (message.authVerifier != null && Object.hasOwnProperty.call(message, "authVerifier"))
        writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.authVerifier);
      if (
        message.encryptionParams != null &&
        Object.hasOwnProperty.call(message, "encryptionParams")
      )
        writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.encryptionParams);
      if (message.rsaPublicKey != null && Object.hasOwnProperty.call(message, "rsaPublicKey"))
        writer.uint32(/* id 11, wireType 2 =*/ 90).bytes(message.rsaPublicKey);
      if (
        message.rsaEncryptedPrivateKey != null &&
        Object.hasOwnProperty.call(message, "rsaEncryptedPrivateKey")
      )
        writer.uint32(/* id 12, wireType 2 =*/ 98).bytes(message.rsaEncryptedPrivateKey);
      if (message.eccPublicKey != null && Object.hasOwnProperty.call(message, "eccPublicKey"))
        writer.uint32(/* id 13, wireType 2 =*/ 106).bytes(message.eccPublicKey);
      if (
        message.eccEncryptedPrivateKey != null &&
        Object.hasOwnProperty.call(message, "eccEncryptedPrivateKey")
      )
        writer.uint32(/* id 14, wireType 2 =*/ 114).bytes(message.eccEncryptedPrivateKey);
      if (
        message.encryptedDeviceToken != null &&
        Object.hasOwnProperty.call(message, "encryptedDeviceToken")
      )
        writer.uint32(/* id 15, wireType 2 =*/ 122).bytes(message.encryptedDeviceToken);
      if (
        message.encryptedClientKey != null &&
        Object.hasOwnProperty.call(message, "encryptedClientKey")
      )
        writer.uint32(/* id 16, wireType 2 =*/ 130).bytes(message.encryptedClientKey);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersProvision message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersProvision.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Enterprise.IEnterpriseUsersProvision} message EnterpriseUsersProvision message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvision.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersProvision message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersProvision} EnterpriseUsersProvision
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvision.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersProvision();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.username = reader.string();
            break;
          }
          case 3: {
            message.nodeId = reader.int64();
            break;
          }
          case 4: {
            message.encryptedData = reader.string();
            break;
          }
          case 5: {
            message.keyType = reader.int32();
            break;
          }
          case 6: {
            message.fullName = reader.string();
            break;
          }
          case 7: {
            message.jobTitle = reader.string();
            break;
          }
          case 8: {
            message.enterpriseUsersDataKey = reader.bytes();
            break;
          }
          case 9: {
            message.authVerifier = reader.bytes();
            break;
          }
          case 10: {
            message.encryptionParams = reader.bytes();
            break;
          }
          case 11: {
            message.rsaPublicKey = reader.bytes();
            break;
          }
          case 12: {
            message.rsaEncryptedPrivateKey = reader.bytes();
            break;
          }
          case 13: {
            message.eccPublicKey = reader.bytes();
            break;
          }
          case 14: {
            message.eccEncryptedPrivateKey = reader.bytes();
            break;
          }
          case 15: {
            message.encryptedDeviceToken = reader.bytes();
            break;
          }
          case 16: {
            message.encryptedClientKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersProvision message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersProvision} EnterpriseUsersProvision
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvision.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersProvision message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersProvision.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (
        message.enterpriseUsersDataKey != null &&
        message.hasOwnProperty("enterpriseUsersDataKey")
      )
        if (
          !(
            (message.enterpriseUsersDataKey &&
              typeof message.enterpriseUsersDataKey.length === "number") ||
            $util.isString(message.enterpriseUsersDataKey)
          )
        )
          return "enterpriseUsersDataKey: buffer expected";
      if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
        if (
          !(
            (message.authVerifier && typeof message.authVerifier.length === "number") ||
            $util.isString(message.authVerifier)
          )
        )
          return "authVerifier: buffer expected";
      if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
        if (
          !(
            (message.encryptionParams && typeof message.encryptionParams.length === "number") ||
            $util.isString(message.encryptionParams)
          )
        )
          return "encryptionParams: buffer expected";
      if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
        if (
          !(
            (message.rsaPublicKey && typeof message.rsaPublicKey.length === "number") ||
            $util.isString(message.rsaPublicKey)
          )
        )
          return "rsaPublicKey: buffer expected";
      if (
        message.rsaEncryptedPrivateKey != null &&
        message.hasOwnProperty("rsaEncryptedPrivateKey")
      )
        if (
          !(
            (message.rsaEncryptedPrivateKey &&
              typeof message.rsaEncryptedPrivateKey.length === "number") ||
            $util.isString(message.rsaEncryptedPrivateKey)
          )
        )
          return "rsaEncryptedPrivateKey: buffer expected";
      if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
        if (
          !(
            (message.eccPublicKey && typeof message.eccPublicKey.length === "number") ||
            $util.isString(message.eccPublicKey)
          )
        )
          return "eccPublicKey: buffer expected";
      if (
        message.eccEncryptedPrivateKey != null &&
        message.hasOwnProperty("eccEncryptedPrivateKey")
      )
        if (
          !(
            (message.eccEncryptedPrivateKey &&
              typeof message.eccEncryptedPrivateKey.length === "number") ||
            $util.isString(message.eccEncryptedPrivateKey)
          )
        )
          return "eccEncryptedPrivateKey: buffer expected";
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        if (
          !(
            (message.encryptedDeviceToken &&
              typeof message.encryptedDeviceToken.length === "number") ||
            $util.isString(message.encryptedDeviceToken)
          )
        )
          return "encryptedDeviceToken: buffer expected";
      if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
        if (
          !(
            (message.encryptedClientKey && typeof message.encryptedClientKey.length === "number") ||
            $util.isString(message.encryptedClientKey)
          )
        )
          return "encryptedClientKey: buffer expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersProvision message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersProvision} EnterpriseUsersProvision
     */
    EnterpriseUsersProvision.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersProvision) return object;
      let message = new $root.Enterprise.EnterpriseUsersProvision();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.username != null) message.username = String(object.username);
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.enterpriseUsersDataKey != null)
        if (typeof object.enterpriseUsersDataKey === "string")
          $util.base64.decode(
            object.enterpriseUsersDataKey,
            (message.enterpriseUsersDataKey = $util.newBuffer(
              $util.base64.length(object.enterpriseUsersDataKey),
            )),
            0,
          );
        else if (object.enterpriseUsersDataKey.length >= 0)
          message.enterpriseUsersDataKey = object.enterpriseUsersDataKey;
      if (object.authVerifier != null)
        if (typeof object.authVerifier === "string")
          $util.base64.decode(
            object.authVerifier,
            (message.authVerifier = $util.newBuffer($util.base64.length(object.authVerifier))),
            0,
          );
        else if (object.authVerifier.length >= 0) message.authVerifier = object.authVerifier;
      if (object.encryptionParams != null)
        if (typeof object.encryptionParams === "string")
          $util.base64.decode(
            object.encryptionParams,
            (message.encryptionParams = $util.newBuffer(
              $util.base64.length(object.encryptionParams),
            )),
            0,
          );
        else if (object.encryptionParams.length >= 0)
          message.encryptionParams = object.encryptionParams;
      if (object.rsaPublicKey != null)
        if (typeof object.rsaPublicKey === "string")
          $util.base64.decode(
            object.rsaPublicKey,
            (message.rsaPublicKey = $util.newBuffer($util.base64.length(object.rsaPublicKey))),
            0,
          );
        else if (object.rsaPublicKey.length >= 0) message.rsaPublicKey = object.rsaPublicKey;
      if (object.rsaEncryptedPrivateKey != null)
        if (typeof object.rsaEncryptedPrivateKey === "string")
          $util.base64.decode(
            object.rsaEncryptedPrivateKey,
            (message.rsaEncryptedPrivateKey = $util.newBuffer(
              $util.base64.length(object.rsaEncryptedPrivateKey),
            )),
            0,
          );
        else if (object.rsaEncryptedPrivateKey.length >= 0)
          message.rsaEncryptedPrivateKey = object.rsaEncryptedPrivateKey;
      if (object.eccPublicKey != null)
        if (typeof object.eccPublicKey === "string")
          $util.base64.decode(
            object.eccPublicKey,
            (message.eccPublicKey = $util.newBuffer($util.base64.length(object.eccPublicKey))),
            0,
          );
        else if (object.eccPublicKey.length >= 0) message.eccPublicKey = object.eccPublicKey;
      if (object.eccEncryptedPrivateKey != null)
        if (typeof object.eccEncryptedPrivateKey === "string")
          $util.base64.decode(
            object.eccEncryptedPrivateKey,
            (message.eccEncryptedPrivateKey = $util.newBuffer(
              $util.base64.length(object.eccEncryptedPrivateKey),
            )),
            0,
          );
        else if (object.eccEncryptedPrivateKey.length >= 0)
          message.eccEncryptedPrivateKey = object.eccEncryptedPrivateKey;
      if (object.encryptedDeviceToken != null)
        if (typeof object.encryptedDeviceToken === "string")
          $util.base64.decode(
            object.encryptedDeviceToken,
            (message.encryptedDeviceToken = $util.newBuffer(
              $util.base64.length(object.encryptedDeviceToken),
            )),
            0,
          );
        else if (object.encryptedDeviceToken.length >= 0)
          message.encryptedDeviceToken = object.encryptedDeviceToken;
      if (object.encryptedClientKey != null)
        if (typeof object.encryptedClientKey === "string")
          $util.base64.decode(
            object.encryptedClientKey,
            (message.encryptedClientKey = $util.newBuffer(
              $util.base64.length(object.encryptedClientKey),
            )),
            0,
          );
        else if (object.encryptedClientKey.length >= 0)
          message.encryptedClientKey = object.encryptedClientKey;
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersProvision message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {Enterprise.EnterpriseUsersProvision} message EnterpriseUsersProvision
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersProvision.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.username = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
        object.fullName = "";
        object.jobTitle = "";
        if (options.bytes === String) object.enterpriseUsersDataKey = "";
        else {
          object.enterpriseUsersDataKey = [];
          if (options.bytes !== Array)
            object.enterpriseUsersDataKey = $util.newBuffer(object.enterpriseUsersDataKey);
        }
        if (options.bytes === String) object.authVerifier = "";
        else {
          object.authVerifier = [];
          if (options.bytes !== Array) object.authVerifier = $util.newBuffer(object.authVerifier);
        }
        if (options.bytes === String) object.encryptionParams = "";
        else {
          object.encryptionParams = [];
          if (options.bytes !== Array)
            object.encryptionParams = $util.newBuffer(object.encryptionParams);
        }
        if (options.bytes === String) object.rsaPublicKey = "";
        else {
          object.rsaPublicKey = [];
          if (options.bytes !== Array) object.rsaPublicKey = $util.newBuffer(object.rsaPublicKey);
        }
        if (options.bytes === String) object.rsaEncryptedPrivateKey = "";
        else {
          object.rsaEncryptedPrivateKey = [];
          if (options.bytes !== Array)
            object.rsaEncryptedPrivateKey = $util.newBuffer(object.rsaEncryptedPrivateKey);
        }
        if (options.bytes === String) object.eccPublicKey = "";
        else {
          object.eccPublicKey = [];
          if (options.bytes !== Array) object.eccPublicKey = $util.newBuffer(object.eccPublicKey);
        }
        if (options.bytes === String) object.eccEncryptedPrivateKey = "";
        else {
          object.eccEncryptedPrivateKey = [];
          if (options.bytes !== Array)
            object.eccEncryptedPrivateKey = $util.newBuffer(object.eccEncryptedPrivateKey);
        }
        if (options.bytes === String) object.encryptedDeviceToken = "";
        else {
          object.encryptedDeviceToken = [];
          if (options.bytes !== Array)
            object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
        }
        if (options.bytes === String) object.encryptedClientKey = "";
        else {
          object.encryptedClientKey = [];
          if (options.bytes !== Array)
            object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
        }
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (
        message.enterpriseUsersDataKey != null &&
        message.hasOwnProperty("enterpriseUsersDataKey")
      )
        object.enterpriseUsersDataKey =
          options.bytes === String
            ? $util.base64.encode(
                message.enterpriseUsersDataKey,
                0,
                message.enterpriseUsersDataKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.enterpriseUsersDataKey)
              : message.enterpriseUsersDataKey;
      if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
        object.authVerifier =
          options.bytes === String
            ? $util.base64.encode(message.authVerifier, 0, message.authVerifier.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.authVerifier)
              : message.authVerifier;
      if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
        object.encryptionParams =
          options.bytes === String
            ? $util.base64.encode(message.encryptionParams, 0, message.encryptionParams.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptionParams)
              : message.encryptionParams;
      if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
        object.rsaPublicKey =
          options.bytes === String
            ? $util.base64.encode(message.rsaPublicKey, 0, message.rsaPublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rsaPublicKey)
              : message.rsaPublicKey;
      if (
        message.rsaEncryptedPrivateKey != null &&
        message.hasOwnProperty("rsaEncryptedPrivateKey")
      )
        object.rsaEncryptedPrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.rsaEncryptedPrivateKey,
                0,
                message.rsaEncryptedPrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.rsaEncryptedPrivateKey)
              : message.rsaEncryptedPrivateKey;
      if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
        object.eccPublicKey =
          options.bytes === String
            ? $util.base64.encode(message.eccPublicKey, 0, message.eccPublicKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.eccPublicKey)
              : message.eccPublicKey;
      if (
        message.eccEncryptedPrivateKey != null &&
        message.hasOwnProperty("eccEncryptedPrivateKey")
      )
        object.eccEncryptedPrivateKey =
          options.bytes === String
            ? $util.base64.encode(
                message.eccEncryptedPrivateKey,
                0,
                message.eccEncryptedPrivateKey.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.eccEncryptedPrivateKey)
              : message.eccEncryptedPrivateKey;
      if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
        object.encryptedDeviceToken =
          options.bytes === String
            ? $util.base64.encode(
                message.encryptedDeviceToken,
                0,
                message.encryptedDeviceToken.length,
              )
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedDeviceToken)
              : message.encryptedDeviceToken;
      if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
        object.encryptedClientKey =
          options.bytes === String
            ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length)
            : options.bytes === Array
              ? Array.prototype.slice.call(message.encryptedClientKey)
              : message.encryptedClientKey;
      return object;
    };

    /**
     * Converts this EnterpriseUsersProvision to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersProvision
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersProvision.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersProvision
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersProvision
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersProvision.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersProvision";
    };

    return EnterpriseUsersProvision;
  })();

  Enterprise.EnterpriseUsersProvisionResponse = (function () {
    /**
     * Properties of an EnterpriseUsersProvisionResponse.
     * @memberof Enterprise
     * @interface IEnterpriseUsersProvisionResponse
     * @property {Array.<Enterprise.IEnterpriseUsersProvisionResult>|null} [results] EnterpriseUsersProvisionResponse results
     */

    /**
     * Constructs a new EnterpriseUsersProvisionResponse.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersProvisionResponse.
     * @implements IEnterpriseUsersProvisionResponse
     * @constructor
     * @param {Enterprise.IEnterpriseUsersProvisionResponse=} [properties] Properties to set
     */
    function EnterpriseUsersProvisionResponse(properties) {
      this.results = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersProvisionResponse results.
     * @member {Array.<Enterprise.IEnterpriseUsersProvisionResult>} results
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @instance
     */
    EnterpriseUsersProvisionResponse.prototype.results = $util.emptyArray;

    /**
     * Creates a new EnterpriseUsersProvisionResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResponse=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersProvisionResponse} EnterpriseUsersProvisionResponse instance
     */
    EnterpriseUsersProvisionResponse.create = function create(properties) {
      return new EnterpriseUsersProvisionResponse(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionResponse message. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResponse} message EnterpriseUsersProvisionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.results != null && message.results.length)
        for (let i = 0; i < message.results.length; ++i)
          $root.Enterprise.EnterpriseUsersProvisionResult.encode(
            message.results[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionResponse message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResponse} message EnterpriseUsersProvisionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersProvisionResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersProvisionResponse} EnterpriseUsersProvisionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersProvisionResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.results && message.results.length)) message.results = [];
            message.results.push(
              $root.Enterprise.EnterpriseUsersProvisionResult.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersProvisionResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersProvisionResponse} EnterpriseUsersProvisionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersProvisionResponse message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersProvisionResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.results != null && message.hasOwnProperty("results")) {
        if (!Array.isArray(message.results)) return "results: array expected";
        for (let i = 0; i < message.results.length; ++i) {
          let error = $root.Enterprise.EnterpriseUsersProvisionResult.verify(message.results[i]);
          if (error) return "results." + error;
        }
      }
      return null;
    };

    /**
     * Creates an EnterpriseUsersProvisionResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersProvisionResponse} EnterpriseUsersProvisionResponse
     */
    EnterpriseUsersProvisionResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersProvisionResponse) return object;
      let message = new $root.Enterprise.EnterpriseUsersProvisionResponse();
      if (object.results) {
        if (!Array.isArray(object.results))
          throw TypeError(".Enterprise.EnterpriseUsersProvisionResponse.results: array expected");
        message.results = [];
        for (let i = 0; i < object.results.length; ++i) {
          if (typeof object.results[i] !== "object")
            throw TypeError(
              ".Enterprise.EnterpriseUsersProvisionResponse.results: object expected",
            );
          message.results[i] = $root.Enterprise.EnterpriseUsersProvisionResult.fromObject(
            object.results[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersProvisionResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {Enterprise.EnterpriseUsersProvisionResponse} message EnterpriseUsersProvisionResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersProvisionResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.results = [];
      if (message.results && message.results.length) {
        object.results = [];
        for (let j = 0; j < message.results.length; ++j)
          object.results[j] = $root.Enterprise.EnterpriseUsersProvisionResult.toObject(
            message.results[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this EnterpriseUsersProvisionResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersProvisionResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersProvisionResponse
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersProvisionResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersProvisionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersProvisionResponse";
    };

    return EnterpriseUsersProvisionResponse;
  })();

  Enterprise.EnterpriseUsersProvisionResult = (function () {
    /**
     * Properties of an EnterpriseUsersProvisionResult.
     * @memberof Enterprise
     * @interface IEnterpriseUsersProvisionResult
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUsersProvisionResult enterpriseUserId
     * @property {string|null} [code] EnterpriseUsersProvisionResult code
     * @property {string|null} [message] EnterpriseUsersProvisionResult message
     * @property {string|null} [additionalInfo] EnterpriseUsersProvisionResult additionalInfo
     */

    /**
     * Constructs a new EnterpriseUsersProvisionResult.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersProvisionResult.
     * @implements IEnterpriseUsersProvisionResult
     * @constructor
     * @param {Enterprise.IEnterpriseUsersProvisionResult=} [properties] Properties to set
     */
    function EnterpriseUsersProvisionResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersProvisionResult enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @instance
     */
    EnterpriseUsersProvisionResult.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUsersProvisionResult code.
     * @member {string} code
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @instance
     */
    EnterpriseUsersProvisionResult.prototype.code = "";

    /**
     * EnterpriseUsersProvisionResult message.
     * @member {string} message
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @instance
     */
    EnterpriseUsersProvisionResult.prototype.message = "";

    /**
     * EnterpriseUsersProvisionResult additionalInfo.
     * @member {string} additionalInfo
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @instance
     */
    EnterpriseUsersProvisionResult.prototype.additionalInfo = "";

    /**
     * Creates a new EnterpriseUsersProvisionResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResult=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersProvisionResult} EnterpriseUsersProvisionResult instance
     */
    EnterpriseUsersProvisionResult.create = function create(properties) {
      return new EnterpriseUsersProvisionResult(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionResult message. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResult} message EnterpriseUsersProvisionResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.code != null && Object.hasOwnProperty.call(message, "code"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.code);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message);
      if (message.additionalInfo != null && Object.hasOwnProperty.call(message, "additionalInfo"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.additionalInfo);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersProvisionResult message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersProvisionResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Enterprise.IEnterpriseUsersProvisionResult} message EnterpriseUsersProvisionResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersProvisionResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersProvisionResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersProvisionResult} EnterpriseUsersProvisionResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersProvisionResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.code = reader.string();
            break;
          }
          case 3: {
            message.message = reader.string();
            break;
          }
          case 4: {
            message.additionalInfo = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersProvisionResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersProvisionResult} EnterpriseUsersProvisionResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersProvisionResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersProvisionResult message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersProvisionResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.code != null && message.hasOwnProperty("code"))
        if (!$util.isString(message.code)) return "code: string expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        if (!$util.isString(message.additionalInfo)) return "additionalInfo: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersProvisionResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersProvisionResult} EnterpriseUsersProvisionResult
     */
    EnterpriseUsersProvisionResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersProvisionResult) return object;
      let message = new $root.Enterprise.EnterpriseUsersProvisionResult();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.code != null) message.code = String(object.code);
      if (object.message != null) message.message = String(object.message);
      if (object.additionalInfo != null) message.additionalInfo = String(object.additionalInfo);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersProvisionResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {Enterprise.EnterpriseUsersProvisionResult} message EnterpriseUsersProvisionResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersProvisionResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.code = "";
        object.message = "";
        object.additionalInfo = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        object.additionalInfo = message.additionalInfo;
      return object;
    };

    /**
     * Converts this EnterpriseUsersProvisionResult to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersProvisionResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersProvisionResult
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersProvisionResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersProvisionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersProvisionResult";
    };

    return EnterpriseUsersProvisionResult;
  })();

  Enterprise.EnterpriseUsersAddRequest = (function () {
    /**
     * Properties of an EnterpriseUsersAddRequest.
     * @memberof Enterprise
     * @interface IEnterpriseUsersAddRequest
     * @property {Array.<Enterprise.IEnterpriseUsersAdd>|null} [users] EnterpriseUsersAddRequest users
     * @property {string|null} [clientVersion] EnterpriseUsersAddRequest clientVersion
     */

    /**
     * Constructs a new EnterpriseUsersAddRequest.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersAddRequest.
     * @implements IEnterpriseUsersAddRequest
     * @constructor
     * @param {Enterprise.IEnterpriseUsersAddRequest=} [properties] Properties to set
     */
    function EnterpriseUsersAddRequest(properties) {
      this.users = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersAddRequest users.
     * @member {Array.<Enterprise.IEnterpriseUsersAdd>} users
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @instance
     */
    EnterpriseUsersAddRequest.prototype.users = $util.emptyArray;

    /**
     * EnterpriseUsersAddRequest clientVersion.
     * @member {string} clientVersion
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @instance
     */
    EnterpriseUsersAddRequest.prototype.clientVersion = "";

    /**
     * Creates a new EnterpriseUsersAddRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersAddRequest=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersAddRequest} EnterpriseUsersAddRequest instance
     */
    EnterpriseUsersAddRequest.create = function create(properties) {
      return new EnterpriseUsersAddRequest(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersAddRequest message. Does not implicitly {@link Enterprise.EnterpriseUsersAddRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersAddRequest} message EnterpriseUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.users != null && message.users.length)
        for (let i = 0; i < message.users.length; ++i)
          $root.Enterprise.EnterpriseUsersAdd.encode(
            message.users[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.clientVersion);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersAddRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersAddRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.IEnterpriseUsersAddRequest} message EnterpriseUsersAddRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersAddRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersAddRequest} EnterpriseUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersAddRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.users && message.users.length)) message.users = [];
            message.users.push($root.Enterprise.EnterpriseUsersAdd.decode(reader, reader.uint32()));
            break;
          }
          case 2: {
            message.clientVersion = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersAddRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersAddRequest} EnterpriseUsersAddRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersAddRequest message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersAddRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.users != null && message.hasOwnProperty("users")) {
        if (!Array.isArray(message.users)) return "users: array expected";
        for (let i = 0; i < message.users.length; ++i) {
          let error = $root.Enterprise.EnterpriseUsersAdd.verify(message.users[i]);
          if (error) return "users." + error;
        }
      }
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        if (!$util.isString(message.clientVersion)) return "clientVersion: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersAddRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersAddRequest} EnterpriseUsersAddRequest
     */
    EnterpriseUsersAddRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersAddRequest) return object;
      let message = new $root.Enterprise.EnterpriseUsersAddRequest();
      if (object.users) {
        if (!Array.isArray(object.users))
          throw TypeError(".Enterprise.EnterpriseUsersAddRequest.users: array expected");
        message.users = [];
        for (let i = 0; i < object.users.length; ++i) {
          if (typeof object.users[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseUsersAddRequest.users: object expected");
          message.users[i] = $root.Enterprise.EnterpriseUsersAdd.fromObject(object.users[i]);
        }
      }
      if (object.clientVersion != null) message.clientVersion = String(object.clientVersion);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersAddRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {Enterprise.EnterpriseUsersAddRequest} message EnterpriseUsersAddRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersAddRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.users = [];
      if (options.defaults) object.clientVersion = "";
      if (message.users && message.users.length) {
        object.users = [];
        for (let j = 0; j < message.users.length; ++j)
          object.users[j] = $root.Enterprise.EnterpriseUsersAdd.toObject(message.users[j], options);
      }
      if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
        object.clientVersion = message.clientVersion;
      return object;
    };

    /**
     * Converts this EnterpriseUsersAddRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersAddRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersAddRequest
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersAddRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersAddRequest";
    };

    return EnterpriseUsersAddRequest;
  })();

  Enterprise.EnterpriseUsersAdd = (function () {
    /**
     * Properties of an EnterpriseUsersAdd.
     * @memberof Enterprise
     * @interface IEnterpriseUsersAdd
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUsersAdd enterpriseUserId
     * @property {string|null} [username] EnterpriseUsersAdd username
     * @property {number|Long|null} [nodeId] EnterpriseUsersAdd nodeId
     * @property {string|null} [encryptedData] EnterpriseUsersAdd encryptedData
     * @property {Enterprise.EncryptedKeyType|null} [keyType] EnterpriseUsersAdd keyType
     * @property {string|null} [fullName] EnterpriseUsersAdd fullName
     * @property {string|null} [jobTitle] EnterpriseUsersAdd jobTitle
     * @property {boolean|null} [suppressEmailInvite] EnterpriseUsersAdd suppressEmailInvite
     * @property {string|null} [inviteeLocale] EnterpriseUsersAdd inviteeLocale
     * @property {boolean|null} [move] EnterpriseUsersAdd move
     * @property {number|Long|null} [roleId] EnterpriseUsersAdd roleId
     */

    /**
     * Constructs a new EnterpriseUsersAdd.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersAdd.
     * @implements IEnterpriseUsersAdd
     * @constructor
     * @param {Enterprise.IEnterpriseUsersAdd=} [properties] Properties to set
     */
    function EnterpriseUsersAdd(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersAdd enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUsersAdd username.
     * @member {string} username
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.username = "";

    /**
     * EnterpriseUsersAdd nodeId.
     * @member {number|Long} nodeId
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * EnterpriseUsersAdd encryptedData.
     * @member {string} encryptedData
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.encryptedData = "";

    /**
     * EnterpriseUsersAdd keyType.
     * @member {Enterprise.EncryptedKeyType} keyType
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.keyType = 0;

    /**
     * EnterpriseUsersAdd fullName.
     * @member {string} fullName
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.fullName = "";

    /**
     * EnterpriseUsersAdd jobTitle.
     * @member {string} jobTitle
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.jobTitle = "";

    /**
     * EnterpriseUsersAdd suppressEmailInvite.
     * @member {boolean} suppressEmailInvite
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.suppressEmailInvite = false;

    /**
     * EnterpriseUsersAdd inviteeLocale.
     * @member {string} inviteeLocale
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.inviteeLocale = "";

    /**
     * EnterpriseUsersAdd move.
     * @member {boolean} move
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.move = false;

    /**
     * EnterpriseUsersAdd roleId.
     * @member {number|Long} roleId
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     */
    EnterpriseUsersAdd.prototype.roleId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

    /**
     * Creates a new EnterpriseUsersAdd instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Enterprise.IEnterpriseUsersAdd=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersAdd} EnterpriseUsersAdd instance
     */
    EnterpriseUsersAdd.create = function create(properties) {
      return new EnterpriseUsersAdd(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersAdd message. Does not implicitly {@link Enterprise.EnterpriseUsersAdd.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Enterprise.IEnterpriseUsersAdd} message EnterpriseUsersAdd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAdd.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.username != null && Object.hasOwnProperty.call(message, "username"))
        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.username);
      if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.nodeId);
      if (message.encryptedData != null && Object.hasOwnProperty.call(message, "encryptedData"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.encryptedData);
      if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.keyType);
      if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.fullName);
      if (message.jobTitle != null && Object.hasOwnProperty.call(message, "jobTitle"))
        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.jobTitle);
      if (
        message.suppressEmailInvite != null &&
        Object.hasOwnProperty.call(message, "suppressEmailInvite")
      )
        writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.suppressEmailInvite);
      if (message.inviteeLocale != null && Object.hasOwnProperty.call(message, "inviteeLocale"))
        writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.inviteeLocale);
      if (message.move != null && Object.hasOwnProperty.call(message, "move"))
        writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.move);
      if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
        writer.uint32(/* id 11, wireType 0 =*/ 88).int64(message.roleId);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersAdd message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersAdd.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Enterprise.IEnterpriseUsersAdd} message EnterpriseUsersAdd message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAdd.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersAdd message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersAdd} EnterpriseUsersAdd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAdd.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersAdd();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.username = reader.string();
            break;
          }
          case 3: {
            message.nodeId = reader.int64();
            break;
          }
          case 4: {
            message.encryptedData = reader.string();
            break;
          }
          case 5: {
            message.keyType = reader.int32();
            break;
          }
          case 6: {
            message.fullName = reader.string();
            break;
          }
          case 7: {
            message.jobTitle = reader.string();
            break;
          }
          case 8: {
            message.suppressEmailInvite = reader.bool();
            break;
          }
          case 9: {
            message.inviteeLocale = reader.string();
            break;
          }
          case 10: {
            message.move = reader.bool();
            break;
          }
          case 11: {
            message.roleId = reader.int64();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersAdd message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersAdd} EnterpriseUsersAdd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAdd.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersAdd message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersAdd.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.username != null && message.hasOwnProperty("username"))
        if (!$util.isString(message.username)) return "username: string expected";
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (
          !$util.isInteger(message.nodeId) &&
          !(
            message.nodeId &&
            $util.isInteger(message.nodeId.low) &&
            $util.isInteger(message.nodeId.high)
          )
        )
          return "nodeId: integer|Long expected";
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        if (!$util.isString(message.encryptedData)) return "encryptedData: string expected";
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        switch (message.keyType) {
          default:
            return "keyType: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        if (!$util.isString(message.fullName)) return "fullName: string expected";
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        if (!$util.isString(message.jobTitle)) return "jobTitle: string expected";
      if (message.suppressEmailInvite != null && message.hasOwnProperty("suppressEmailInvite"))
        if (typeof message.suppressEmailInvite !== "boolean")
          return "suppressEmailInvite: boolean expected";
      if (message.inviteeLocale != null && message.hasOwnProperty("inviteeLocale"))
        if (!$util.isString(message.inviteeLocale)) return "inviteeLocale: string expected";
      if (message.move != null && message.hasOwnProperty("move"))
        if (typeof message.move !== "boolean") return "move: boolean expected";
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (
          !$util.isInteger(message.roleId) &&
          !(
            message.roleId &&
            $util.isInteger(message.roleId.low) &&
            $util.isInteger(message.roleId.high)
          )
        )
          return "roleId: integer|Long expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersAdd message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersAdd} EnterpriseUsersAdd
     */
    EnterpriseUsersAdd.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersAdd) return object;
      let message = new $root.Enterprise.EnterpriseUsersAdd();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.username != null) message.username = String(object.username);
      if (object.nodeId != null)
        if ($util.Long) (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
        else if (typeof object.nodeId === "string") message.nodeId = parseInt(object.nodeId, 10);
        else if (typeof object.nodeId === "number") message.nodeId = object.nodeId;
        else if (typeof object.nodeId === "object")
          message.nodeId = new $util.LongBits(
            object.nodeId.low >>> 0,
            object.nodeId.high >>> 0,
          ).toNumber();
      if (object.encryptedData != null) message.encryptedData = String(object.encryptedData);
      switch (object.keyType) {
        default:
          if (typeof object.keyType === "number") {
            message.keyType = object.keyType;
            break;
          }
          break;
        case "KT_NO_KEY":
        case 0:
          message.keyType = 0;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY":
        case 1:
          message.keyType = 1;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY":
        case 2:
          message.keyType = 2;
          break;
        case "KT_ENCRYPTED_BY_DATA_KEY_GCM":
        case 3:
          message.keyType = 3;
          break;
        case "KT_ENCRYPTED_BY_PUBLIC_KEY_ECC":
        case 4:
          message.keyType = 4;
          break;
      }
      if (object.fullName != null) message.fullName = String(object.fullName);
      if (object.jobTitle != null) message.jobTitle = String(object.jobTitle);
      if (object.suppressEmailInvite != null)
        message.suppressEmailInvite = Boolean(object.suppressEmailInvite);
      if (object.inviteeLocale != null) message.inviteeLocale = String(object.inviteeLocale);
      if (object.move != null) message.move = Boolean(object.move);
      if (object.roleId != null)
        if ($util.Long) (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
        else if (typeof object.roleId === "string") message.roleId = parseInt(object.roleId, 10);
        else if (typeof object.roleId === "number") message.roleId = object.roleId;
        else if (typeof object.roleId === "object")
          message.roleId = new $util.LongBits(
            object.roleId.low >>> 0,
            object.roleId.high >>> 0,
          ).toNumber();
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersAdd message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {Enterprise.EnterpriseUsersAdd} message EnterpriseUsersAdd
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersAdd.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.username = "";
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.nodeId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.nodeId = options.longs === String ? "0" : 0;
        object.encryptedData = "";
        object.keyType = options.enums === String ? "KT_NO_KEY" : 0;
        object.fullName = "";
        object.jobTitle = "";
        object.suppressEmailInvite = false;
        object.inviteeLocale = "";
        object.move = false;
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.roleId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.roleId = options.longs === String ? "0" : 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.username != null && message.hasOwnProperty("username"))
        object.username = message.username;
      if (message.nodeId != null && message.hasOwnProperty("nodeId"))
        if (typeof message.nodeId === "number")
          object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
        else
          object.nodeId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.nodeId)
              : options.longs === Number
                ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber()
                : message.nodeId;
      if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
        object.encryptedData = message.encryptedData;
      if (message.keyType != null && message.hasOwnProperty("keyType"))
        object.keyType =
          options.enums === String
            ? $root.Enterprise.EncryptedKeyType[message.keyType] === undefined
              ? message.keyType
              : $root.Enterprise.EncryptedKeyType[message.keyType]
            : message.keyType;
      if (message.fullName != null && message.hasOwnProperty("fullName"))
        object.fullName = message.fullName;
      if (message.jobTitle != null && message.hasOwnProperty("jobTitle"))
        object.jobTitle = message.jobTitle;
      if (message.suppressEmailInvite != null && message.hasOwnProperty("suppressEmailInvite"))
        object.suppressEmailInvite = message.suppressEmailInvite;
      if (message.inviteeLocale != null && message.hasOwnProperty("inviteeLocale"))
        object.inviteeLocale = message.inviteeLocale;
      if (message.move != null && message.hasOwnProperty("move")) object.move = message.move;
      if (message.roleId != null && message.hasOwnProperty("roleId"))
        if (typeof message.roleId === "number")
          object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
        else
          object.roleId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.roleId)
              : options.longs === Number
                ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber()
                : message.roleId;
      return object;
    };

    /**
     * Converts this EnterpriseUsersAdd to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersAdd
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersAdd.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersAdd
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersAdd
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersAdd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersAdd";
    };

    return EnterpriseUsersAdd;
  })();

  Enterprise.EnterpriseUsersAddResponse = (function () {
    /**
     * Properties of an EnterpriseUsersAddResponse.
     * @memberof Enterprise
     * @interface IEnterpriseUsersAddResponse
     * @property {Array.<Enterprise.IEnterpriseUsersAddResult>|null} [results] EnterpriseUsersAddResponse results
     * @property {boolean|null} [success] EnterpriseUsersAddResponse success
     * @property {string|null} [code] EnterpriseUsersAddResponse code
     * @property {string|null} [message] EnterpriseUsersAddResponse message
     * @property {string|null} [additionalInfo] EnterpriseUsersAddResponse additionalInfo
     */

    /**
     * Constructs a new EnterpriseUsersAddResponse.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersAddResponse.
     * @implements IEnterpriseUsersAddResponse
     * @constructor
     * @param {Enterprise.IEnterpriseUsersAddResponse=} [properties] Properties to set
     */
    function EnterpriseUsersAddResponse(properties) {
      this.results = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersAddResponse results.
     * @member {Array.<Enterprise.IEnterpriseUsersAddResult>} results
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     */
    EnterpriseUsersAddResponse.prototype.results = $util.emptyArray;

    /**
     * EnterpriseUsersAddResponse success.
     * @member {boolean} success
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     */
    EnterpriseUsersAddResponse.prototype.success = false;

    /**
     * EnterpriseUsersAddResponse code.
     * @member {string} code
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     */
    EnterpriseUsersAddResponse.prototype.code = "";

    /**
     * EnterpriseUsersAddResponse message.
     * @member {string} message
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     */
    EnterpriseUsersAddResponse.prototype.message = "";

    /**
     * EnterpriseUsersAddResponse additionalInfo.
     * @member {string} additionalInfo
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     */
    EnterpriseUsersAddResponse.prototype.additionalInfo = "";

    /**
     * Creates a new EnterpriseUsersAddResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResponse=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersAddResponse} EnterpriseUsersAddResponse instance
     */
    EnterpriseUsersAddResponse.create = function create(properties) {
      return new EnterpriseUsersAddResponse(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersAddResponse message. Does not implicitly {@link Enterprise.EnterpriseUsersAddResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResponse} message EnterpriseUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.results != null && message.results.length)
        for (let i = 0; i < message.results.length; ++i)
          $root.Enterprise.EnterpriseUsersAddResult.encode(
            message.results[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      if (message.success != null && Object.hasOwnProperty.call(message, "success"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.success);
      if (message.code != null && Object.hasOwnProperty.call(message, "code"))
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.code);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.message);
      if (message.additionalInfo != null && Object.hasOwnProperty.call(message, "additionalInfo"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.additionalInfo);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersAddResponse message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersAddResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResponse} message EnterpriseUsersAddResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersAddResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersAddResponse} EnterpriseUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersAddResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.results && message.results.length)) message.results = [];
            message.results.push(
              $root.Enterprise.EnterpriseUsersAddResult.decode(reader, reader.uint32()),
            );
            break;
          }
          case 2: {
            message.success = reader.bool();
            break;
          }
          case 3: {
            message.code = reader.string();
            break;
          }
          case 4: {
            message.message = reader.string();
            break;
          }
          case 5: {
            message.additionalInfo = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersAddResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersAddResponse} EnterpriseUsersAddResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersAddResponse message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersAddResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.results != null && message.hasOwnProperty("results")) {
        if (!Array.isArray(message.results)) return "results: array expected";
        for (let i = 0; i < message.results.length; ++i) {
          let error = $root.Enterprise.EnterpriseUsersAddResult.verify(message.results[i]);
          if (error) return "results." + error;
        }
      }
      if (message.success != null && message.hasOwnProperty("success"))
        if (typeof message.success !== "boolean") return "success: boolean expected";
      if (message.code != null && message.hasOwnProperty("code"))
        if (!$util.isString(message.code)) return "code: string expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        if (!$util.isString(message.additionalInfo)) return "additionalInfo: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersAddResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersAddResponse} EnterpriseUsersAddResponse
     */
    EnterpriseUsersAddResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersAddResponse) return object;
      let message = new $root.Enterprise.EnterpriseUsersAddResponse();
      if (object.results) {
        if (!Array.isArray(object.results))
          throw TypeError(".Enterprise.EnterpriseUsersAddResponse.results: array expected");
        message.results = [];
        for (let i = 0; i < object.results.length; ++i) {
          if (typeof object.results[i] !== "object")
            throw TypeError(".Enterprise.EnterpriseUsersAddResponse.results: object expected");
          message.results[i] = $root.Enterprise.EnterpriseUsersAddResult.fromObject(
            object.results[i],
          );
        }
      }
      if (object.success != null) message.success = Boolean(object.success);
      if (object.code != null) message.code = String(object.code);
      if (object.message != null) message.message = String(object.message);
      if (object.additionalInfo != null) message.additionalInfo = String(object.additionalInfo);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersAddResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {Enterprise.EnterpriseUsersAddResponse} message EnterpriseUsersAddResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersAddResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.results = [];
      if (options.defaults) {
        object.success = false;
        object.code = "";
        object.message = "";
        object.additionalInfo = "";
      }
      if (message.results && message.results.length) {
        object.results = [];
        for (let j = 0; j < message.results.length; ++j)
          object.results[j] = $root.Enterprise.EnterpriseUsersAddResult.toObject(
            message.results[j],
            options,
          );
      }
      if (message.success != null && message.hasOwnProperty("success"))
        object.success = message.success;
      if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        object.additionalInfo = message.additionalInfo;
      return object;
    };

    /**
     * Converts this EnterpriseUsersAddResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersAddResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersAddResponse
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersAddResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersAddResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersAddResponse";
    };

    return EnterpriseUsersAddResponse;
  })();

  Enterprise.EnterpriseUsersAddResult = (function () {
    /**
     * Properties of an EnterpriseUsersAddResult.
     * @memberof Enterprise
     * @interface IEnterpriseUsersAddResult
     * @property {number|Long|null} [enterpriseUserId] EnterpriseUsersAddResult enterpriseUserId
     * @property {boolean|null} [success] EnterpriseUsersAddResult success
     * @property {string|null} [verificationCode] EnterpriseUsersAddResult verificationCode
     * @property {string|null} [code] EnterpriseUsersAddResult code
     * @property {string|null} [message] EnterpriseUsersAddResult message
     * @property {string|null} [additionalInfo] EnterpriseUsersAddResult additionalInfo
     */

    /**
     * Constructs a new EnterpriseUsersAddResult.
     * @memberof Enterprise
     * @classdesc Represents an EnterpriseUsersAddResult.
     * @implements IEnterpriseUsersAddResult
     * @constructor
     * @param {Enterprise.IEnterpriseUsersAddResult=} [properties] Properties to set
     */
    function EnterpriseUsersAddResult(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * EnterpriseUsersAddResult enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * EnterpriseUsersAddResult success.
     * @member {boolean} success
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.success = false;

    /**
     * EnterpriseUsersAddResult verificationCode.
     * @member {string} verificationCode
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.verificationCode = "";

    /**
     * EnterpriseUsersAddResult code.
     * @member {string} code
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.code = "";

    /**
     * EnterpriseUsersAddResult message.
     * @member {string} message
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.message = "";

    /**
     * EnterpriseUsersAddResult additionalInfo.
     * @member {string} additionalInfo
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     */
    EnterpriseUsersAddResult.prototype.additionalInfo = "";

    /**
     * Creates a new EnterpriseUsersAddResult instance using the specified properties.
     * @function create
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResult=} [properties] Properties to set
     * @returns {Enterprise.EnterpriseUsersAddResult} EnterpriseUsersAddResult instance
     */
    EnterpriseUsersAddResult.create = function create(properties) {
      return new EnterpriseUsersAddResult(properties);
    };

    /**
     * Encodes the specified EnterpriseUsersAddResult message. Does not implicitly {@link Enterprise.EnterpriseUsersAddResult.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResult} message EnterpriseUsersAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddResult.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.success != null && Object.hasOwnProperty.call(message, "success"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.success);
      if (
        message.verificationCode != null &&
        Object.hasOwnProperty.call(message, "verificationCode")
      )
        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.verificationCode);
      if (message.code != null && Object.hasOwnProperty.call(message, "code"))
        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.code);
      if (message.message != null && Object.hasOwnProperty.call(message, "message"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.message);
      if (message.additionalInfo != null && Object.hasOwnProperty.call(message, "additionalInfo"))
        writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.additionalInfo);
      return writer;
    };

    /**
     * Encodes the specified EnterpriseUsersAddResult message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUsersAddResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Enterprise.IEnterpriseUsersAddResult} message EnterpriseUsersAddResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EnterpriseUsersAddResult.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EnterpriseUsersAddResult message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.EnterpriseUsersAddResult} EnterpriseUsersAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddResult.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.EnterpriseUsersAddResult();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.success = reader.bool();
            break;
          }
          case 3: {
            message.verificationCode = reader.string();
            break;
          }
          case 4: {
            message.code = reader.string();
            break;
          }
          case 5: {
            message.message = reader.string();
            break;
          }
          case 6: {
            message.additionalInfo = reader.string();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an EnterpriseUsersAddResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.EnterpriseUsersAddResult} EnterpriseUsersAddResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EnterpriseUsersAddResult.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EnterpriseUsersAddResult message.
     * @function verify
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EnterpriseUsersAddResult.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.success != null && message.hasOwnProperty("success"))
        if (typeof message.success !== "boolean") return "success: boolean expected";
      if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
        if (!$util.isString(message.verificationCode)) return "verificationCode: string expected";
      if (message.code != null && message.hasOwnProperty("code"))
        if (!$util.isString(message.code)) return "code: string expected";
      if (message.message != null && message.hasOwnProperty("message"))
        if (!$util.isString(message.message)) return "message: string expected";
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        if (!$util.isString(message.additionalInfo)) return "additionalInfo: string expected";
      return null;
    };

    /**
     * Creates an EnterpriseUsersAddResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.EnterpriseUsersAddResult} EnterpriseUsersAddResult
     */
    EnterpriseUsersAddResult.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.EnterpriseUsersAddResult) return object;
      let message = new $root.Enterprise.EnterpriseUsersAddResult();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      if (object.success != null) message.success = Boolean(object.success);
      if (object.verificationCode != null)
        message.verificationCode = String(object.verificationCode);
      if (object.code != null) message.code = String(object.code);
      if (object.message != null) message.message = String(object.message);
      if (object.additionalInfo != null) message.additionalInfo = String(object.additionalInfo);
      return message;
    };

    /**
     * Creates a plain object from an EnterpriseUsersAddResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {Enterprise.EnterpriseUsersAddResult} message EnterpriseUsersAddResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EnterpriseUsersAddResult.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.success = false;
        object.verificationCode = "";
        object.code = "";
        object.message = "";
        object.additionalInfo = "";
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.success != null && message.hasOwnProperty("success"))
        object.success = message.success;
      if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
        object.verificationCode = message.verificationCode;
      if (message.code != null && message.hasOwnProperty("code")) object.code = message.code;
      if (message.message != null && message.hasOwnProperty("message"))
        object.message = message.message;
      if (message.additionalInfo != null && message.hasOwnProperty("additionalInfo"))
        object.additionalInfo = message.additionalInfo;
      return object;
    };

    /**
     * Converts this EnterpriseUsersAddResult to JSON.
     * @function toJSON
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EnterpriseUsersAddResult.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for EnterpriseUsersAddResult
     * @function getTypeUrl
     * @memberof Enterprise.EnterpriseUsersAddResult
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    EnterpriseUsersAddResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.EnterpriseUsersAddResult";
    };

    return EnterpriseUsersAddResult;
  })();

  Enterprise.UpdateMSPPermitsRequest = (function () {
    /**
     * Properties of an UpdateMSPPermitsRequest.
     * @memberof Enterprise
     * @interface IUpdateMSPPermitsRequest
     * @property {number|null} [mspEnterpriseId] UpdateMSPPermitsRequest mspEnterpriseId
     * @property {number|null} [maxAllowedLicenses] UpdateMSPPermitsRequest maxAllowedLicenses
     * @property {Array.<string>|null} [allowedMcProducts] UpdateMSPPermitsRequest allowedMcProducts
     * @property {Array.<string>|null} [allowedAddOns] UpdateMSPPermitsRequest allowedAddOns
     * @property {string|null} [maxFilePlanType] UpdateMSPPermitsRequest maxFilePlanType
     * @property {boolean|null} [allowUnlimitedLicenses] UpdateMSPPermitsRequest allowUnlimitedLicenses
     */

    /**
     * Constructs a new UpdateMSPPermitsRequest.
     * @memberof Enterprise
     * @classdesc Represents an UpdateMSPPermitsRequest.
     * @implements IUpdateMSPPermitsRequest
     * @constructor
     * @param {Enterprise.IUpdateMSPPermitsRequest=} [properties] Properties to set
     */
    function UpdateMSPPermitsRequest(properties) {
      this.allowedMcProducts = [];
      this.allowedAddOns = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateMSPPermitsRequest mspEnterpriseId.
     * @member {number} mspEnterpriseId
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.mspEnterpriseId = 0;

    /**
     * UpdateMSPPermitsRequest maxAllowedLicenses.
     * @member {number} maxAllowedLicenses
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.maxAllowedLicenses = 0;

    /**
     * UpdateMSPPermitsRequest allowedMcProducts.
     * @member {Array.<string>} allowedMcProducts
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.allowedMcProducts = $util.emptyArray;

    /**
     * UpdateMSPPermitsRequest allowedAddOns.
     * @member {Array.<string>} allowedAddOns
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.allowedAddOns = $util.emptyArray;

    /**
     * UpdateMSPPermitsRequest maxFilePlanType.
     * @member {string} maxFilePlanType
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.maxFilePlanType = "";

    /**
     * UpdateMSPPermitsRequest allowUnlimitedLicenses.
     * @member {boolean} allowUnlimitedLicenses
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     */
    UpdateMSPPermitsRequest.prototype.allowUnlimitedLicenses = false;

    /**
     * Creates a new UpdateMSPPermitsRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Enterprise.IUpdateMSPPermitsRequest=} [properties] Properties to set
     * @returns {Enterprise.UpdateMSPPermitsRequest} UpdateMSPPermitsRequest instance
     */
    UpdateMSPPermitsRequest.create = function create(properties) {
      return new UpdateMSPPermitsRequest(properties);
    };

    /**
     * Encodes the specified UpdateMSPPermitsRequest message. Does not implicitly {@link Enterprise.UpdateMSPPermitsRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Enterprise.IUpdateMSPPermitsRequest} message UpdateMSPPermitsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateMSPPermitsRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.mspEnterpriseId != null && Object.hasOwnProperty.call(message, "mspEnterpriseId"))
        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mspEnterpriseId);
      if (
        message.maxAllowedLicenses != null &&
        Object.hasOwnProperty.call(message, "maxAllowedLicenses")
      )
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.maxAllowedLicenses);
      if (message.allowedMcProducts != null && message.allowedMcProducts.length)
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.allowedMcProducts[i]);
      if (message.allowedAddOns != null && message.allowedAddOns.length)
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.allowedAddOns[i]);
      if (message.maxFilePlanType != null && Object.hasOwnProperty.call(message, "maxFilePlanType"))
        writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.maxFilePlanType);
      if (
        message.allowUnlimitedLicenses != null &&
        Object.hasOwnProperty.call(message, "allowUnlimitedLicenses")
      )
        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.allowUnlimitedLicenses);
      return writer;
    };

    /**
     * Encodes the specified UpdateMSPPermitsRequest message, length delimited. Does not implicitly {@link Enterprise.UpdateMSPPermitsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Enterprise.IUpdateMSPPermitsRequest} message UpdateMSPPermitsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateMSPPermitsRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateMSPPermitsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.UpdateMSPPermitsRequest} UpdateMSPPermitsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateMSPPermitsRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.UpdateMSPPermitsRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.mspEnterpriseId = reader.int32();
            break;
          }
          case 2: {
            message.maxAllowedLicenses = reader.int32();
            break;
          }
          case 3: {
            if (!(message.allowedMcProducts && message.allowedMcProducts.length))
              message.allowedMcProducts = [];
            message.allowedMcProducts.push(reader.string());
            break;
          }
          case 4: {
            if (!(message.allowedAddOns && message.allowedAddOns.length))
              message.allowedAddOns = [];
            message.allowedAddOns.push(reader.string());
            break;
          }
          case 5: {
            message.maxFilePlanType = reader.string();
            break;
          }
          case 6: {
            message.allowUnlimitedLicenses = reader.bool();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes an UpdateMSPPermitsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.UpdateMSPPermitsRequest} UpdateMSPPermitsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateMSPPermitsRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateMSPPermitsRequest message.
     * @function verify
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateMSPPermitsRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.mspEnterpriseId != null && message.hasOwnProperty("mspEnterpriseId"))
        if (!$util.isInteger(message.mspEnterpriseId)) return "mspEnterpriseId: integer expected";
      if (message.maxAllowedLicenses != null && message.hasOwnProperty("maxAllowedLicenses"))
        if (!$util.isInteger(message.maxAllowedLicenses))
          return "maxAllowedLicenses: integer expected";
      if (message.allowedMcProducts != null && message.hasOwnProperty("allowedMcProducts")) {
        if (!Array.isArray(message.allowedMcProducts)) return "allowedMcProducts: array expected";
        for (let i = 0; i < message.allowedMcProducts.length; ++i)
          if (!$util.isString(message.allowedMcProducts[i]))
            return "allowedMcProducts: string[] expected";
      }
      if (message.allowedAddOns != null && message.hasOwnProperty("allowedAddOns")) {
        if (!Array.isArray(message.allowedAddOns)) return "allowedAddOns: array expected";
        for (let i = 0; i < message.allowedAddOns.length; ++i)
          if (!$util.isString(message.allowedAddOns[i])) return "allowedAddOns: string[] expected";
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        if (!$util.isString(message.maxFilePlanType)) return "maxFilePlanType: string expected";
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        if (typeof message.allowUnlimitedLicenses !== "boolean")
          return "allowUnlimitedLicenses: boolean expected";
      return null;
    };

    /**
     * Creates an UpdateMSPPermitsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.UpdateMSPPermitsRequest} UpdateMSPPermitsRequest
     */
    UpdateMSPPermitsRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.UpdateMSPPermitsRequest) return object;
      let message = new $root.Enterprise.UpdateMSPPermitsRequest();
      if (object.mspEnterpriseId != null) message.mspEnterpriseId = object.mspEnterpriseId | 0;
      if (object.maxAllowedLicenses != null)
        message.maxAllowedLicenses = object.maxAllowedLicenses | 0;
      if (object.allowedMcProducts) {
        if (!Array.isArray(object.allowedMcProducts))
          throw TypeError(".Enterprise.UpdateMSPPermitsRequest.allowedMcProducts: array expected");
        message.allowedMcProducts = [];
        for (let i = 0; i < object.allowedMcProducts.length; ++i)
          message.allowedMcProducts[i] = String(object.allowedMcProducts[i]);
      }
      if (object.allowedAddOns) {
        if (!Array.isArray(object.allowedAddOns))
          throw TypeError(".Enterprise.UpdateMSPPermitsRequest.allowedAddOns: array expected");
        message.allowedAddOns = [];
        for (let i = 0; i < object.allowedAddOns.length; ++i)
          message.allowedAddOns[i] = String(object.allowedAddOns[i]);
      }
      if (object.maxFilePlanType != null) message.maxFilePlanType = String(object.maxFilePlanType);
      if (object.allowUnlimitedLicenses != null)
        message.allowUnlimitedLicenses = Boolean(object.allowUnlimitedLicenses);
      return message;
    };

    /**
     * Creates a plain object from an UpdateMSPPermitsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {Enterprise.UpdateMSPPermitsRequest} message UpdateMSPPermitsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateMSPPermitsRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.allowedMcProducts = [];
        object.allowedAddOns = [];
      }
      if (options.defaults) {
        object.mspEnterpriseId = 0;
        object.maxAllowedLicenses = 0;
        object.maxFilePlanType = "";
        object.allowUnlimitedLicenses = false;
      }
      if (message.mspEnterpriseId != null && message.hasOwnProperty("mspEnterpriseId"))
        object.mspEnterpriseId = message.mspEnterpriseId;
      if (message.maxAllowedLicenses != null && message.hasOwnProperty("maxAllowedLicenses"))
        object.maxAllowedLicenses = message.maxAllowedLicenses;
      if (message.allowedMcProducts && message.allowedMcProducts.length) {
        object.allowedMcProducts = [];
        for (let j = 0; j < message.allowedMcProducts.length; ++j)
          object.allowedMcProducts[j] = message.allowedMcProducts[j];
      }
      if (message.allowedAddOns && message.allowedAddOns.length) {
        object.allowedAddOns = [];
        for (let j = 0; j < message.allowedAddOns.length; ++j)
          object.allowedAddOns[j] = message.allowedAddOns[j];
      }
      if (message.maxFilePlanType != null && message.hasOwnProperty("maxFilePlanType"))
        object.maxFilePlanType = message.maxFilePlanType;
      if (
        message.allowUnlimitedLicenses != null &&
        message.hasOwnProperty("allowUnlimitedLicenses")
      )
        object.allowUnlimitedLicenses = message.allowUnlimitedLicenses;
      return object;
    };

    /**
     * Converts this UpdateMSPPermitsRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateMSPPermitsRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UpdateMSPPermitsRequest
     * @function getTypeUrl
     * @memberof Enterprise.UpdateMSPPermitsRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UpdateMSPPermitsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.UpdateMSPPermitsRequest";
    };

    return UpdateMSPPermitsRequest;
  })();

  Enterprise.DeleteEnterpriseUsersRequest = (function () {
    /**
     * Properties of a DeleteEnterpriseUsersRequest.
     * @memberof Enterprise
     * @interface IDeleteEnterpriseUsersRequest
     * @property {Array.<number|Long>|null} [enterpriseUserIds] DeleteEnterpriseUsersRequest enterpriseUserIds
     */

    /**
     * Constructs a new DeleteEnterpriseUsersRequest.
     * @memberof Enterprise
     * @classdesc Represents a DeleteEnterpriseUsersRequest.
     * @implements IDeleteEnterpriseUsersRequest
     * @constructor
     * @param {Enterprise.IDeleteEnterpriseUsersRequest=} [properties] Properties to set
     */
    function DeleteEnterpriseUsersRequest(properties) {
      this.enterpriseUserIds = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteEnterpriseUsersRequest enterpriseUserIds.
     * @member {Array.<number|Long>} enterpriseUserIds
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @instance
     */
    DeleteEnterpriseUsersRequest.prototype.enterpriseUserIds = $util.emptyArray;

    /**
     * Creates a new DeleteEnterpriseUsersRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersRequest=} [properties] Properties to set
     * @returns {Enterprise.DeleteEnterpriseUsersRequest} DeleteEnterpriseUsersRequest instance
     */
    DeleteEnterpriseUsersRequest.create = function create(properties) {
      return new DeleteEnterpriseUsersRequest(properties);
    };

    /**
     * Encodes the specified DeleteEnterpriseUsersRequest message. Does not implicitly {@link Enterprise.DeleteEnterpriseUsersRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersRequest} message DeleteEnterpriseUsersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUsersRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseUserIds != null && message.enterpriseUserIds.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          writer.int64(message.enterpriseUserIds[i]);
        writer.ldelim();
      }
      return writer;
    };

    /**
     * Encodes the specified DeleteEnterpriseUsersRequest message, length delimited. Does not implicitly {@link Enterprise.DeleteEnterpriseUsersRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersRequest} message DeleteEnterpriseUsersRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUsersRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteEnterpriseUsersRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DeleteEnterpriseUsersRequest} DeleteEnterpriseUsersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUsersRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DeleteEnterpriseUsersRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.enterpriseUserIds && message.enterpriseUserIds.length))
              message.enterpriseUserIds = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserIds.push(reader.int64());
            } else message.enterpriseUserIds.push(reader.int64());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DeleteEnterpriseUsersRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DeleteEnterpriseUsersRequest} DeleteEnterpriseUsersRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUsersRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteEnterpriseUsersRequest message.
     * @function verify
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteEnterpriseUsersRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserIds != null && message.hasOwnProperty("enterpriseUserIds")) {
        if (!Array.isArray(message.enterpriseUserIds)) return "enterpriseUserIds: array expected";
        for (let i = 0; i < message.enterpriseUserIds.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserIds[i]) &&
            !(
              message.enterpriseUserIds[i] &&
              $util.isInteger(message.enterpriseUserIds[i].low) &&
              $util.isInteger(message.enterpriseUserIds[i].high)
            )
          )
            return "enterpriseUserIds: integer|Long[] expected";
      }
      return null;
    };

    /**
     * Creates a DeleteEnterpriseUsersRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DeleteEnterpriseUsersRequest} DeleteEnterpriseUsersRequest
     */
    DeleteEnterpriseUsersRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DeleteEnterpriseUsersRequest) return object;
      let message = new $root.Enterprise.DeleteEnterpriseUsersRequest();
      if (object.enterpriseUserIds) {
        if (!Array.isArray(object.enterpriseUserIds))
          throw TypeError(
            ".Enterprise.DeleteEnterpriseUsersRequest.enterpriseUserIds: array expected",
          );
        message.enterpriseUserIds = [];
        for (let i = 0; i < object.enterpriseUserIds.length; ++i)
          if ($util.Long)
            (message.enterpriseUserIds[i] = $util.Long.fromValue(
              object.enterpriseUserIds[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserIds[i] === "string")
            message.enterpriseUserIds[i] = parseInt(object.enterpriseUserIds[i], 10);
          else if (typeof object.enterpriseUserIds[i] === "number")
            message.enterpriseUserIds[i] = object.enterpriseUserIds[i];
          else if (typeof object.enterpriseUserIds[i] === "object")
            message.enterpriseUserIds[i] = new $util.LongBits(
              object.enterpriseUserIds[i].low >>> 0,
              object.enterpriseUserIds[i].high >>> 0,
            ).toNumber();
      }
      return message;
    };

    /**
     * Creates a plain object from a DeleteEnterpriseUsersRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {Enterprise.DeleteEnterpriseUsersRequest} message DeleteEnterpriseUsersRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteEnterpriseUsersRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserIds = [];
      if (message.enterpriseUserIds && message.enterpriseUserIds.length) {
        object.enterpriseUserIds = [];
        for (let j = 0; j < message.enterpriseUserIds.length; ++j)
          if (typeof message.enterpriseUserIds[j] === "number")
            object.enterpriseUserIds[j] =
              options.longs === String
                ? String(message.enterpriseUserIds[j])
                : message.enterpriseUserIds[j];
          else
            object.enterpriseUserIds[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserIds[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserIds[j].low >>> 0,
                      message.enterpriseUserIds[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserIds[j];
      }
      return object;
    };

    /**
     * Converts this DeleteEnterpriseUsersRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteEnterpriseUsersRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DeleteEnterpriseUsersRequest
     * @function getTypeUrl
     * @memberof Enterprise.DeleteEnterpriseUsersRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DeleteEnterpriseUsersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DeleteEnterpriseUsersRequest";
    };

    return DeleteEnterpriseUsersRequest;
  })();

  Enterprise.DeleteEnterpriseUserStatus = (function () {
    /**
     * Properties of a DeleteEnterpriseUserStatus.
     * @memberof Enterprise
     * @interface IDeleteEnterpriseUserStatus
     * @property {number|Long|null} [enterpriseUserId] DeleteEnterpriseUserStatus enterpriseUserId
     * @property {Enterprise.DeleteEnterpriseUsersResult|null} [status] DeleteEnterpriseUserStatus status
     */

    /**
     * Constructs a new DeleteEnterpriseUserStatus.
     * @memberof Enterprise
     * @classdesc Represents a DeleteEnterpriseUserStatus.
     * @implements IDeleteEnterpriseUserStatus
     * @constructor
     * @param {Enterprise.IDeleteEnterpriseUserStatus=} [properties] Properties to set
     */
    function DeleteEnterpriseUserStatus(properties) {
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteEnterpriseUserStatus enterpriseUserId.
     * @member {number|Long} enterpriseUserId
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @instance
     */
    DeleteEnterpriseUserStatus.prototype.enterpriseUserId = $util.Long
      ? $util.Long.fromBits(0, 0, false)
      : 0;

    /**
     * DeleteEnterpriseUserStatus status.
     * @member {Enterprise.DeleteEnterpriseUsersResult} status
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @instance
     */
    DeleteEnterpriseUserStatus.prototype.status = 0;

    /**
     * Creates a new DeleteEnterpriseUserStatus instance using the specified properties.
     * @function create
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Enterprise.IDeleteEnterpriseUserStatus=} [properties] Properties to set
     * @returns {Enterprise.DeleteEnterpriseUserStatus} DeleteEnterpriseUserStatus instance
     */
    DeleteEnterpriseUserStatus.create = function create(properties) {
      return new DeleteEnterpriseUserStatus(properties);
    };

    /**
     * Encodes the specified DeleteEnterpriseUserStatus message. Does not implicitly {@link Enterprise.DeleteEnterpriseUserStatus.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Enterprise.IDeleteEnterpriseUserStatus} message DeleteEnterpriseUserStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUserStatus.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (
        message.enterpriseUserId != null &&
        Object.hasOwnProperty.call(message, "enterpriseUserId")
      )
        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.enterpriseUserId);
      if (message.status != null && Object.hasOwnProperty.call(message, "status"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.status);
      return writer;
    };

    /**
     * Encodes the specified DeleteEnterpriseUserStatus message, length delimited. Does not implicitly {@link Enterprise.DeleteEnterpriseUserStatus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Enterprise.IDeleteEnterpriseUserStatus} message DeleteEnterpriseUserStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUserStatus.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteEnterpriseUserStatus message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DeleteEnterpriseUserStatus} DeleteEnterpriseUserStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUserStatus.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DeleteEnterpriseUserStatus();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            message.enterpriseUserId = reader.int64();
            break;
          }
          case 2: {
            message.status = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DeleteEnterpriseUserStatus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DeleteEnterpriseUserStatus} DeleteEnterpriseUserStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUserStatus.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteEnterpriseUserStatus message.
     * @function verify
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteEnterpriseUserStatus.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (
          !$util.isInteger(message.enterpriseUserId) &&
          !(
            message.enterpriseUserId &&
            $util.isInteger(message.enterpriseUserId.low) &&
            $util.isInteger(message.enterpriseUserId.high)
          )
        )
          return "enterpriseUserId: integer|Long expected";
      if (message.status != null && message.hasOwnProperty("status"))
        switch (message.status) {
          default:
            return "status: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
            break;
        }
      return null;
    };

    /**
     * Creates a DeleteEnterpriseUserStatus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DeleteEnterpriseUserStatus} DeleteEnterpriseUserStatus
     */
    DeleteEnterpriseUserStatus.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DeleteEnterpriseUserStatus) return object;
      let message = new $root.Enterprise.DeleteEnterpriseUserStatus();
      if (object.enterpriseUserId != null)
        if ($util.Long)
          (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned =
            false;
        else if (typeof object.enterpriseUserId === "string")
          message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
        else if (typeof object.enterpriseUserId === "number")
          message.enterpriseUserId = object.enterpriseUserId;
        else if (typeof object.enterpriseUserId === "object")
          message.enterpriseUserId = new $util.LongBits(
            object.enterpriseUserId.low >>> 0,
            object.enterpriseUserId.high >>> 0,
          ).toNumber();
      switch (object.status) {
        default:
          if (typeof object.status === "number") {
            message.status = object.status;
            break;
          }
          break;
        case "SUCCESS":
        case 0:
          message.status = 0;
          break;
        case "NOT_AN_ENTERPRISE_USER":
        case 1:
          message.status = 1;
          break;
        case "CANNOT_DELETE_SELF":
        case 2:
          message.status = 2;
          break;
        case "BRIDGE_CANNOT_DELETE_ACTIVE_USER":
        case 3:
          message.status = 3;
          break;
        case "ERROR":
        case 4:
          message.status = 4;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a DeleteEnterpriseUserStatus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {Enterprise.DeleteEnterpriseUserStatus} message DeleteEnterpriseUserStatus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteEnterpriseUserStatus.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.defaults) {
        if ($util.Long) {
          let long = new $util.Long(0, 0, false);
          object.enterpriseUserId =
            options.longs === String
              ? long.toString()
              : options.longs === Number
                ? long.toNumber()
                : long;
        } else object.enterpriseUserId = options.longs === String ? "0" : 0;
        object.status = options.enums === String ? "SUCCESS" : 0;
      }
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
        if (typeof message.enterpriseUserId === "number")
          object.enterpriseUserId =
            options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
        else
          object.enterpriseUserId =
            options.longs === String
              ? $util.Long.prototype.toString.call(message.enterpriseUserId)
              : options.longs === Number
                ? new $util.LongBits(
                    message.enterpriseUserId.low >>> 0,
                    message.enterpriseUserId.high >>> 0,
                  ).toNumber()
                : message.enterpriseUserId;
      if (message.status != null && message.hasOwnProperty("status"))
        object.status =
          options.enums === String
            ? $root.Enterprise.DeleteEnterpriseUsersResult[message.status] === undefined
              ? message.status
              : $root.Enterprise.DeleteEnterpriseUsersResult[message.status]
            : message.status;
      return object;
    };

    /**
     * Converts this DeleteEnterpriseUserStatus to JSON.
     * @function toJSON
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteEnterpriseUserStatus.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DeleteEnterpriseUserStatus
     * @function getTypeUrl
     * @memberof Enterprise.DeleteEnterpriseUserStatus
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DeleteEnterpriseUserStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DeleteEnterpriseUserStatus";
    };

    return DeleteEnterpriseUserStatus;
  })();

  Enterprise.DeleteEnterpriseUsersResponse = (function () {
    /**
     * Properties of a DeleteEnterpriseUsersResponse.
     * @memberof Enterprise
     * @interface IDeleteEnterpriseUsersResponse
     * @property {Array.<Enterprise.IDeleteEnterpriseUserStatus>|null} [deleteStatus] DeleteEnterpriseUsersResponse deleteStatus
     */

    /**
     * Constructs a new DeleteEnterpriseUsersResponse.
     * @memberof Enterprise
     * @classdesc Represents a DeleteEnterpriseUsersResponse.
     * @implements IDeleteEnterpriseUsersResponse
     * @constructor
     * @param {Enterprise.IDeleteEnterpriseUsersResponse=} [properties] Properties to set
     */
    function DeleteEnterpriseUsersResponse(properties) {
      this.deleteStatus = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteEnterpriseUsersResponse deleteStatus.
     * @member {Array.<Enterprise.IDeleteEnterpriseUserStatus>} deleteStatus
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @instance
     */
    DeleteEnterpriseUsersResponse.prototype.deleteStatus = $util.emptyArray;

    /**
     * Creates a new DeleteEnterpriseUsersResponse instance using the specified properties.
     * @function create
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersResponse=} [properties] Properties to set
     * @returns {Enterprise.DeleteEnterpriseUsersResponse} DeleteEnterpriseUsersResponse instance
     */
    DeleteEnterpriseUsersResponse.create = function create(properties) {
      return new DeleteEnterpriseUsersResponse(properties);
    };

    /**
     * Encodes the specified DeleteEnterpriseUsersResponse message. Does not implicitly {@link Enterprise.DeleteEnterpriseUsersResponse.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersResponse} message DeleteEnterpriseUsersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUsersResponse.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.deleteStatus != null && message.deleteStatus.length)
        for (let i = 0; i < message.deleteStatus.length; ++i)
          $root.Enterprise.DeleteEnterpriseUserStatus.encode(
            message.deleteStatus[i],
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
      return writer;
    };

    /**
     * Encodes the specified DeleteEnterpriseUsersResponse message, length delimited. Does not implicitly {@link Enterprise.DeleteEnterpriseUsersResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Enterprise.IDeleteEnterpriseUsersResponse} message DeleteEnterpriseUsersResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteEnterpriseUsersResponse.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteEnterpriseUsersResponse message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.DeleteEnterpriseUsersResponse} DeleteEnterpriseUsersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUsersResponse.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.DeleteEnterpriseUsersResponse();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.deleteStatus && message.deleteStatus.length)) message.deleteStatus = [];
            message.deleteStatus.push(
              $root.Enterprise.DeleteEnterpriseUserStatus.decode(reader, reader.uint32()),
            );
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a DeleteEnterpriseUsersResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.DeleteEnterpriseUsersResponse} DeleteEnterpriseUsersResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteEnterpriseUsersResponse.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteEnterpriseUsersResponse message.
     * @function verify
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteEnterpriseUsersResponse.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.deleteStatus != null && message.hasOwnProperty("deleteStatus")) {
        if (!Array.isArray(message.deleteStatus)) return "deleteStatus: array expected";
        for (let i = 0; i < message.deleteStatus.length; ++i) {
          let error = $root.Enterprise.DeleteEnterpriseUserStatus.verify(message.deleteStatus[i]);
          if (error) return "deleteStatus." + error;
        }
      }
      return null;
    };

    /**
     * Creates a DeleteEnterpriseUsersResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.DeleteEnterpriseUsersResponse} DeleteEnterpriseUsersResponse
     */
    DeleteEnterpriseUsersResponse.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.DeleteEnterpriseUsersResponse) return object;
      let message = new $root.Enterprise.DeleteEnterpriseUsersResponse();
      if (object.deleteStatus) {
        if (!Array.isArray(object.deleteStatus))
          throw TypeError(".Enterprise.DeleteEnterpriseUsersResponse.deleteStatus: array expected");
        message.deleteStatus = [];
        for (let i = 0; i < object.deleteStatus.length; ++i) {
          if (typeof object.deleteStatus[i] !== "object")
            throw TypeError(
              ".Enterprise.DeleteEnterpriseUsersResponse.deleteStatus: object expected",
            );
          message.deleteStatus[i] = $root.Enterprise.DeleteEnterpriseUserStatus.fromObject(
            object.deleteStatus[i],
          );
        }
      }
      return message;
    };

    /**
     * Creates a plain object from a DeleteEnterpriseUsersResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {Enterprise.DeleteEnterpriseUsersResponse} message DeleteEnterpriseUsersResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteEnterpriseUsersResponse.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.deleteStatus = [];
      if (message.deleteStatus && message.deleteStatus.length) {
        object.deleteStatus = [];
        for (let j = 0; j < message.deleteStatus.length; ++j)
          object.deleteStatus[j] = $root.Enterprise.DeleteEnterpriseUserStatus.toObject(
            message.deleteStatus[j],
            options,
          );
      }
      return object;
    };

    /**
     * Converts this DeleteEnterpriseUsersResponse to JSON.
     * @function toJSON
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteEnterpriseUsersResponse.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DeleteEnterpriseUsersResponse
     * @function getTypeUrl
     * @memberof Enterprise.DeleteEnterpriseUsersResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DeleteEnterpriseUsersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.DeleteEnterpriseUsersResponse";
    };

    return DeleteEnterpriseUsersResponse;
  })();

  Enterprise.ClearSecurityDataRequest = (function () {
    /**
     * Properties of a ClearSecurityDataRequest.
     * @memberof Enterprise
     * @interface IClearSecurityDataRequest
     * @property {Array.<number|Long>|null} [enterpriseUserId] ClearSecurityDataRequest enterpriseUserId
     * @property {boolean|null} [allUsers] ClearSecurityDataRequest allUsers
     * @property {Enterprise.ClearSecurityDataType|null} [type] ClearSecurityDataRequest type
     */

    /**
     * Constructs a new ClearSecurityDataRequest.
     * @memberof Enterprise
     * @classdesc Represents a ClearSecurityDataRequest.
     * @implements IClearSecurityDataRequest
     * @constructor
     * @param {Enterprise.IClearSecurityDataRequest=} [properties] Properties to set
     */
    function ClearSecurityDataRequest(properties) {
      this.enterpriseUserId = [];
      if (properties)
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClearSecurityDataRequest enterpriseUserId.
     * @member {Array.<number|Long>} enterpriseUserId
     * @memberof Enterprise.ClearSecurityDataRequest
     * @instance
     */
    ClearSecurityDataRequest.prototype.enterpriseUserId = $util.emptyArray;

    /**
     * ClearSecurityDataRequest allUsers.
     * @member {boolean} allUsers
     * @memberof Enterprise.ClearSecurityDataRequest
     * @instance
     */
    ClearSecurityDataRequest.prototype.allUsers = false;

    /**
     * ClearSecurityDataRequest type.
     * @member {Enterprise.ClearSecurityDataType} type
     * @memberof Enterprise.ClearSecurityDataRequest
     * @instance
     */
    ClearSecurityDataRequest.prototype.type = 0;

    /**
     * Creates a new ClearSecurityDataRequest instance using the specified properties.
     * @function create
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Enterprise.IClearSecurityDataRequest=} [properties] Properties to set
     * @returns {Enterprise.ClearSecurityDataRequest} ClearSecurityDataRequest instance
     */
    ClearSecurityDataRequest.create = function create(properties) {
      return new ClearSecurityDataRequest(properties);
    };

    /**
     * Encodes the specified ClearSecurityDataRequest message. Does not implicitly {@link Enterprise.ClearSecurityDataRequest.verify|verify} messages.
     * @function encode
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Enterprise.IClearSecurityDataRequest} message ClearSecurityDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClearSecurityDataRequest.encode = function encode(message, writer) {
      if (!writer) writer = $Writer.create();
      if (message.enterpriseUserId != null && message.enterpriseUserId.length) {
        writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
        for (let i = 0; i < message.enterpriseUserId.length; ++i)
          writer.int64(message.enterpriseUserId[i]);
        writer.ldelim();
      }
      if (message.allUsers != null && Object.hasOwnProperty.call(message, "allUsers"))
        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allUsers);
      if (message.type != null && Object.hasOwnProperty.call(message, "type"))
        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.type);
      return writer;
    };

    /**
     * Encodes the specified ClearSecurityDataRequest message, length delimited. Does not implicitly {@link Enterprise.ClearSecurityDataRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Enterprise.IClearSecurityDataRequest} message ClearSecurityDataRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClearSecurityDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClearSecurityDataRequest message from the specified reader or buffer.
     * @function decode
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Enterprise.ClearSecurityDataRequest} ClearSecurityDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClearSecurityDataRequest.decode = function decode(reader, length, error) {
      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
      let end = length === undefined ? reader.len : reader.pos + length,
        message = new $root.Enterprise.ClearSecurityDataRequest();
      while (reader.pos < end) {
        let tag = reader.uint32();
        if (tag === error) break;
        switch (tag >>> 3) {
          case 1: {
            if (!(message.enterpriseUserId && message.enterpriseUserId.length))
              message.enterpriseUserId = [];
            if ((tag & 7) === 2) {
              let end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) message.enterpriseUserId.push(reader.int64());
            } else message.enterpriseUserId.push(reader.int64());
            break;
          }
          case 2: {
            message.allUsers = reader.bool();
            break;
          }
          case 3: {
            message.type = reader.int32();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };

    /**
     * Decodes a ClearSecurityDataRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Enterprise.ClearSecurityDataRequest} ClearSecurityDataRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClearSecurityDataRequest.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader)) reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClearSecurityDataRequest message.
     * @function verify
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClearSecurityDataRequest.verify = function verify(message) {
      if (typeof message !== "object" || message === null) return "object expected";
      if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId")) {
        if (!Array.isArray(message.enterpriseUserId)) return "enterpriseUserId: array expected";
        for (let i = 0; i < message.enterpriseUserId.length; ++i)
          if (
            !$util.isInteger(message.enterpriseUserId[i]) &&
            !(
              message.enterpriseUserId[i] &&
              $util.isInteger(message.enterpriseUserId[i].low) &&
              $util.isInteger(message.enterpriseUserId[i].high)
            )
          )
            return "enterpriseUserId: integer|Long[] expected";
      }
      if (message.allUsers != null && message.hasOwnProperty("allUsers"))
        if (typeof message.allUsers !== "boolean") return "allUsers: boolean expected";
      if (message.type != null && message.hasOwnProperty("type"))
        switch (message.type) {
          default:
            return "type: enum value expected";
          case 0:
          case 1:
          case 2:
            break;
        }
      return null;
    };

    /**
     * Creates a ClearSecurityDataRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Enterprise.ClearSecurityDataRequest} ClearSecurityDataRequest
     */
    ClearSecurityDataRequest.fromObject = function fromObject(object) {
      if (object instanceof $root.Enterprise.ClearSecurityDataRequest) return object;
      let message = new $root.Enterprise.ClearSecurityDataRequest();
      if (object.enterpriseUserId) {
        if (!Array.isArray(object.enterpriseUserId))
          throw TypeError(".Enterprise.ClearSecurityDataRequest.enterpriseUserId: array expected");
        message.enterpriseUserId = [];
        for (let i = 0; i < object.enterpriseUserId.length; ++i)
          if ($util.Long)
            (message.enterpriseUserId[i] = $util.Long.fromValue(
              object.enterpriseUserId[i],
            )).unsigned = false;
          else if (typeof object.enterpriseUserId[i] === "string")
            message.enterpriseUserId[i] = parseInt(object.enterpriseUserId[i], 10);
          else if (typeof object.enterpriseUserId[i] === "number")
            message.enterpriseUserId[i] = object.enterpriseUserId[i];
          else if (typeof object.enterpriseUserId[i] === "object")
            message.enterpriseUserId[i] = new $util.LongBits(
              object.enterpriseUserId[i].low >>> 0,
              object.enterpriseUserId[i].high >>> 0,
            ).toNumber();
      }
      if (object.allUsers != null) message.allUsers = Boolean(object.allUsers);
      switch (object.type) {
        default:
          if (typeof object.type === "number") {
            message.type = object.type;
            break;
          }
          break;
        case "RECALCULATE_SUMMARY_REPORT":
        case 0:
          message.type = 0;
          break;
        case "FORCE_CLIENT_CHECK_FOR_MISSING_DATA":
        case 1:
          message.type = 1;
          break;
        case "FORCE_CLIENT_RESEND_SECURITY_DATA":
        case 2:
          message.type = 2;
          break;
      }
      return message;
    };

    /**
     * Creates a plain object from a ClearSecurityDataRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {Enterprise.ClearSecurityDataRequest} message ClearSecurityDataRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClearSecurityDataRequest.toObject = function toObject(message, options) {
      if (!options) options = {};
      let object = {};
      if (options.arrays || options.defaults) object.enterpriseUserId = [];
      if (options.defaults) {
        object.allUsers = false;
        object.type = options.enums === String ? "RECALCULATE_SUMMARY_REPORT" : 0;
      }
      if (message.enterpriseUserId && message.enterpriseUserId.length) {
        object.enterpriseUserId = [];
        for (let j = 0; j < message.enterpriseUserId.length; ++j)
          if (typeof message.enterpriseUserId[j] === "number")
            object.enterpriseUserId[j] =
              options.longs === String
                ? String(message.enterpriseUserId[j])
                : message.enterpriseUserId[j];
          else
            object.enterpriseUserId[j] =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.enterpriseUserId[j])
                : options.longs === Number
                  ? new $util.LongBits(
                      message.enterpriseUserId[j].low >>> 0,
                      message.enterpriseUserId[j].high >>> 0,
                    ).toNumber()
                  : message.enterpriseUserId[j];
      }
      if (message.allUsers != null && message.hasOwnProperty("allUsers"))
        object.allUsers = message.allUsers;
      if (message.type != null && message.hasOwnProperty("type"))
        object.type =
          options.enums === String
            ? $root.Enterprise.ClearSecurityDataType[message.type] === undefined
              ? message.type
              : $root.Enterprise.ClearSecurityDataType[message.type]
            : message.type;
      return object;
    };

    /**
     * Converts this ClearSecurityDataRequest to JSON.
     * @function toJSON
     * @memberof Enterprise.ClearSecurityDataRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClearSecurityDataRequest.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ClearSecurityDataRequest
     * @function getTypeUrl
     * @memberof Enterprise.ClearSecurityDataRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ClearSecurityDataRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === undefined) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/Enterprise.ClearSecurityDataRequest";
    };

    return ClearSecurityDataRequest;
  })();

  return Enterprise;
})());

export { $root as default };
