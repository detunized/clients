// @ts-nocheck
// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "APIRequest.proto" (package "Authentication", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedKey } from "./enterprise";
import { AppClientType } from "./enterprise";
import { KeyType } from "./enterprise";
import { EnterpriseRegistration } from "./enterprise";
import { EncryptedKeyType } from "./enterprise";
/**
 * @generated from protobuf message Authentication.ApiRequest
 */
export interface ApiRequest {
  /**
   * @generated from protobuf field: bytes encryptedTransmissionKey = 1
   */
  encryptedTransmissionKey: Uint8Array;
  /**
   * @generated from protobuf field: int32 publicKeyId = 2
   */
  publicKeyId: number;
  /**
   * @generated from protobuf field: string locale = 3
   */
  locale: string;
  /**
   * @generated from protobuf field: bytes encryptedPayload = 4
   */
  encryptedPayload: Uint8Array;
  /**
   * @generated from protobuf field: int32 encryptionType = 5
   */
  encryptionType: number;
  /**
   * @generated from protobuf field: string recaptcha = 6
   */
  recaptcha: string;
  /**
   * @generated from protobuf field: string subEnvironment = 7
   */
  subEnvironment: string;
}
/**
 * @generated from protobuf message Authentication.ApiRequestPayload
 */
export interface ApiRequestPayload {
  /**
   * @generated from protobuf field: bytes payload = 1
   */
  payload: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedSessionToken = 2
   */
  encryptedSessionToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes timeToken = 3
   */
  timeToken: Uint8Array;
  /**
   * @generated from protobuf field: int32 apiVersion = 4
   */
  apiVersion: number;
}
/**
 * @generated from protobuf message Authentication.Transform
 */
export interface Transform {
  /**
   * @generated from protobuf field: bytes key = 1
   */
  key: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 2
   */
  encryptedDeviceToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.DeviceRequest
 */
export interface DeviceRequest {
  /**
   * @generated from protobuf field: string clientVersion = 1
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string deviceName = 2
   */
  deviceName: string;
  /**
   * @generated from protobuf field: string devicePlatform = 3
   */
  devicePlatform: string;
  /**
   * @generated from protobuf field: Authentication.ClientFormFactor clientFormFactor = 4
   */
  clientFormFactor: ClientFormFactor;
  /**
   * @generated from protobuf field: string username = 5
   */
  username: string;
}
/**
 * @generated from protobuf message Authentication.AuthRequest
 */
export interface AuthRequest {
  /**
   * @generated from protobuf field: string clientVersion = 1
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string username = 2
   */
  username: string;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 3
   */
  encryptedDeviceToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.NewUserMinimumParams
 */
export interface NewUserMinimumParams {
  /**
   * @generated from protobuf field: int32 minimumIterations = 1
   */
  minimumIterations: number;
  /**
   * @generated from protobuf field: repeated string passwordMatchRegex = 2
   */
  passwordMatchRegex: string[];
  /**
   * @generated from protobuf field: repeated string passwordMatchDescription = 3
   */
  passwordMatchDescription: string[];
  /**
   * @generated from protobuf field: bool isEnterpriseDomain = 4
   */
  isEnterpriseDomain: boolean;
  /**
   * @generated from protobuf field: bytes enterpriseEccPublicKey = 5
   */
  enterpriseEccPublicKey: Uint8Array;
  /**
   * @generated from protobuf field: bool forbidKeyType2 = 6
   */
  forbidKeyType2: boolean;
}
/**
 * @generated from protobuf message Authentication.PreLoginRequest
 */
export interface PreLoginRequest {
  /**
   * @generated from protobuf field: Authentication.AuthRequest authRequest = 1
   */
  authRequest?: AuthRequest;
  /**
   * @generated from protobuf field: Authentication.LoginType loginType = 2
   */
  loginType: LoginType;
  /**
   * @generated from protobuf field: bytes twoFactorToken = 3
   */
  twoFactorToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.LoginRequest
 */
export interface LoginRequest {
  /**
   * @generated from protobuf field: Authentication.AuthRequest authRequest = 1
   */
  authRequest?: AuthRequest;
  /**
   * @generated from protobuf field: Authentication.LoginType loginType = 2
   */
  loginType: LoginType;
  /**
   * @generated from protobuf field: bytes authenticationHashPrime = 3
   */
  authenticationHashPrime: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 4
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes authResponse = 5
   */
  authResponse: Uint8Array;
  /**
   * @generated from protobuf field: int32 mcEnterpriseId = 6
   */
  mcEnterpriseId: number;
  /**
   * @generated from protobuf field: string push_token = 7
   */
  pushToken: string;
  /**
   * @generated from protobuf field: string platform = 8
   */
  platform: string;
}
/**
 * @generated from protobuf message Authentication.DeviceResponse
 */
export interface DeviceResponse {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.DeviceStatus status = 2
   */
  status: DeviceStatus;
}
/**
 * @generated from protobuf message Authentication.Salt
 */
export interface Salt {
  /**
   * @generated from protobuf field: int32 iterations = 1
   */
  iterations: number;
  /**
   * @generated from protobuf field: bytes salt = 2
   */
  salt: Uint8Array;
  /**
   * @generated from protobuf field: int32 algorithm = 3
   */
  algorithm: number;
  /**
   * @generated from protobuf field: bytes uid = 4
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: string name = 5
   */
  name: string;
}
/**
 * @generated from protobuf message Authentication.TwoFactorChannel
 */
export interface TwoFactorChannel {
  /**
   * @generated from protobuf field: int32 type = 1
   */
  type: number;
}
/**
 * @generated from protobuf message Authentication.StartLoginRequest
 */
export interface StartLoginRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string username = 2
   */
  username: string;
  /**
   * @generated from protobuf field: string clientVersion = 3
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: bytes messageSessionUid = 4
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 5
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.LoginType loginType = 6
   */
  loginType: LoginType;
  /**
   * @generated from protobuf field: int32 mcEnterpriseId = 7
   */
  mcEnterpriseId: number;
  /**
   * @generated from protobuf field: Authentication.LoginMethod loginMethod = 8
   */
  loginMethod: LoginMethod;
  /**
   * @generated from protobuf field: bool forceNewLogin = 9
   */
  forceNewLogin: boolean;
  /**
   * @generated from protobuf field: bytes cloneCode = 10
   */
  cloneCode: Uint8Array;
  /**
   * @generated from protobuf field: string v2TwoFactorToken = 11
   */
  v2TwoFactorToken: string;
  /**
   * @generated from protobuf field: bytes accountUid = 12
   */
  accountUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes fromSessionToken = 13
   */
  fromSessionToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.LoginResponse
 */
export interface LoginResponse {
  /**
   * @generated from protobuf field: Authentication.LoginState loginState = 1
   */
  loginState: LoginState;
  /**
   * @generated from protobuf field: bytes accountUid = 2
   */
  accountUid: Uint8Array;
  /**
   * @generated from protobuf field: string primaryUsername = 3
   */
  primaryUsername: string;
  /**
   * @generated from protobuf field: bytes encryptedDataKey = 4
   */
  encryptedDataKey: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.EncryptedDataKeyType encryptedDataKeyType = 5
   */
  encryptedDataKeyType: EncryptedDataKeyType;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 6
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedSessionToken = 7
   */
  encryptedSessionToken: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.SessionTokenType sessionTokenType = 8
   */
  sessionTokenType: SessionTokenType;
  /**
   * @generated from protobuf field: string message = 9
   */
  message: string;
  /**
   * @generated from protobuf field: string url = 10
   */
  url: string;
  /**
   * @generated from protobuf field: repeated Authentication.TwoFactorChannelInfo channels = 11
   */
  channels: TwoFactorChannelInfo[];
  /**
   * @generated from protobuf field: repeated Authentication.Salt salt = 12
   */
  salt: Salt[];
  /**
   * @generated from protobuf field: bytes cloneCode = 13
   */
  cloneCode: Uint8Array;
  /**
   * @generated from protobuf field: string stateSpecificValue = 14
   */
  stateSpecificValue: string;
  /**
   * @generated from protobuf field: string ssoClientVersion = 15
   */
  ssoClientVersion: string;
  /**
   * @generated from protobuf field: string sessionTokenTypeModifier = 16
   */
  sessionTokenTypeModifier: string;
}
/**
 * @generated from protobuf message Authentication.SwitchListElement
 */
export interface SwitchListElement {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: string fullName = 2
   */
  fullName: string;
  /**
   * @generated from protobuf field: bool authRequired = 3
   */
  authRequired: boolean;
  /**
   * @generated from protobuf field: bool isLinked = 4
   */
  isLinked: boolean;
}
/**
 * @generated from protobuf message Authentication.SwitchListResponse
 */
export interface SwitchListResponse {
  /**
   * @generated from protobuf field: repeated Authentication.SwitchListElement elements = 1
   */
  elements: SwitchListElement[];
}
/**
 * @generated from protobuf message Authentication.SsoUserInfo
 */
export interface SsoUserInfo {
  /**
   * @generated from protobuf field: string companyName = 1
   */
  companyName: string;
  /**
   * @generated from protobuf field: string samlRequest = 2
   */
  samlRequest: string;
  /**
   * @generated from protobuf field: string samlRequestType = 3
   */
  samlRequestType: string;
  /**
   * @generated from protobuf field: string ssoDomainName = 4
   */
  ssoDomainName: string;
  /**
   * @generated from protobuf field: string loginUrl = 5
   */
  loginUrl: string;
  /**
   * @generated from protobuf field: string logoutUrl = 6
   */
  logoutUrl: string;
}
/**
 * @generated from protobuf message Authentication.PreLoginResponse
 */
export interface PreLoginResponse {
  /**
   * @generated from protobuf field: Authentication.DeviceStatus deviceStatus = 1
   */
  deviceStatus: DeviceStatus;
  /**
   * @generated from protobuf field: repeated Authentication.Salt salt = 2
   */
  salt: Salt[];
  /**
   * @generated from protobuf field: repeated Authentication.TwoFactorChannel OBSOLETE_FIELD = 3
   */
  oBSOLETEFIELD: TwoFactorChannel[];
  /**
   * @generated from protobuf field: Authentication.SsoUserInfo ssoUserInfo = 4
   */
  ssoUserInfo?: SsoUserInfo;
}
/**
 * @generated from protobuf message Authentication.LoginAsUserRequest
 */
export interface LoginAsUserRequest {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
}
/**
 * @generated from protobuf message Authentication.LoginAsUserResponse
 */
export interface LoginAsUserResponse {
  /**
   * @generated from protobuf field: bytes encryptedSessionToken = 1
   */
  encryptedSessionToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedSharedAccountKey = 2
   */
  encryptedSharedAccountKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ValidateAuthHashRequest
 */
export interface ValidateAuthHashRequest {
  /**
   * @generated from protobuf field: Authentication.PasswordMethod passwordMethod = 1
   */
  passwordMethod: PasswordMethod;
  /**
   * @generated from protobuf field: bytes authResponse = 2
   */
  authResponse: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 3
   */
  encryptedLoginToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.TwoFactorChannelInfo
 */
export interface TwoFactorChannelInfo {
  /**
   * @generated from protobuf field: Authentication.TwoFactorChannelType channelType = 1
   */
  channelType: TwoFactorChannelType;
  /**
   * @generated from protobuf field: bytes channel_uid = 2
   */
  channelUid: Uint8Array;
  /**
   * @generated from protobuf field: string channelName = 3
   */
  channelName: string;
  /**
   * @generated from protobuf field: string challenge = 4
   */
  challenge: string;
  /**
   * @generated from protobuf field: repeated string capabilities = 5
   */
  capabilities: string[];
  /**
   * @generated from protobuf field: string phoneNumber = 6
   */
  phoneNumber: string;
  /**
   * @generated from protobuf field: Authentication.TwoFactorExpiration maxExpiration = 7
   */
  maxExpiration: TwoFactorExpiration;
  /**
   * @generated from protobuf field: int64 createdOn = 8
   */
  createdOn: bigint;
  /**
   * @generated from protobuf field: Authentication.TwoFactorExpiration lastFrequency = 9
   */
  lastFrequency: TwoFactorExpiration;
}
/**
 * @generated from protobuf message Authentication.TwoFactorDuoStatus
 */
export interface TwoFactorDuoStatus {
  /**
   * @generated from protobuf field: repeated string capabilities = 1
   */
  capabilities: string[];
  /**
   * @generated from protobuf field: string phoneNumber = 2
   */
  phoneNumber: string;
  /**
   * @generated from protobuf field: string enroll_url = 3
   */
  enrollUrl: string;
  /**
   * @generated from protobuf field: string message = 4
   */
  message: string;
}
/**
 * @generated from protobuf message Authentication.TwoFactorAddRequest
 */
export interface TwoFactorAddRequest {
  /**
   * @generated from protobuf field: Authentication.TwoFactorChannelType channelType = 1
   */
  channelType: TwoFactorChannelType;
  /**
   * @generated from protobuf field: bytes channel_uid = 2
   */
  channelUid: Uint8Array;
  /**
   * @generated from protobuf field: string channelName = 3
   */
  channelName: string;
  /**
   * @generated from protobuf field: string phoneNumber = 4
   */
  phoneNumber: string;
  /**
   * @generated from protobuf field: Authentication.TwoFactorPushType duoPushType = 5
   */
  duoPushType: TwoFactorPushType;
}
/**
 * @generated from protobuf message Authentication.TwoFactorRenameRequest
 */
export interface TwoFactorRenameRequest {
  /**
   * @generated from protobuf field: bytes channel_uid = 1
   */
  channelUid: Uint8Array;
  /**
   * @generated from protobuf field: string channelName = 2
   */
  channelName: string;
}
/**
 * @generated from protobuf message Authentication.TwoFactorAddResponse
 */
export interface TwoFactorAddResponse {
  /**
   * @generated from protobuf field: string challenge = 1
   */
  challenge: string;
  /**
   * @generated from protobuf field: repeated string backupKeys = 2
   */
  backupKeys: string[];
}
/**
 * @generated from protobuf message Authentication.TwoFactorDeleteRequest
 */
export interface TwoFactorDeleteRequest {
  /**
   * @generated from protobuf field: bytes channel_uid = 1
   */
  channelUid: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.TwoFactorListResponse
 */
export interface TwoFactorListResponse {
  /**
   * @generated from protobuf field: repeated Authentication.TwoFactorChannelInfo channels = 1
   */
  channels: TwoFactorChannelInfo[];
  /**
   * @generated from protobuf field: int64 expireOn = 2
   */
  expireOn: bigint;
}
/**
 * @generated from protobuf message Authentication.TwoFactorUpdateExpirationRequest
 */
export interface TwoFactorUpdateExpirationRequest {
  /**
   * @generated from protobuf field: Authentication.TwoFactorExpiration expireIn = 1
   */
  expireIn: TwoFactorExpiration;
}
/**
 * @generated from protobuf message Authentication.TwoFactorValidateRequest
 */
export interface TwoFactorValidateRequest {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.TwoFactorValueType valueType = 2
   */
  valueType: TwoFactorValueType;
  /**
   * @generated from protobuf field: string value = 3
   */
  value: string;
  /**
   * @generated from protobuf field: bytes channel_uid = 4
   */
  channelUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.TwoFactorExpiration expireIn = 5
   */
  expireIn: TwoFactorExpiration;
}
/**
 * @generated from protobuf message Authentication.TwoFactorValidateResponse
 */
export interface TwoFactorValidateResponse {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.TwoFactorSendPushRequest
 */
export interface TwoFactorSendPushRequest {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.TwoFactorPushType pushType = 2
   */
  pushType: TwoFactorPushType;
  /**
   * @generated from protobuf field: bytes channel_uid = 3
   */
  channelUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.TwoFactorExpiration expireIn = 4
   */
  expireIn: TwoFactorExpiration;
}
/**
 * @generated from protobuf message Authentication.License
 */
export interface License {
  /**
   * @generated from protobuf field: int64 created = 1
   */
  created: bigint;
  /**
   * @generated from protobuf field: int64 expiration = 2
   */
  expiration: bigint;
  /**
   * @generated from protobuf field: Authentication.LicenseStatus licenseStatus = 3
   */
  licenseStatus: LicenseStatus;
  /**
   * @generated from protobuf field: bool paid = 4
   */
  paid: boolean;
  /**
   * @generated from protobuf field: string message = 5
   */
  message: string;
}
/**
 * @generated from protobuf message Authentication.OwnerlessRecord
 */
export interface OwnerlessRecord {
  /**
   * @generated from protobuf field: bytes recordUid = 1
   */
  recordUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes recordKey = 2
   */
  recordKey: Uint8Array;
  /**
   * @generated from protobuf field: int32 status = 3
   */
  status: number;
}
/**
 * @generated from protobuf message Authentication.OwnerlessRecords
 */
export interface OwnerlessRecords {
  /**
   * @generated from protobuf field: repeated Authentication.OwnerlessRecord ownerlessRecord = 1
   */
  ownerlessRecord: OwnerlessRecord[];
}
/**
 * @generated from protobuf message Authentication.UserAuthRequest
 */
export interface UserAuthRequest {
  /**
   * @generated from protobuf field: bytes uid = 1
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: bytes salt = 2
   */
  salt: Uint8Array;
  /**
   * @generated from protobuf field: int32 iterations = 3
   */
  iterations: number;
  /**
   * @generated from protobuf field: bytes encryptedClientKey = 4
   */
  encryptedClientKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes authHash = 5
   */
  authHash: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDataKey = 6
   */
  encryptedDataKey: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.LoginType loginType = 7
   */
  loginType: LoginType;
  /**
   * @generated from protobuf field: string name = 8
   */
  name: string;
  /**
   * @generated from protobuf field: int32 algorithm = 9
   */
  algorithm: number;
}
/**
 * @generated from protobuf message Authentication.UidRequest
 */
export interface UidRequest {
  /**
   * @generated from protobuf field: repeated bytes uid = 1
   */
  uid: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.DeviceUpdateRequest
 */
export interface DeviceUpdateRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string deviceName = 3
   */
  deviceName: string;
  /**
   * @generated from protobuf field: bytes devicePublicKey = 4
   */
  devicePublicKey: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.DeviceStatus deviceStatus = 5
   */
  deviceStatus: DeviceStatus;
  /**
   * @generated from protobuf field: string devicePlatform = 6
   */
  devicePlatform: string;
  /**
   * @generated from protobuf field: Authentication.ClientFormFactor clientFormFactor = 7
   */
  clientFormFactor: ClientFormFactor;
}
/**
 * @generated from protobuf message Authentication.DeviceUpdateResponse
 */
export interface DeviceUpdateResponse {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string deviceName = 3
   */
  deviceName: string;
  /**
   * @generated from protobuf field: bytes devicePublicKey = 4
   */
  devicePublicKey: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.DeviceStatus deviceStatus = 5
   */
  deviceStatus: DeviceStatus;
  /**
   * @generated from protobuf field: string devicePlatform = 6
   */
  devicePlatform: string;
  /**
   * @generated from protobuf field: Authentication.ClientFormFactor clientFormFactor = 7
   */
  clientFormFactor: ClientFormFactor;
}
/**
 * @generated from protobuf message Authentication.RegisterDeviceInRegionRequest
 */
export interface RegisterDeviceInRegionRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string deviceName = 3
   */
  deviceName: string;
  /**
   * @generated from protobuf field: bytes devicePublicKey = 4
   */
  devicePublicKey: Uint8Array;
  /**
   * @generated from protobuf field: string devicePlatform = 5
   */
  devicePlatform: string;
  /**
   * @generated from protobuf field: Authentication.ClientFormFactor clientFormFactor = 6
   */
  clientFormFactor: ClientFormFactor;
}
/**
 * @generated from protobuf message Authentication.RegistrationRequest
 */
export interface RegistrationRequest {
  /**
   * @generated from protobuf field: Authentication.AuthRequest authRequest = 1
   */
  authRequest?: AuthRequest;
  /**
   * @generated from protobuf field: Authentication.UserAuthRequest userAuthRequest = 2
   */
  userAuthRequest?: UserAuthRequest;
  /**
   * @generated from protobuf field: bytes encryptedClientKey = 3
   */
  encryptedClientKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedPrivateKey = 4
   */
  encryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes publicKey = 5
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: string verificationCode = 6
   */
  verificationCode: string;
  /**
   * @generated from protobuf field: bytes deprecatedAuthHashHash = 7
   */
  deprecatedAuthHashHash: Uint8Array;
  /**
   * @generated from protobuf field: bytes deprecatedEncryptedClientKey = 8
   */
  deprecatedEncryptedClientKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes deprecatedEncryptedPrivateKey = 9
   */
  deprecatedEncryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes deprecatedEncryptionParams = 10
   */
  deprecatedEncryptionParams: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ConvertUserToV3Request
 */
export interface ConvertUserToV3Request {
  /**
   * @generated from protobuf field: Authentication.AuthRequest authRequest = 1
   */
  authRequest?: AuthRequest;
  /**
   * @generated from protobuf field: Authentication.UserAuthRequest userAuthRequest = 2
   */
  userAuthRequest?: UserAuthRequest;
  /**
   * @generated from protobuf field: bytes encryptedClientKey = 3
   */
  encryptedClientKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedPrivateKey = 4
   */
  encryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes publicKey = 5
   */
  publicKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.RevisionResponse
 */
export interface RevisionResponse {
  /**
   * @generated from protobuf field: int64 revision = 1
   */
  revision: bigint;
}
/**
 * @generated from protobuf message Authentication.ChangeEmailRequest
 */
export interface ChangeEmailRequest {
  /**
   * @generated from protobuf field: string newEmail = 1
   */
  newEmail: string;
}
/**
 * @generated from protobuf message Authentication.ChangeEmailResponse
 */
export interface ChangeEmailResponse {
  /**
   * @generated from protobuf field: bytes encryptedChangeEmailToken = 1
   */
  encryptedChangeEmailToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.EmailVerificationLinkResponse
 */
export interface EmailVerificationLinkResponse {
  /**
   * @generated from protobuf field: bool emailVerified = 1
   */
  emailVerified: boolean;
}
/**
 * @generated from protobuf message Authentication.SecurityData
 */
export interface SecurityData {
  /**
   * @generated from protobuf field: bytes uid = 1
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: bytes data = 2
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SecurityScoreData
 */
export interface SecurityScoreData {
  /**
   * @generated from protobuf field: bytes uid = 1
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: bytes data = 2
   */
  data: Uint8Array;
  /**
   * @generated from protobuf field: int64 revision = 3
   */
  revision: bigint;
}
/**
 * @generated from protobuf message Authentication.SecurityDataRequest
 */
export interface SecurityDataRequest {
  /**
   * @generated from protobuf field: repeated Authentication.SecurityData recordSecurityData = 1
   */
  recordSecurityData: SecurityData[];
  /**
   * @generated from protobuf field: repeated Authentication.SecurityData masterPasswordSecurityData = 2
   */
  masterPasswordSecurityData: SecurityData[];
  /**
   * @generated from protobuf field: Enterprise.EncryptedKeyType encryptionType = 3
   */
  encryptionType: EncryptedKeyType;
  /**
   * @generated from protobuf field: repeated Authentication.SecurityScoreData recordSecurityScoreData = 4
   */
  recordSecurityScoreData: SecurityScoreData[];
}
/**
 * @generated from protobuf message Authentication.SecurityReportIncrementalData
 */
export interface SecurityReportIncrementalData {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: bytes currentSecurityData = 2
   */
  currentSecurityData: Uint8Array;
  /**
   * @generated from protobuf field: int64 currentSecurityDataRevision = 3
   */
  currentSecurityDataRevision: bigint;
  /**
   * @generated from protobuf field: bytes oldSecurityData = 4
   */
  oldSecurityData: Uint8Array;
  /**
   * @generated from protobuf field: int64 oldSecurityDataRevision = 5
   */
  oldSecurityDataRevision: bigint;
  /**
   * @generated from protobuf field: Enterprise.EncryptedKeyType currentDataEncryptionType = 6
   */
  currentDataEncryptionType: EncryptedKeyType;
  /**
   * @generated from protobuf field: Enterprise.EncryptedKeyType oldDataEncryptionType = 7
   */
  oldDataEncryptionType: EncryptedKeyType;
  /**
   * @generated from protobuf field: bytes recordUid = 8
   */
  recordUid: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SecurityReport
 */
export interface SecurityReport {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: bytes encryptedReportData = 2
   */
  encryptedReportData: Uint8Array;
  /**
   * @generated from protobuf field: int64 revision = 3
   */
  revision: bigint;
  /**
   * @generated from protobuf field: string twoFactor = 4
   */
  twoFactor: string;
  /**
   * @generated from protobuf field: int64 lastLogin = 5
   */
  lastLogin: bigint;
  /**
   * @generated from protobuf field: int32 numberOfReusedPassword = 6
   */
  numberOfReusedPassword: number;
  /**
   * @generated from protobuf field: repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData = 7
   */
  securityReportIncrementalData: SecurityReportIncrementalData[];
  /**
   * @generated from protobuf field: int32 userId = 8
   */
  userId: number;
  /**
   * @generated from protobuf field: bool hasOldEncryption = 9
   */
  hasOldEncryption: boolean;
}
/**
 * @generated from protobuf message Authentication.SecurityReportSaveRequest
 */
export interface SecurityReportSaveRequest {
  /**
   * @generated from protobuf field: repeated Authentication.SecurityReport securityReport = 1
   */
  securityReport: SecurityReport[];
  /**
   * @generated from protobuf field: bytes continuationToken = 2
   */
  continuationToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SecurityReportRequest
 */
export interface SecurityReportRequest {
  /**
   * @generated from protobuf field: int64 fromPage = 1
   */
  fromPage: bigint;
}
/**
 * @generated from protobuf message Authentication.SecurityReportResponse
 */
export interface SecurityReportResponse {
  /**
   * @generated from protobuf field: bytes enterprisePrivateKey = 1
   */
  enterprisePrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: repeated Authentication.SecurityReport securityReport = 2
   */
  securityReport: SecurityReport[];
  /**
   * @generated from protobuf field: int64 asOfRevision = 3
   */
  asOfRevision: bigint;
  /**
   * @generated from protobuf field: int64 fromPage = 4
   */
  fromPage: bigint;
  /**
   * @generated from protobuf field: int64 toPage = 5
   */
  toPage: bigint;
  /**
   * @generated from protobuf field: bool complete = 6
   */
  complete: boolean;
  /**
   * @generated from protobuf field: bytes enterpriseEccPrivateKey = 7
   */
  enterpriseEccPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bool hasIncrementalData = 8
   */
  hasIncrementalData: boolean;
}
/**
 * @generated from protobuf message Authentication.IncrementalSecurityDataRequest
 */
export interface IncrementalSecurityDataRequest {
  /**
   * @generated from protobuf field: bytes continuationToken = 1
   */
  continuationToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.IncrementalSecurityDataResponse
 */
export interface IncrementalSecurityDataResponse {
  /**
   * @generated from protobuf field: repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData = 1
   */
  securityReportIncrementalData: SecurityReportIncrementalData[];
  /**
   * @generated from protobuf field: bytes continuationToken = 2
   */
  continuationToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ReusedPasswordsRequest
 */
export interface ReusedPasswordsRequest {
  /**
   * @generated from protobuf field: int32 count = 1
   */
  count: number;
}
/**
 * @generated from protobuf message Authentication.SummaryConsoleReport
 */
export interface SummaryConsoleReport {
  /**
   * @generated from protobuf field: int32 reportType = 1
   */
  reportType: number;
  /**
   * @generated from protobuf field: bytes reportData = 2
   */
  reportData: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ChangeToKeyTypeOne
 */
export interface ChangeToKeyTypeOne {
  /**
   * @generated from protobuf field: Authentication.ObjectTypes objectType = 1
   */
  objectType: ObjectTypes;
  /**
   * @generated from protobuf field: bytes primaryUid = 2
   */
  primaryUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes secondaryUid = 3
   */
  secondaryUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes key = 4
   */
  key: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ChangeToKeyTypeOneRequest
 */
export interface ChangeToKeyTypeOneRequest {
  /**
   * @generated from protobuf field: repeated Authentication.ChangeToKeyTypeOne changeToKeyTypeOne = 1
   */
  changeToKeyTypeOne: ChangeToKeyTypeOne[];
}
/**
 * @generated from protobuf message Authentication.ChangeToKeyTypeOneStatus
 */
export interface ChangeToKeyTypeOneStatus {
  /**
   * @generated from protobuf field: bytes uid = 1
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: string type = 2
   */
  type: string;
  /**
   * @generated from protobuf field: string status = 3
   */
  status: string;
  /**
   * @generated from protobuf field: string reason = 4
   */
  reason: string;
}
/**
 * @generated from protobuf message Authentication.ChangeToKeyTypeOneResponse
 */
export interface ChangeToKeyTypeOneResponse {
  /**
   * @generated from protobuf field: repeated Authentication.ChangeToKeyTypeOneStatus changeToKeyTypeOneStatus = 1
   */
  changeToKeyTypeOneStatus: ChangeToKeyTypeOneStatus[];
}
/**
 * @generated from protobuf message Authentication.GetChangeKeyTypesRequest
 */
export interface GetChangeKeyTypesRequest {
  /**
   * @generated from protobuf field: repeated Authentication.EncryptedObjectType onlyTheseObjects = 1
   */
  onlyTheseObjects: EncryptedObjectType[];
  /**
   * @generated from protobuf field: int32 limit = 2
   */
  limit: number;
  /**
   * @generated from protobuf field: bool includeRecommended = 3
   */
  includeRecommended: boolean;
  /**
   * @generated from protobuf field: bool includeKeys = 4
   */
  includeKeys: boolean;
  /**
   * @generated from protobuf field: bool includeAllowedKeyTypes = 5
   */
  includeAllowedKeyTypes: boolean;
}
/**
 * @generated from protobuf message Authentication.GetChangeKeyTypesResponse
 */
export interface GetChangeKeyTypesResponse {
  /**
   * @generated from protobuf field: repeated Authentication.ChangeKeyType keys = 1
   */
  keys: ChangeKeyType[];
  /**
   * @generated from protobuf field: repeated Authentication.AllowedKeyTypes allowedKeyTypes = 2
   */
  allowedKeyTypes: AllowedKeyTypes[];
}
/**
 * @generated from protobuf message Authentication.AllowedKeyTypes
 */
export interface AllowedKeyTypes {
  /**
   * @generated from protobuf field: Authentication.EncryptedObjectType objectType = 1
   */
  objectType: EncryptedObjectType;
  /**
   * @generated from protobuf field: repeated Enterprise.EncryptedKeyType allowedKeyTypes = 2
   */
  allowedKeyTypes: EncryptedKeyType[];
}
/**
 * @generated from protobuf message Authentication.ChangeKeyTypes
 */
export interface ChangeKeyTypes {
  /**
   * @generated from protobuf field: repeated Authentication.ChangeKeyType keys = 1
   */
  keys: ChangeKeyType[];
}
/**
 * @generated from protobuf message Authentication.ChangeKeyType
 */
export interface ChangeKeyType {
  /**
   * @generated from protobuf field: Authentication.EncryptedObjectType objectType = 1
   */
  objectType: EncryptedObjectType;
  /**
   * @generated from protobuf field: bytes uid = 2
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: bytes secondaryUid = 3
   */
  secondaryUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes key = 4
   */
  key: Uint8Array;
  /**
   * @generated from protobuf field: Enterprise.EncryptedKeyType keyType = 5
   */
  keyType: EncryptedKeyType;
  /**
   * @generated from protobuf field: Authentication.GenericStatus status = 6
   */
  status: GenericStatus;
}
/**
 * @generated from protobuf message Authentication.SetKey
 */
export interface SetKey {
  /**
   * @generated from protobuf field: int64 id = 1
   */
  id: bigint;
  /**
   * @generated from protobuf field: bytes key = 2
   */
  key: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SetKeyRequest
 */
export interface SetKeyRequest {
  /**
   * @generated from protobuf field: repeated Authentication.SetKey keys = 1
   */
  keys: SetKey[];
}
/**
 * @generated from protobuf message Authentication.CreateUserRequest
 */
export interface CreateUserRequest {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: bytes authVerifier = 2
   */
  authVerifier: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptionParams = 3
   */
  encryptionParams: Uint8Array;
  /**
   * @generated from protobuf field: bytes rsaPublicKey = 4
   */
  rsaPublicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes rsaEncryptedPrivateKey = 5
   */
  rsaEncryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes eccPublicKey = 6
   */
  eccPublicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes eccEncryptedPrivateKey = 7
   */
  eccEncryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 8
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedClientKey = 9
   */
  encryptedClientKey: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 10
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: bytes encryptedDeviceDataKey = 11
   */
  encryptedDeviceDataKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 12
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes messageSessionUid = 13
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: string installReferrer = 14
   */
  installReferrer: string;
  /**
   * @generated from protobuf field: int32 mccMNC = 15
   */
  mccMNC: number;
  /**
   * @generated from protobuf field: string mfg = 16
   */
  mfg: string;
  /**
   * @generated from protobuf field: string model = 17
   */
  model: string;
  /**
   * @generated from protobuf field: string brand = 18
   */
  brand: string;
  /**
   * @generated from protobuf field: string product = 19
   */
  product: string;
  /**
   * @generated from protobuf field: string device = 20
   */
  device: string;
  /**
   * @generated from protobuf field: string carrier = 21
   */
  carrier: string;
  /**
   * @generated from protobuf field: string verificationCode = 22
   */
  verificationCode: string;
  /**
   * @generated from protobuf field: Enterprise.EnterpriseRegistration enterpriseRegistration = 23
   */
  enterpriseRegistration?: EnterpriseRegistration;
  /**
   * @generated from protobuf field: bytes encryptedVerificationToken = 24
   */
  encryptedVerificationToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes enterpriseUsersDataKey = 25
   */
  enterpriseUsersDataKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.NodeEnforcementAddOrUpdateRequest
 */
export interface NodeEnforcementAddOrUpdateRequest {
  /**
   * @generated from protobuf field: int64 nodeId = 1
   */
  nodeId: bigint;
  /**
   * @generated from protobuf field: string enforcement = 2
   */
  enforcement: string;
  /**
   * @generated from protobuf field: string value = 3
   */
  value: string;
}
/**
 * @generated from protobuf message Authentication.NodeEnforcementRemoveRequest
 */
export interface NodeEnforcementRemoveRequest {
  /**
   * @generated from protobuf field: int64 nodeId = 1
   */
  nodeId: bigint;
  /**
   * @generated from protobuf field: string enforcement = 2
   */
  enforcement: string;
}
/**
 * @generated from protobuf message Authentication.ApiRequestByKey
 */
export interface ApiRequestByKey {
  /**
   * @generated from protobuf field: int32 keyId = 1
   */
  keyId: number;
  /**
   * @generated from protobuf field: bytes payload = 2
   */
  payload: Uint8Array;
  /**
   * @generated from protobuf field: string username = 3
   */
  username: string;
  /**
   * @generated from protobuf field: string locale = 4
   */
  locale: string;
  /**
   * @generated from protobuf field: Authentication.SupportedLanguage supportedLanguage = 5
   */
  supportedLanguage: SupportedLanguage;
  /**
   * @generated from protobuf field: int32 type = 6
   */
  type: number;
}
/**
 * @generated from protobuf message Authentication.ApiRequestByKAtoKAKey
 */
export interface ApiRequestByKAtoKAKey {
  /**
   * @generated from protobuf field: Authentication.Region sourceRegion = 1
   */
  sourceRegion: Region;
  /**
   * @generated from protobuf field: bytes payload = 2
   */
  payload: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.SupportedLanguage supportedLanguage = 3
   */
  supportedLanguage: SupportedLanguage;
  /**
   * @generated from protobuf field: Authentication.Region destinationRegion = 4
   */
  destinationRegion: Region;
}
/**
 * @generated from protobuf message Authentication.MemcacheRequest
 */
export interface MemcacheRequest {
  /**
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * @generated from protobuf field: int32 userId = 2
   */
  userId: number;
}
/**
 * @generated from protobuf message Authentication.MemcacheResponse
 */
export interface MemcacheResponse {
  /**
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * @generated from protobuf field: string value = 2
   */
  value: string;
}
/**
 * @generated from protobuf message Authentication.MasterPasswordReentryRequest
 */
export interface MasterPasswordReentryRequest {
  /**
   * @generated from protobuf field: string pbkdf2Password = 1
   */
  pbkdf2Password: string;
  /**
   * @generated from protobuf field: Authentication.MasterPasswordReentryActionType action = 2
   */
  action: MasterPasswordReentryActionType;
}
/**
 * @generated from protobuf message Authentication.MasterPasswordReentryResponse
 */
export interface MasterPasswordReentryResponse {
  /**
   * @generated from protobuf field: Authentication.MasterPasswordReentryStatus status = 1
   */
  status: MasterPasswordReentryStatus;
}
/**
 * @generated from protobuf message Authentication.DeviceRegistrationRequest
 */
export interface DeviceRegistrationRequest {
  /**
   * @generated from protobuf field: string clientVersion = 1
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string deviceName = 2
   */
  deviceName: string;
  /**
   * @generated from protobuf field: bytes devicePublicKey = 3
   */
  devicePublicKey: Uint8Array;
  /**
   * @generated from protobuf field: string devicePlatform = 4
   */
  devicePlatform: string;
  /**
   * @generated from protobuf field: Authentication.ClientFormFactor clientFormFactor = 5
   */
  clientFormFactor: ClientFormFactor;
}
/**
 * @generated from protobuf message Authentication.DeviceVerificationRequest
 */
export interface DeviceVerificationRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string username = 2
   */
  username: string;
  /**
   * @generated from protobuf field: string verificationChannel = 3
   */
  verificationChannel: string;
  /**
   * @generated from protobuf field: bytes messageSessionUid = 4
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 5
   */
  clientVersion: string;
}
/**
 * @generated from protobuf message Authentication.DeviceVerificationResponse
 */
export interface DeviceVerificationResponse {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string username = 2
   */
  username: string;
  /**
   * @generated from protobuf field: bytes messageSessionUid = 3
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: string clientVersion = 4
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: Authentication.DeviceStatus deviceStatus = 5
   */
  deviceStatus: DeviceStatus;
}
/**
 * @generated from protobuf message Authentication.DeviceApprovalRequest
 */
export interface DeviceApprovalRequest {
  /**
   * @generated from protobuf field: string email = 1
   */
  email: string;
  /**
   * @generated from protobuf field: string twoFactorChannel = 2
   */
  twoFactorChannel: string;
  /**
   * @generated from protobuf field: string clientVersion = 3
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string locale = 4
   */
  locale: string;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 5
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: string totpCode = 6
   */
  totpCode: string;
  /**
   * @generated from protobuf field: string deviceIp = 7
   */
  deviceIp: string;
  /**
   * @generated from protobuf field: string deviceTokenExpireDays = 8
   */
  deviceTokenExpireDays: string;
}
/**
 * @generated from protobuf message Authentication.DeviceApprovalResponse
 */
export interface DeviceApprovalResponse {
  /**
   * @generated from protobuf field: bytes encryptedTwoFactorToken = 1
   */
  encryptedTwoFactorToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ApproveDeviceRequest
 */
export interface ApproveDeviceRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDeviceDataKey = 2
   */
  encryptedDeviceDataKey: Uint8Array;
  /**
   * @generated from protobuf field: bool denyApproval = 3
   */
  denyApproval: boolean;
  /**
   * @generated from protobuf field: bool linkDevice = 4
   */
  linkDevice: boolean;
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserAliasRequest
 */
export interface EnterpriseUserAliasRequest {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: string alias = 2
   */
  alias: string;
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserAddAliasRequest
 */
export interface EnterpriseUserAddAliasRequest {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: string alias = 2
   */
  alias: string;
  /**
   * @generated from protobuf field: bool primary = 3
   */
  primary: boolean;
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserAddAliasRequestV2
 */
export interface EnterpriseUserAddAliasRequestV2 {
  /**
   * @generated from protobuf field: repeated Authentication.EnterpriseUserAddAliasRequest enterpriseUserAddAliasRequest = 1
   */
  enterpriseUserAddAliasRequest: EnterpriseUserAddAliasRequest[];
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserAddAliasStatus
 */
export interface EnterpriseUserAddAliasStatus {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: string status = 2
   */
  status: string;
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserAddAliasResponse
 */
export interface EnterpriseUserAddAliasResponse {
  /**
   * @generated from protobuf field: repeated Authentication.EnterpriseUserAddAliasStatus status = 1
   */
  status: EnterpriseUserAddAliasStatus[];
}
/**
 * @generated from protobuf message Authentication.Device
 */
export interface Device {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.RegisterDeviceDataKeyRequest
 */
export interface RegisterDeviceDataKeyRequest {
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 1
   */
  encryptedDeviceToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDeviceDataKey = 2
   */
  encryptedDeviceDataKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.ValidateCreateUserVerificationCodeRequest
 */
export interface ValidateCreateUserVerificationCodeRequest {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string verificationCode = 3
   */
  verificationCode: string;
}
/**
 * @generated from protobuf message Authentication.ValidateDeviceVerificationCodeRequest
 */
export interface ValidateDeviceVerificationCodeRequest {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string verificationCode = 3
   */
  verificationCode: string;
  /**
   * @generated from protobuf field: bytes messageSessionUid = 4
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 5
   */
  encryptedDeviceToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SendSessionMessageRequest
 */
export interface SendSessionMessageRequest {
  /**
   * @generated from protobuf field: bytes messageSessionUid = 1
   */
  messageSessionUid: Uint8Array;
  /**
   * @generated from protobuf field: string command = 2
   */
  command: string;
  /**
   * @generated from protobuf field: string username = 3
   */
  username: string;
}
/**
 * @generated from protobuf message Authentication.GlobalUserAccount
 */
export interface GlobalUserAccount {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: bytes accountUid = 2
   */
  accountUid: Uint8Array;
  /**
   * @generated from protobuf field: string regionName = 3
   */
  regionName: string;
}
/**
 * @generated from protobuf message Authentication.AccountUsername
 */
export interface AccountUsername {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: string dateActive = 2
   */
  dateActive: string;
}
/**
 * @generated from protobuf message Authentication.SsoServiceProviderRequest
 */
export interface SsoServiceProviderRequest {
  /**
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * @generated from protobuf field: string clientVersion = 2
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: string locale = 3
   */
  locale: string;
}
/**
 * @generated from protobuf message Authentication.SsoServiceProviderResponse
 */
export interface SsoServiceProviderResponse {
  /**
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * @generated from protobuf field: string spUrl = 2
   */
  spUrl: string;
  /**
   * @generated from protobuf field: bool isCloud = 3
   */
  isCloud: boolean;
  /**
   * @generated from protobuf field: string clientVersion = 4
   */
  clientVersion: string;
}
/**
 * @generated from protobuf message Authentication.UserSettingRequest
 */
export interface UserSettingRequest {
  /**
   * @generated from protobuf field: string setting = 1
   */
  setting: string;
  /**
   * @generated from protobuf field: string value = 2
   */
  value: string;
}
/**
 * @generated from protobuf message Authentication.ThrottleState
 */
export interface ThrottleState {
  /**
   * @generated from protobuf field: Authentication.ThrottleType type = 1
   */
  type: ThrottleType;
  /**
   * @generated from protobuf field: string key = 2
   */
  key: string;
  /**
   * @generated from protobuf field: string value = 3
   */
  value: string;
  /**
   * @generated from protobuf field: bool state = 4
   */
  state: boolean;
}
/**
 * @generated from protobuf message Authentication.ThrottleState2
 */
export interface ThrottleState2 {
  /**
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * @generated from protobuf field: string keyDescription = 2
   */
  keyDescription: string;
  /**
   * @generated from protobuf field: string value = 3
   */
  value: string;
  /**
   * @generated from protobuf field: string valueDescription = 4
   */
  valueDescription: string;
  /**
   * @generated from protobuf field: string identifier = 5
   */
  identifier: string;
  /**
   * @generated from protobuf field: bool locked = 6
   */
  locked: boolean;
  /**
   * @generated from protobuf field: bool includedInAllClear = 7
   */
  includedInAllClear: boolean;
  /**
   * @generated from protobuf field: int32 expireSeconds = 8
   */
  expireSeconds: number;
}
/**
 * @generated from protobuf message Authentication.DeviceInformation
 */
export interface DeviceInformation {
  /**
   * @generated from protobuf field: int64 deviceId = 1
   */
  deviceId: bigint;
  /**
   * @generated from protobuf field: string deviceName = 2
   */
  deviceName: string;
  /**
   * @generated from protobuf field: string clientVersion = 3
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: int64 lastLogin = 4
   */
  lastLogin: bigint;
  /**
   * @generated from protobuf field: Authentication.DeviceStatus deviceStatus = 5
   */
  deviceStatus: DeviceStatus;
}
/**
 * @generated from protobuf message Authentication.UserSetting
 */
export interface UserSetting {
  /**
   * @generated from protobuf field: string name = 1
   */
  name: string;
  /**
   * @generated from protobuf field: bool value = 2
   */
  value: boolean;
}
/**
 * @generated from protobuf message Authentication.UserDataKeyRequest
 */
export interface UserDataKeyRequest {
  /**
   * @generated from protobuf field: repeated int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint[];
}
/**
 * @generated from protobuf message Authentication.UserDataKeyByNodeRequest
 */
export interface UserDataKeyByNodeRequest {
  /**
   * @generated from protobuf field: repeated int64 nodeIds = 1
   */
  nodeIds: bigint[];
}
/**
 * @generated from protobuf message Authentication.EnterpriseUserIdDataKeyPair
 */
export interface EnterpriseUserIdDataKeyPair {
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 1
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: bytes encryptedDataKey = 2
   */
  encryptedDataKey: Uint8Array;
  /**
   * @generated from protobuf field: Enterprise.EncryptedKeyType keyType = 3
   */
  keyType: EncryptedKeyType;
}
/**
 * @generated from protobuf message Authentication.UserDataKey
 */
export interface UserDataKey {
  /**
   * @generated from protobuf field: int64 roleId = 1
   */
  roleId: bigint;
  /**
   * @generated from protobuf field: bytes roleKey = 2
   */
  roleKey: Uint8Array;
  /**
   * @generated from protobuf field: string privateKey = 3
   */
  privateKey: string;
  /**
   * @generated from protobuf field: repeated Authentication.EnterpriseUserIdDataKeyPair enterpriseUserIdDataKeyPairs = 4
   */
  enterpriseUserIdDataKeyPairs: EnterpriseUserIdDataKeyPair[];
}
/**
 * @generated from protobuf message Authentication.UserDataKeyResponse
 */
export interface UserDataKeyResponse {
  /**
   * @generated from protobuf field: repeated Authentication.UserDataKey userDataKeys = 1
   */
  userDataKeys: UserDataKey[];
  /**
   * @generated from protobuf field: repeated int64 accessDenied = 2
   */
  accessDenied: bigint[];
  /**
   * @generated from protobuf field: repeated int64 noEncryptedDataKey = 3
   */
  noEncryptedDataKey: bigint[];
}
/**
 * @generated from protobuf message Authentication.MasterPasswordRecoveryVerificationRequest
 */
export interface MasterPasswordRecoveryVerificationRequest {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.GetSecurityQuestionV3Request
 */
export interface GetSecurityQuestionV3Request {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: string verificationCode = 2
   */
  verificationCode: string;
}
/**
 * @generated from protobuf message Authentication.GetSecurityQuestionV3Response
 */
export interface GetSecurityQuestionV3Response {
  /**
   * @generated from protobuf field: string securityQuestion = 1
   */
  securityQuestion: string;
  /**
   * @generated from protobuf field: int64 backupKeyDate = 2
   */
  backupKeyDate: bigint;
  /**
   * @generated from protobuf field: bytes salt = 3
   */
  salt: Uint8Array;
  /**
   * @generated from protobuf field: int32 iterations = 4
   */
  iterations: number;
}
/**
 * @generated from protobuf message Authentication.GetDataKeyBackupV3Request
 */
export interface GetDataKeyBackupV3Request {
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 1
   */
  encryptedLoginToken: Uint8Array;
  /**
   * @generated from protobuf field: string verificationCode = 2
   */
  verificationCode: string;
  /**
   * @generated from protobuf field: bytes securityAnswerHash = 3
   */
  securityAnswerHash: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.PasswordRules
 */
export interface PasswordRules {
  /**
   * @generated from protobuf field: string ruleType = 1
   */
  ruleType: string;
  /**
   * @generated from protobuf field: bool match = 2
   */
  match: boolean;
  /**
   * @generated from protobuf field: string pattern = 3
   */
  pattern: string;
  /**
   * @generated from protobuf field: string description = 4
   */
  description: string;
  /**
   * @generated from protobuf field: int32 minimum = 5
   */
  minimum: number;
  /**
   * @generated from protobuf field: string value = 6
   */
  value: string;
}
/**
 * @generated from protobuf message Authentication.GetDataKeyBackupV3Response
 */
export interface GetDataKeyBackupV3Response {
  /**
   * @generated from protobuf field: bytes dataKeyBackup = 1
   */
  dataKeyBackup: Uint8Array;
  /**
   * @generated from protobuf field: int64 dataKeyBackupDate = 2
   */
  dataKeyBackupDate: bigint;
  /**
   * @generated from protobuf field: bytes publicKey = 3
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedPrivateKey = 4
   */
  encryptedPrivateKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes clientKey = 5
   */
  clientKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedSessionToken = 6
   */
  encryptedSessionToken: Uint8Array;
  /**
   * @generated from protobuf field: repeated Authentication.PasswordRules passwordRules = 7
   */
  passwordRules: PasswordRules[];
  /**
   * @generated from protobuf field: string passwordRulesIntro = 8
   */
  passwordRulesIntro: string;
  /**
   * @generated from protobuf field: int32 minimumPbkdf2Iterations = 9
   */
  minimumPbkdf2Iterations: number;
  /**
   * @generated from protobuf field: Enterprise.KeyType keyType = 10
   */
  keyType: KeyType;
}
/**
 * @generated from protobuf message Authentication.GetPublicKeysRequest
 */
export interface GetPublicKeysRequest {
  /**
   * @generated from protobuf field: repeated string usernames = 1
   */
  usernames: string[];
}
/**
 * @generated from protobuf message Authentication.PublicKeyResponse
 */
export interface PublicKeyResponse {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
  /**
   * @generated from protobuf field: bytes publicKey = 2
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes publicEccKey = 3
   */
  publicEccKey: Uint8Array;
  /**
   * @generated from protobuf field: string message = 4
   */
  message: string;
  /**
   * @generated from protobuf field: string errorCode = 5
   */
  errorCode: string;
}
/**
 * @generated from protobuf message Authentication.GetPublicKeysResponse
 */
export interface GetPublicKeysResponse {
  /**
   * @generated from protobuf field: repeated Authentication.PublicKeyResponse keyResponses = 1
   */
  keyResponses: PublicKeyResponse[];
}
/**
 * @generated from protobuf message Authentication.SetEccKeyPairRequest
 */
export interface SetEccKeyPairRequest {
  /**
   * @generated from protobuf field: bytes publicKey = 1
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedPrivateKey = 2
   */
  encryptedPrivateKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SetEccKeyPairsRequest
 */
export interface SetEccKeyPairsRequest {
  /**
   * @generated from protobuf field: repeated Authentication.TeamEccKeyPair teamKeys = 1
   */
  teamKeys: TeamEccKeyPair[];
}
/**
 * @generated from protobuf message Authentication.SetEccKeyPairsResponse
 */
export interface SetEccKeyPairsResponse {
  /**
   * @generated from protobuf field: repeated Authentication.TeamEccKeyPairResponse teamKeys = 1
   */
  teamKeys: TeamEccKeyPairResponse[];
}
/**
 * @generated from protobuf message Authentication.TeamEccKeyPair
 */
export interface TeamEccKeyPair {
  /**
   * @generated from protobuf field: bytes teamUid = 1
   */
  teamUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes publicKey = 2
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedPrivateKey = 3
   */
  encryptedPrivateKey: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.TeamEccKeyPairResponse
 */
export interface TeamEccKeyPairResponse {
  /**
   * @generated from protobuf field: bytes teamUid = 1
   */
  teamUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.GenericStatus status = 2
   */
  status: GenericStatus;
}
/**
 * @generated from protobuf message Authentication.GetKsmPublicKeysRequest
 */
export interface GetKsmPublicKeysRequest {
  /**
   * @generated from protobuf field: repeated bytes clientIds = 1
   */
  clientIds: Uint8Array[];
  /**
   * @generated from protobuf field: repeated bytes controllerUids = 2
   */
  controllerUids: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.DevicePublicKeyResponse
 */
export interface DevicePublicKeyResponse {
  /**
   * @generated from protobuf field: bytes clientId = 1
   */
  clientId: Uint8Array;
  /**
   * @generated from protobuf field: bytes publicKey = 2
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes controllerUid = 3
   */
  controllerUid: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.GetKsmPublicKeysResponse
 */
export interface GetKsmPublicKeysResponse {
  /**
   * @generated from protobuf field: repeated Authentication.DevicePublicKeyResponse keyResponses = 1
   */
  keyResponses: DevicePublicKeyResponse[];
}
/**
 * @generated from protobuf message Authentication.AddAppSharesRequest
 */
export interface AddAppSharesRequest {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: repeated Authentication.AppShareAdd shares = 2
   */
  shares: AppShareAdd[];
}
/**
 * @generated from protobuf message Authentication.RemoveAppSharesRequest
 */
export interface RemoveAppSharesRequest {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: repeated bytes shares = 2
   */
  shares: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.AppShareAdd
 */
export interface AppShareAdd {
  /**
   * @generated from protobuf field: bytes secretUid = 2
   */
  secretUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.ApplicationShareType shareType = 3
   */
  shareType: ApplicationShareType;
  /**
   * @generated from protobuf field: bytes encryptedSecretKey = 4
   */
  encryptedSecretKey: Uint8Array;
  /**
   * @generated from protobuf field: bool editable = 5
   */
  editable: boolean;
}
/**
 * @generated from protobuf message Authentication.AppShare
 */
export interface AppShare {
  /**
   * @generated from protobuf field: bytes secretUid = 1
   */
  secretUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.ApplicationShareType shareType = 2
   */
  shareType: ApplicationShareType;
  /**
   * @generated from protobuf field: bool editable = 3
   */
  editable: boolean;
  /**
   * @generated from protobuf field: int64 createdOn = 4
   */
  createdOn: bigint;
  /**
   * @generated from protobuf field: bytes data = 5
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.AddAppClientRequest
 */
export interface AddAppClientRequest {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedAppKey = 2
   */
  encryptedAppKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes clientId = 3
   */
  clientId: Uint8Array;
  /**
   * @generated from protobuf field: bool lockIp = 4
   */
  lockIp: boolean;
  /**
   * @generated from protobuf field: int64 firstAccessExpireOn = 5
   */
  firstAccessExpireOn: bigint;
  /**
   * @generated from protobuf field: int64 accessExpireOn = 6
   */
  accessExpireOn: bigint;
  /**
   * @generated from protobuf field: string id = 7
   */
  id: string;
  /**
   * @generated from protobuf field: Enterprise.AppClientType appClientType = 8
   */
  appClientType: AppClientType;
}
/**
 * @generated from protobuf message Authentication.RemoveAppClientsRequest
 */
export interface RemoveAppClientsRequest {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: repeated bytes clients = 2
   */
  clients: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.AddExternalShareRequest
 */
export interface AddExternalShareRequest {
  /**
   * @generated from protobuf field: bytes recordUid = 1
   */
  recordUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedRecordKey = 2
   */
  encryptedRecordKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes clientId = 3
   */
  clientId: Uint8Array;
  /**
   * @generated from protobuf field: int64 accessExpireOn = 4
   */
  accessExpireOn: bigint;
  /**
   * @generated from protobuf field: string id = 5
   */
  id: string;
  /**
   * @generated from protobuf field: bool isSelfDestruct = 6
   */
  isSelfDestruct: boolean;
  /**
   * @generated from protobuf field: bool isEditable = 7
   */
  isEditable: boolean;
}
/**
 * @generated from protobuf message Authentication.AppClient
 */
export interface AppClient {
  /**
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * @generated from protobuf field: bytes clientId = 2
   */
  clientId: Uint8Array;
  /**
   * @generated from protobuf field: int64 createdOn = 3
   */
  createdOn: bigint;
  /**
   * @generated from protobuf field: int64 firstAccess = 4
   */
  firstAccess: bigint;
  /**
   * @generated from protobuf field: int64 lastAccess = 5
   */
  lastAccess: bigint;
  /**
   * @generated from protobuf field: bytes publicKey = 6
   */
  publicKey: Uint8Array;
  /**
   * @generated from protobuf field: bool lockIp = 7
   */
  lockIp: boolean;
  /**
   * @generated from protobuf field: string ipAddress = 8
   */
  ipAddress: string;
  /**
   * @generated from protobuf field: int64 firstAccessExpireOn = 9
   */
  firstAccessExpireOn: bigint;
  /**
   * @generated from protobuf field: int64 accessExpireOn = 10
   */
  accessExpireOn: bigint;
  /**
   * @generated from protobuf field: Enterprise.AppClientType appClientType = 11
   */
  appClientType: AppClientType;
  /**
   * @generated from protobuf field: bool canEdit = 12
   */
  canEdit: boolean;
}
/**
 * @generated from protobuf message Authentication.GetAppInfoRequest
 */
export interface GetAppInfoRequest {
  /**
   * @generated from protobuf field: repeated bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.AppInfo
 */
export interface AppInfo {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: repeated Authentication.AppShare shares = 2
   */
  shares: AppShare[];
  /**
   * @generated from protobuf field: repeated Authentication.AppClient clients = 3
   */
  clients: AppClient[];
  /**
   * @generated from protobuf field: bool isExternalShare = 4
   */
  isExternalShare: boolean;
}
/**
 * @generated from protobuf message Authentication.GetAppInfoResponse
 */
export interface GetAppInfoResponse {
  /**
   * @generated from protobuf field: repeated Authentication.AppInfo appInfo = 1
   */
  appInfo: AppInfo[];
}
/**
 * @generated from protobuf message Authentication.ApplicationSummary
 */
export interface ApplicationSummary {
  /**
   * @generated from protobuf field: bytes appRecordUid = 1
   */
  appRecordUid: Uint8Array;
  /**
   * @generated from protobuf field: int64 lastAccess = 2
   */
  lastAccess: bigint;
  /**
   * @generated from protobuf field: int32 recordShares = 3
   */
  recordShares: number;
  /**
   * @generated from protobuf field: int32 folderShares = 4
   */
  folderShares: number;
  /**
   * @generated from protobuf field: int32 folderRecords = 5
   */
  folderRecords: number;
  /**
   * @generated from protobuf field: int32 clientCount = 6
   */
  clientCount: number;
  /**
   * @generated from protobuf field: int32 expiredClientCount = 7
   */
  expiredClientCount: number;
  /**
   * @generated from protobuf field: string username = 8
   */
  username: string;
  /**
   * @generated from protobuf field: bytes appData = 9
   */
  appData: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.GetApplicationsSummaryResponse
 */
export interface GetApplicationsSummaryResponse {
  /**
   * @generated from protobuf field: repeated Authentication.ApplicationSummary applicationSummary = 1
   */
  applicationSummary: ApplicationSummary[];
}
/**
 * @generated from protobuf message Authentication.GetVerificationTokenRequest
 */
export interface GetVerificationTokenRequest {
  /**
   * @generated from protobuf field: string username = 1
   */
  username: string;
}
/**
 * @generated from protobuf message Authentication.GetVerificationTokenResponse
 */
export interface GetVerificationTokenResponse {
  /**
   * @generated from protobuf field: bytes encryptedVerificationToken = 1
   */
  encryptedVerificationToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.SendShareInviteRequest
 */
export interface SendShareInviteRequest {
  /**
   * @generated from protobuf field: string email = 1
   */
  email: string;
}
/**
 * @generated from protobuf message Authentication.TimeLimitedAccessRequest
 */
export interface TimeLimitedAccessRequest {
  /**
   * @generated from protobuf field: repeated bytes accountUid = 1
   */
  accountUid: Uint8Array[];
  /**
   * @generated from protobuf field: repeated bytes teamUid = 2
   */
  teamUid: Uint8Array[];
  /**
   * @generated from protobuf field: repeated bytes recordUid = 3
   */
  recordUid: Uint8Array[];
  /**
   * @generated from protobuf field: bytes sharedObjectUid = 4
   */
  sharedObjectUid: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.TimeLimitedAccessType timeLimitedAccessType = 5
   */
  timeLimitedAccessType: TimeLimitedAccessType;
  /**
   * @generated from protobuf field: int64 expiration = 6
   */
  expiration: bigint;
}
/**
 * @generated from protobuf message Authentication.TimeLimitedAccessStatus
 */
export interface TimeLimitedAccessStatus {
  /**
   * @generated from protobuf field: bytes uid = 1
   */
  uid: Uint8Array;
  /**
   * @generated from protobuf field: string message = 2
   */
  message: string;
}
/**
 * @generated from protobuf message Authentication.TimeLimitedAccessResponse
 */
export interface TimeLimitedAccessResponse {
  /**
   * @generated from protobuf field: int64 revision = 1
   */
  revision: bigint;
  /**
   * @generated from protobuf field: repeated Authentication.TimeLimitedAccessStatus userAccessStatus = 2
   */
  userAccessStatus: TimeLimitedAccessStatus[];
  /**
   * @generated from protobuf field: repeated Authentication.TimeLimitedAccessStatus teamAccessStatus = 3
   */
  teamAccessStatus: TimeLimitedAccessStatus[];
  /**
   * @generated from protobuf field: repeated Authentication.TimeLimitedAccessStatus recordAccessStatus = 4
   */
  recordAccessStatus: TimeLimitedAccessStatus[];
}
/**
 * @generated from protobuf message Authentication.RequestDownloadRequest
 */
export interface RequestDownloadRequest {
  /**
   * @generated from protobuf field: repeated string fileNames = 1
   */
  fileNames: string[];
}
/**
 * @generated from protobuf message Authentication.RequestDownloadResponse
 */
export interface RequestDownloadResponse {
  /**
   * @generated from protobuf field: string result = 1
   */
  result: string;
  /**
   * @generated from protobuf field: string message = 2
   */
  message: string;
  /**
   * @generated from protobuf field: repeated Authentication.Download downloads = 3
   */
  downloads: Download[];
}
/**
 * @generated from protobuf message Authentication.Download
 */
export interface Download {
  /**
   * @generated from protobuf field: string fileName = 1
   */
  fileName: string;
  /**
   * @generated from protobuf field: string url = 2
   */
  url: string;
  /**
   * @generated from protobuf field: int32 successStatusCode = 3
   */
  successStatusCode: number;
}
/**
 * @generated from protobuf message Authentication.DeleteUserRequest
 */
export interface DeleteUserRequest {
  /**
   * @generated from protobuf field: string reason = 1
   */
  reason: string;
}
/**
 * @generated from protobuf message Authentication.ChangeMasterPasswordRequest
 */
export interface ChangeMasterPasswordRequest {
  /**
   * @generated from protobuf field: bytes authVerifier = 1
   */
  authVerifier: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptionParams = 2
   */
  encryptionParams: Uint8Array;
  /**
   * @generated from protobuf field: bool fromServiceProvider = 3
   */
  fromServiceProvider: boolean;
  /**
   * @generated from protobuf field: bool iterationsChange = 4
   */
  iterationsChange: boolean;
}
/**
 * @generated from protobuf message Authentication.ChangeMasterPasswordResponse
 */
export interface ChangeMasterPasswordResponse {
  /**
   * @generated from protobuf field: bytes encryptedSessionToken = 1
   */
  encryptedSessionToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.AccountRecoverySetupRequest
 */
export interface AccountRecoverySetupRequest {
  /**
   * @generated from protobuf field: bytes recoveryEncryptedDataKey = 1
   */
  recoveryEncryptedDataKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes recoveryAuthHash = 2
   */
  recoveryAuthHash: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.AccountRecoveryVerifyCodeResponse
 */
export interface AccountRecoveryVerifyCodeResponse {
  /**
   * @generated from protobuf field: Authentication.BackupKeyType backupKeyType = 1
   */
  backupKeyType: BackupKeyType;
  /**
   * @generated from protobuf field: int64 backupKeyDate = 2
   */
  backupKeyDate: bigint;
  /**
   * @generated from protobuf field: string securityQuestion = 3
   */
  securityQuestion: string;
  /**
   * @generated from protobuf field: bytes salt = 4
   */
  salt: Uint8Array;
  /**
   * @generated from protobuf field: int32 iterations = 5
   */
  iterations: number;
}
/**
 * @generated from protobuf message Authentication.EmergencyAccessLoginRequest
 */
export interface EmergencyAccessLoginRequest {
  /**
   * @generated from protobuf field: string owner = 1
   */
  owner: string;
}
/**
 * @generated from protobuf message Authentication.EmergencyAccessLoginResponse
 */
export interface EmergencyAccessLoginResponse {
  /**
   * @generated from protobuf field: bytes sessionToken = 1
   */
  sessionToken: Uint8Array;
  /**
   * @generated from protobuf field: Enterprise.TypedKey dataKey = 2
   */
  dataKey?: TypedKey;
  /**
   * @generated from protobuf field: Enterprise.TypedKey rsaPrivateKey = 3
   */
  rsaPrivateKey?: TypedKey;
  /**
   * @generated from protobuf field: Enterprise.TypedKey eccPrivateKey = 4
   */
  eccPrivateKey?: TypedKey;
}
/**
 * @generated from protobuf message Authentication.UserTeamKey
 */
export interface UserTeamKey {
  /**
   * @generated from protobuf field: bytes teamUid = 1
   */
  teamUid: Uint8Array;
  /**
   * @generated from protobuf field: string username = 2
   */
  username: string;
  /**
   * @generated from protobuf field: int64 enterpriseUserId = 3
   */
  enterpriseUserId: bigint;
  /**
   * @generated from protobuf field: bytes encryptedTeamKeyRSA = 4
   */
  encryptedTeamKeyRSA: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedTeamKeyEC = 5
   */
  encryptedTeamKeyEC: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.GenericStatus status = 6
   */
  status: GenericStatus;
}
/**
 * @generated from protobuf message Authentication.GenericRequestResponse
 */
export interface GenericRequestResponse {
  /**
   * @generated from protobuf field: repeated bytes request = 1
   */
  request: Uint8Array[];
}
/**
 * @generated from protobuf message Authentication.PasskeyRegistrationRequest
 */
export interface PasskeyRegistrationRequest {
  /**
   * @generated from protobuf field: Authentication.AuthenticatorAttachment authenticatorAttachment = 1
   */
  authenticatorAttachment: AuthenticatorAttachment;
}
/**
 * @generated from protobuf message Authentication.PasskeyRegistrationResponse
 */
export interface PasskeyRegistrationResponse {
  /**
   * @generated from protobuf field: bytes challengeToken = 1
   */
  challengeToken: Uint8Array;
  /**
   * @generated from protobuf field: string pkCreationOptions = 2
   */
  pkCreationOptions: string;
}
/**
 * @generated from protobuf message Authentication.PasskeyRegistrationFinalization
 */
export interface PasskeyRegistrationFinalization {
  /**
   * @generated from protobuf oneof: _friendlyName
   */
  FriendlyName:
    | {
        oneofKind: "friendlyName";
        /**
         * @generated from protobuf field: string friendlyName = 3
         */
        friendlyName: string;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: bytes challengeToken = 1
   */
  challengeToken: Uint8Array;
  /**
   * @generated from protobuf field: string authenticatorResponse = 2
   */
  authenticatorResponse: string;
}
/**
 * @generated from protobuf message Authentication.PasskeyAuthenticationRequest
 */
export interface PasskeyAuthenticationRequest {
  /**
   * @generated from protobuf oneof: _username
   */
  Username:
    | {
        oneofKind: "username";
        /**
         * @generated from protobuf field: string username = 5
         */
        username: string;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf oneof: _encryptedLoginToken
   */
  EncryptedLoginToken:
    | {
        oneofKind: "encryptedLoginToken";
        /**
         * @generated from protobuf field: bytes encryptedLoginToken = 6
         */
        encryptedLoginToken: Uint8Array;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: Authentication.AuthenticatorAttachment authenticatorAttachment = 1
   */
  authenticatorAttachment: AuthenticatorAttachment;
  /**
   * @generated from protobuf field: Authentication.PasskeyPurpose passkeyPurpose = 2
   */
  passkeyPurpose: PasskeyPurpose;
  /**
   * @generated from protobuf field: string clientVersion = 3
   */
  clientVersion: string;
  /**
   * @generated from protobuf field: bytes encryptedDeviceToken = 4
   */
  encryptedDeviceToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.PasskeyAuthenticationResponse
 */
export interface PasskeyAuthenticationResponse {
  /**
   * @generated from protobuf oneof: _encryptedLoginToken
   */
  EncryptedLoginToken:
    | {
        oneofKind: "encryptedLoginToken";
        /**
         * @generated from protobuf field: bytes encryptedLoginToken = 3
         */
        encryptedLoginToken: Uint8Array;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: string pkRequestOptions = 1
   */
  pkRequestOptions: string;
  /**
   * @generated from protobuf field: bytes challengeToken = 2
   */
  challengeToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.PasskeyValidationRequest
 */
export interface PasskeyValidationRequest {
  /**
   * @generated from protobuf oneof: _encryptedLoginToken
   */
  EncryptedLoginToken:
    | {
        oneofKind: "encryptedLoginToken";
        /**
         * @generated from protobuf field: bytes encryptedLoginToken = 4
         */
        encryptedLoginToken: Uint8Array;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: bytes challengeToken = 1
   */
  challengeToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes assertionResponse = 2
   */
  assertionResponse: Uint8Array;
  /**
   * @generated from protobuf field: Authentication.PasskeyPurpose passkeyPurpose = 3
   */
  passkeyPurpose: PasskeyPurpose;
}
/**
 * @generated from protobuf message Authentication.PasskeyValidationResponse
 */
export interface PasskeyValidationResponse {
  /**
   * @generated from protobuf field: bool isValid = 1
   */
  isValid: boolean;
  /**
   * @generated from protobuf field: bytes encryptedLoginToken = 2
   */
  encryptedLoginToken: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.UpdatePasskeyRequest
 */
export interface UpdatePasskeyRequest {
  /**
   * @generated from protobuf oneof: _friendlyName
   */
  FriendlyName:
    | {
        oneofKind: "friendlyName";
        /**
         * @generated from protobuf field: string friendlyName = 3
         */
        friendlyName: string;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: int32 userId = 1
   */
  userId: number;
  /**
   * @generated from protobuf field: bytes credentialId = 2
   */
  credentialId: Uint8Array;
}
/**
 * @generated from protobuf message Authentication.PasskeyListRequest
 */
export interface PasskeyListRequest {
  /**
   * @generated from protobuf field: bool includeDisabled = 1
   */
  includeDisabled: boolean;
}
/**
 * @generated from protobuf message Authentication.PasskeyInfo
 */
export interface PasskeyInfo {
  /**
   * @generated from protobuf field: int32 userId = 1
   */
  userId: number;
  /**
   * @generated from protobuf field: bytes credentialId = 2
   */
  credentialId: Uint8Array;
  /**
   * @generated from protobuf field: string friendlyName = 3
   */
  friendlyName: string;
  /**
   * @generated from protobuf field: string AAGUID = 4
   */
  aAGUID: string;
  /**
   * @generated from protobuf field: int64 createdAtMillis = 5
   */
  createdAtMillis: bigint;
  /**
   * @generated from protobuf field: int64 lastUsedMillis = 6
   */
  lastUsedMillis: bigint;
  /**
   * @generated from protobuf field: int64 disabledAtMillis = 7
   */
  disabledAtMillis: bigint;
}
/**
 * @generated from protobuf message Authentication.PasskeyListResponse
 */
export interface PasskeyListResponse {
  /**
   * @generated from protobuf field: repeated Authentication.PasskeyInfo passkeyInfo = 1
   */
  passkeyInfo: PasskeyInfo[];
}
/**
 * @generated from protobuf message Authentication.TranslationInfo
 */
export interface TranslationInfo {
  /**
   * @generated from protobuf field: string translationKey = 1
   */
  translationKey: string;
  /**
   * @generated from protobuf field: string translationValue = 2
   */
  translationValue: string;
}
/**
 * @generated from protobuf message Authentication.TranslationRequest
 */
export interface TranslationRequest {
  /**
   * @generated from protobuf field: repeated string translationKey = 1
   */
  translationKey: string[];
}
/**
 * @generated from protobuf message Authentication.TranslationResponse
 */
export interface TranslationResponse {
  /**
   * @generated from protobuf field: repeated Authentication.TranslationInfo translationInfo = 1
   */
  translationInfo: TranslationInfo[];
}
/**
 * @generated from protobuf enum Authentication.SupportedLanguage
 */
export enum SupportedLanguage {
  /**
   * @generated from protobuf enum value: ENGLISH = 0;
   */
  ENGLISH = 0,
  /**
   * @generated from protobuf enum value: ARABIC = 1;
   */
  ARABIC = 1,
  /**
   * @generated from protobuf enum value: BRITISH = 2;
   */
  BRITISH = 2,
  /**
   * @generated from protobuf enum value: CHINESE = 3;
   */
  CHINESE = 3,
  /**
   * @generated from protobuf enum value: CHINESE_HONG_KONG = 4;
   */
  CHINESE_HONG_KONG = 4,
  /**
   * @generated from protobuf enum value: CHINESE_TAIWAN = 5;
   */
  CHINESE_TAIWAN = 5,
  /**
   * @generated from protobuf enum value: DUTCH = 6;
   */
  DUTCH = 6,
  /**
   * @generated from protobuf enum value: FRENCH = 7;
   */
  FRENCH = 7,
  /**
   * @generated from protobuf enum value: GERMAN = 8;
   */
  GERMAN = 8,
  /**
   * @generated from protobuf enum value: GREEK = 9;
   */
  GREEK = 9,
  /**
   * @generated from protobuf enum value: HEBREW = 10;
   */
  HEBREW = 10,
  /**
   * @generated from protobuf enum value: ITALIAN = 11;
   */
  ITALIAN = 11,
  /**
   * @generated from protobuf enum value: JAPANESE = 12;
   */
  JAPANESE = 12,
  /**
   * @generated from protobuf enum value: KOREAN = 13;
   */
  KOREAN = 13,
  /**
   * @generated from protobuf enum value: POLISH = 14;
   */
  POLISH = 14,
  /**
   * @generated from protobuf enum value: PORTUGUESE = 15;
   */
  PORTUGUESE = 15,
  /**
   * @generated from protobuf enum value: PORTUGUESE_BRAZIL = 16;
   */
  PORTUGUESE_BRAZIL = 16,
  /**
   * @generated from protobuf enum value: ROMANIAN = 17;
   */
  ROMANIAN = 17,
  /**
   * @generated from protobuf enum value: RUSSIAN = 18;
   */
  RUSSIAN = 18,
  /**
   * @generated from protobuf enum value: SLOVAK = 19;
   */
  SLOVAK = 19,
  /**
   * @generated from protobuf enum value: SPANISH = 20;
   */
  SPANISH = 20,
  /**
   * @generated from protobuf enum value: FINNISH = 21;
   */
  FINNISH = 21,
  /**
   * @generated from protobuf enum value: SWEDISH = 22;
   */
  SWEDISH = 22,
}
/**
 * @generated from protobuf enum Authentication.LoginType
 */
export enum LoginType {
  /**
   * @generated from protobuf enum value: NORMAL = 0;
   */
  NORMAL = 0,
  /**
   * @generated from protobuf enum value: SSO = 1;
   */
  SSO = 1,
  /**
   * @generated from protobuf enum value: BIO = 2;
   */
  BIO = 2,
  /**
   * @generated from protobuf enum value: ALTERNATE = 3;
   */
  ALTERNATE = 3,
  /**
   * @generated from protobuf enum value: OFFLINE = 4;
   */
  OFFLINE = 4,
  /**
   * @generated from protobuf enum value: FORGOT_PASSWORD = 5;
   */
  FORGOT_PASSWORD = 5,
  /**
   * @generated from protobuf enum value: PASSKEY_BIO = 6;
   */
  PASSKEY_BIO = 6,
}
/**
 * @generated from protobuf enum Authentication.DeviceStatus
 */
export enum DeviceStatus {
  /**
   * @generated from protobuf enum value: DEVICE_NEEDS_APPROVAL = 0;
   */
  DEVICE_NEEDS_APPROVAL = 0,
  /**
   * @generated from protobuf enum value: DEVICE_OK = 1;
   */
  DEVICE_OK = 1,
  /**
   * @generated from protobuf enum value: DEVICE_DISABLED_BY_USER = 2;
   */
  DEVICE_DISABLED_BY_USER = 2,
  /**
   * @generated from protobuf enum value: DEVICE_LOCKED_BY_ADMIN = 3;
   */
  DEVICE_LOCKED_BY_ADMIN = 3,
}
/**
 * @generated from protobuf enum Authentication.LicenseStatus
 */
export enum LicenseStatus {
  /**
   * @generated from protobuf enum value: OTHER = 0;
   */
  OTHER = 0,
  /**
   * @generated from protobuf enum value: ACTIVE = 1;
   */
  ACTIVE = 1,
  /**
   * @generated from protobuf enum value: EXPIRED = 2;
   */
  EXPIRED = 2,
  /**
   * @generated from protobuf enum value: DISABLED = 3;
   */
  DISABLED = 3,
}
/**
 * @generated from protobuf enum Authentication.AccountType
 */
export enum AccountType {
  /**
   * @generated from protobuf enum value: CONSUMER = 0;
   */
  CONSUMER = 0,
  /**
   * @generated from protobuf enum value: FAMILY = 1;
   */
  FAMILY = 1,
  /**
   * @generated from protobuf enum value: ENTERPRISE = 2;
   */
  ENTERPRISE = 2,
}
/**
 * @generated from protobuf enum Authentication.SessionTokenType
 */
export enum SessionTokenType {
  /**
   * @generated from protobuf enum value: NO_RESTRICTION = 0;
   */
  NO_RESTRICTION = 0,
  /**
   * @generated from protobuf enum value: ACCOUNT_RECOVERY = 1;
   */
  ACCOUNT_RECOVERY = 1,
  /**
   * @generated from protobuf enum value: SHARE_ACCOUNT = 2;
   */
  SHARE_ACCOUNT = 2,
  /**
   * @generated from protobuf enum value: PURCHASE = 3;
   */
  PURCHASE = 3,
  /**
   * @generated from protobuf enum value: RESTRICT = 4;
   */
  RESTRICT = 4,
  /**
   * @generated from protobuf enum value: ACCEPT_INVITE = 5;
   */
  ACCEPT_INVITE = 5,
  /**
   * @generated from protobuf enum value: SUPPORT_SERVER = 6;
   */
  SUPPORT_SERVER = 6,
  /**
   * @generated from protobuf enum value: ENTERPRISE_CREATION = 7;
   */
  ENTERPRISE_CREATION = 7,
  /**
   * @generated from protobuf enum value: EXPIRED_BUT_ALLOWED_TO_SYNC = 8;
   */
  EXPIRED_BUT_ALLOWED_TO_SYNC = 8,
  /**
   * @generated from protobuf enum value: ACCEPT_FAMILY_INVITE = 9;
   */
  ACCEPT_FAMILY_INVITE = 9,
  /**
   * @generated from protobuf enum value: ENTERPRISE_CREATION_PURCHASED = 10;
   */
  ENTERPRISE_CREATION_PURCHASED = 10,
  /**
   * @generated from protobuf enum value: EMERGENCY_ACCESS = 11;
   */
  EMERGENCY_ACCESS = 11,
}
/**
 * @generated from protobuf enum Authentication.Version
 */
export enum Version {
  /**
   * @generated from protobuf enum value: invalid_version = 0;
   */
  invalid_version = 0,
  /**
   * @generated from protobuf enum value: default_version = 1;
   */
  default_version = 1,
  /**
   * @generated from protobuf enum value: second_version = 2;
   */
  second_version = 2,
}
/**
 * @generated from protobuf enum Authentication.MasterPasswordReentryActionType
 */
export enum MasterPasswordReentryActionType {
  /**
   * @generated from protobuf enum value: UNMASK = 0;
   */
  UNMASK = 0,
  /**
   * @generated from protobuf enum value: COPY = 1;
   */
  COPY = 1,
}
/**
 * @generated from protobuf enum Authentication.LoginMethod
 */
export enum LoginMethod {
  /**
   * @generated from protobuf enum value: INVALID_LOGINMETHOD = 0;
   */
  INVALID_LOGINMETHOD = 0,
  /**
   * @generated from protobuf enum value: EXISTING_ACCOUNT = 1;
   */
  EXISTING_ACCOUNT = 1,
  /**
   * @generated from protobuf enum value: SSO_DOMAIN = 2;
   */
  SSO_DOMAIN = 2,
  /**
   * @generated from protobuf enum value: AFTER_SSO = 3;
   */
  AFTER_SSO = 3,
  /**
   * @generated from protobuf enum value: NEW_ACCOUNT = 4;
   */
  NEW_ACCOUNT = 4,
}
/**
 * @generated from protobuf enum Authentication.LoginState
 */
export enum LoginState {
  /**
   * @generated from protobuf enum value: INVALID_LOGINSTATE = 0;
   */
  INVALID_LOGINSTATE = 0,
  /**
   * @generated from protobuf enum value: LOGGED_OUT = 1;
   */
  LOGGED_OUT = 1,
  /**
   * @generated from protobuf enum value: DEVICE_APPROVAL_REQUIRED = 2;
   */
  DEVICE_APPROVAL_REQUIRED = 2,
  /**
   * @generated from protobuf enum value: DEVICE_LOCKED = 3;
   */
  DEVICE_LOCKED = 3,
  /**
   * @generated from protobuf enum value: ACCOUNT_LOCKED = 4;
   */
  ACCOUNT_LOCKED = 4,
  /**
   * @generated from protobuf enum value: DEVICE_ACCOUNT_LOCKED = 5;
   */
  DEVICE_ACCOUNT_LOCKED = 5,
  /**
   * @generated from protobuf enum value: UPGRADE = 6;
   */
  UPGRADE = 6,
  /**
   * @generated from protobuf enum value: LICENSE_EXPIRED = 7;
   */
  LICENSE_EXPIRED = 7,
  /**
   * @generated from protobuf enum value: REGION_REDIRECT = 8;
   */
  REGION_REDIRECT = 8,
  /**
   * @generated from protobuf enum value: REDIRECT_CLOUD_SSO = 9;
   */
  REDIRECT_CLOUD_SSO = 9,
  /**
   * @generated from protobuf enum value: REDIRECT_ONSITE_SSO = 10;
   */
  REDIRECT_ONSITE_SSO = 10,
  /**
   * @generated from protobuf enum value: REQUIRES_2FA = 12;
   */
  REQUIRES_2FA = 12,
  /**
   * @generated from protobuf enum value: REQUIRES_AUTH_HASH = 13;
   */
  REQUIRES_AUTH_HASH = 13,
  /**
   * @generated from protobuf enum value: REQUIRES_USERNAME = 14;
   */
  REQUIRES_USERNAME = 14,
  /**
   * @generated from protobuf enum value: AFTER_CLOUD_SSO_LOGIN = 15;
   */
  AFTER_CLOUD_SSO_LOGIN = 15,
  /**
   * @generated from protobuf enum value: REQUIRES_ACCOUNT_CREATION = 16;
   */
  REQUIRES_ACCOUNT_CREATION = 16,
  /**
   * @generated from protobuf enum value: REQUIRES_DEVICE_ENCRYPTED_DATA_KEY = 17;
   */
  REQUIRES_DEVICE_ENCRYPTED_DATA_KEY = 17,
  /**
   * @generated from protobuf enum value: LOGIN_TOKEN_EXPIRED = 18;
   */
  LOGIN_TOKEN_EXPIRED = 18,
  /**
   * @generated from protobuf enum value: PASSKEY_INITIATE_CHALLENGE = 19;
   */
  PASSKEY_INITIATE_CHALLENGE = 19,
  /**
   * @generated from protobuf enum value: PASSKEY_AUTH_REQUIRED = 20;
   */
  PASSKEY_AUTH_REQUIRED = 20,
  /**
   * @generated from protobuf enum value: PASSKEY_VERIFY_AUTHENTICATION = 21;
   */
  PASSKEY_VERIFY_AUTHENTICATION = 21,
  /**
   * @generated from protobuf enum value: AFTER_PASSKEY_LOGIN = 22;
   */
  AFTER_PASSKEY_LOGIN = 22,
  /**
   * @generated from protobuf enum value: LOGGED_IN = 99;
   */
  LOGGED_IN = 99,
}
/**
 * @generated from protobuf enum Authentication.EncryptedDataKeyType
 */
export enum EncryptedDataKeyType {
  /**
   * @generated from protobuf enum value: NO_KEY = 0;
   */
  NO_KEY = 0,
  /**
   * @generated from protobuf enum value: BY_DEVICE_PUBLIC_KEY = 1;
   */
  BY_DEVICE_PUBLIC_KEY = 1,
  /**
   * @generated from protobuf enum value: BY_PASSWORD = 2;
   */
  BY_PASSWORD = 2,
  /**
   * @generated from protobuf enum value: BY_ALTERNATE = 3;
   */
  BY_ALTERNATE = 3,
  /**
   * @generated from protobuf enum value: BY_BIO = 4;
   */
  BY_BIO = 4,
}
/**
 * @generated from protobuf enum Authentication.PasswordMethod
 */
export enum PasswordMethod {
  /**
   * @generated from protobuf enum value: ENTERED = 0;
   */
  ENTERED = 0,
  /**
   * @generated from protobuf enum value: BIOMETRICS = 1;
   */
  BIOMETRICS = 1,
}
/**
 * @generated from protobuf enum Authentication.TwoFactorPushType
 */
export enum TwoFactorPushType {
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_NONE = 0;
   */
  TWO_FA_PUSH_NONE = 0,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_SMS = 1;
   */
  TWO_FA_PUSH_SMS = 1,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_KEEPER = 2;
   */
  TWO_FA_PUSH_KEEPER = 2,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_DUO_PUSH = 3;
   */
  TWO_FA_PUSH_DUO_PUSH = 3,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_DUO_TEXT = 4;
   */
  TWO_FA_PUSH_DUO_TEXT = 4,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_DUO_CALL = 5;
   */
  TWO_FA_PUSH_DUO_CALL = 5,
  /**
   * @generated from protobuf enum value: TWO_FA_PUSH_DNA = 6;
   */
  TWO_FA_PUSH_DNA = 6,
}
/**
 * @generated from protobuf enum Authentication.TwoFactorValueType
 */
export enum TwoFactorValueType {
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_NONE = 0;
   */
  TWO_FA_CODE_NONE = 0,
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_TOTP = 1;
   */
  TWO_FA_CODE_TOTP = 1,
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_SMS = 2;
   */
  TWO_FA_CODE_SMS = 2,
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_DUO = 3;
   */
  TWO_FA_CODE_DUO = 3,
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_RSA = 4;
   */
  TWO_FA_CODE_RSA = 4,
  /**
   * @generated from protobuf enum value: TWO_FA_RESP_U2F = 5;
   */
  TWO_FA_RESP_U2F = 5,
  /**
   * @generated from protobuf enum value: TWO_FA_RESP_WEBAUTHN = 6;
   */
  TWO_FA_RESP_WEBAUTHN = 6,
  /**
   * @generated from protobuf enum value: TWO_FA_CODE_DNA = 7;
   */
  TWO_FA_CODE_DNA = 7,
}
/**
 * @generated from protobuf enum Authentication.TwoFactorChannelType
 */
export enum TwoFactorChannelType {
  /**
   * @generated from protobuf enum value: TWO_FA_CT_NONE = 0;
   */
  TWO_FA_CT_NONE = 0,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_TOTP = 1;
   */
  TWO_FA_CT_TOTP = 1,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_SMS = 2;
   */
  TWO_FA_CT_SMS = 2,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_DUO = 3;
   */
  TWO_FA_CT_DUO = 3,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_RSA = 4;
   */
  TWO_FA_CT_RSA = 4,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_BACKUP = 5;
   */
  TWO_FA_CT_BACKUP = 5,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_U2F = 6;
   */
  TWO_FA_CT_U2F = 6,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_WEBAUTHN = 7;
   */
  TWO_FA_CT_WEBAUTHN = 7,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_KEEPER = 8;
   */
  TWO_FA_CT_KEEPER = 8,
  /**
   * @generated from protobuf enum value: TWO_FA_CT_DNA = 9;
   */
  TWO_FA_CT_DNA = 9,
}
/**
 * @generated from protobuf enum Authentication.TwoFactorExpiration
 */
export enum TwoFactorExpiration {
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_IMMEDIATELY = 0;
   */
  TWO_FA_EXP_IMMEDIATELY = 0,
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_5_MINUTES = 1;
   */
  TWO_FA_EXP_5_MINUTES = 1,
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_12_HOURS = 2;
   */
  TWO_FA_EXP_12_HOURS = 2,
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_24_HOURS = 3;
   */
  TWO_FA_EXP_24_HOURS = 3,
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_30_DAYS = 4;
   */
  TWO_FA_EXP_30_DAYS = 4,
  /**
   * @generated from protobuf enum value: TWO_FA_EXP_NEVER = 5;
   */
  TWO_FA_EXP_NEVER = 5,
}
/**
 * @generated from protobuf enum Authentication.LicenseType
 */
export enum LicenseType {
  /**
   * @generated from protobuf enum value: VAULT = 0;
   */
  VAULT = 0,
  /**
   * @generated from protobuf enum value: CHAT = 1;
   */
  CHAT = 1,
  /**
   * @generated from protobuf enum value: STORAGE = 2;
   */
  STORAGE = 2,
  /**
   * @generated from protobuf enum value: BREACHWATCH = 3;
   */
  BREACHWATCH = 3,
}
/**
 * @generated from protobuf enum Authentication.ObjectTypes
 */
export enum ObjectTypes {
  /**
   * @generated from protobuf enum value: RECORD = 0;
   */
  RECORD = 0,
  /**
   * @generated from protobuf enum value: SHARED_FOLDER_USER = 1;
   */
  SHARED_FOLDER_USER = 1,
  /**
   * @generated from protobuf enum value: SHARED_FOLDER_TEAM = 2;
   */
  SHARED_FOLDER_TEAM = 2,
  /**
   * @generated from protobuf enum value: USER_FOLDER = 3;
   */
  USER_FOLDER = 3,
  /**
   * @generated from protobuf enum value: TEAM_USER = 4;
   */
  TEAM_USER = 4,
}
/**
 * @generated from protobuf enum Authentication.EncryptedObjectType
 */
export enum EncryptedObjectType {
  /**
   * @generated from protobuf enum value: EOT_UNSPECIFIED = 0;
   */
  EOT_UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: EOT_RECORD_KEY = 1;
   */
  EOT_RECORD_KEY = 1,
  /**
   * @generated from protobuf enum value: EOT_SHARED_FOLDER_USER_KEY = 2;
   */
  EOT_SHARED_FOLDER_USER_KEY = 2,
  /**
   * @generated from protobuf enum value: EOT_SHARED_FOLDER_TEAM_KEY = 3;
   */
  EOT_SHARED_FOLDER_TEAM_KEY = 3,
  /**
   * @generated from protobuf enum value: EOT_TEAM_USER_KEY = 4;
   */
  EOT_TEAM_USER_KEY = 4,
  /**
   * @generated from protobuf enum value: EOT_USER_FOLDER_KEY = 5;
   */
  EOT_USER_FOLDER_KEY = 5,
  /**
   * @generated from protobuf enum value: EOT_SECURITY_DATA = 6;
   */
  EOT_SECURITY_DATA = 6,
  /**
   * @generated from protobuf enum value: EOT_SECURITY_DATA_MASTER_PASSWORD = 7;
   */
  EOT_SECURITY_DATA_MASTER_PASSWORD = 7,
  /**
   * @generated from protobuf enum value: EOT_EMERGENCY_ACCESS_KEY = 8;
   */
  EOT_EMERGENCY_ACCESS_KEY = 8,
  /**
   * @generated from protobuf enum value: EOT_V2_RECORD_KEY = 9;
   */
  EOT_V2_RECORD_KEY = 9,
}
/**
 * @generated from protobuf enum Authentication.MasterPasswordReentryStatus
 */
export enum MasterPasswordReentryStatus {
  /**
   * @generated from protobuf enum value: MP_UNKNOWN = 0;
   */
  MP_UNKNOWN = 0,
  /**
   * @generated from protobuf enum value: MP_SUCCESS = 1;
   */
  MP_SUCCESS = 1,
  /**
   * @generated from protobuf enum value: MP_FAILURE = 2;
   */
  MP_FAILURE = 2,
}
/**
 * @generated from protobuf enum Authentication.AlternateAuthenticationType
 */
export enum AlternateAuthenticationType {
  /**
   * @generated from protobuf enum value: ALTERNATE_MASTER_PASSWORD = 0;
   */
  ALTERNATE_MASTER_PASSWORD = 0,
  /**
   * @generated from protobuf enum value: BIOMETRIC = 1;
   */
  BIOMETRIC = 1,
  /**
   * @generated from protobuf enum value: ACCOUNT_RECOVER = 2;
   */
  ACCOUNT_RECOVER = 2,
}
/**
 * @generated from protobuf enum Authentication.ThrottleType
 */
export enum ThrottleType {
  /**
   * @generated from protobuf enum value: PASSWORD_RETRY_THROTTLE = 0;
   */
  PASSWORD_RETRY_THROTTLE = 0,
  /**
   * @generated from protobuf enum value: PASSWORD_RETRY_LEGACY_THROTTLE = 1;
   */
  PASSWORD_RETRY_LEGACY_THROTTLE = 1,
  /**
   * @generated from protobuf enum value: TWO_FA_THROTTLE = 2;
   */
  TWO_FA_THROTTLE = 2,
  /**
   * @generated from protobuf enum value: TWO_FA_LEGACY_THROTTLE = 3;
   */
  TWO_FA_LEGACY_THROTTLE = 3,
  /**
   * @generated from protobuf enum value: QA_RETRY_THROTTLE = 4;
   */
  QA_RETRY_THROTTLE = 4,
  /**
   * @generated from protobuf enum value: ACCOUNT_RECOVER_THROTTLE = 5;
   */
  ACCOUNT_RECOVER_THROTTLE = 5,
  /**
   * @generated from protobuf enum value: VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE = 6;
   */
  VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE = 6,
  /**
   * @generated from protobuf enum value: VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE = 7;
   */
  VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE = 7,
}
/**
 * @generated from protobuf enum Authentication.Region
 */
export enum Region {
  /**
   * @generated from protobuf enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,
  /**
   * @generated from protobuf enum value: eu = 1;
   */
  eu = 1,
  /**
   * @generated from protobuf enum value: us = 2;
   */
  us = 2,
  /**
   * @generated from protobuf enum value: usgov = 3;
   */
  usgov = 3,
  /**
   * @generated from protobuf enum value: au = 4;
   */
  au = 4,
  /**
   * @generated from protobuf enum value: jp = 5;
   */
  jp = 5,
  /**
   * @generated from protobuf enum value: ca = 6;
   */
  ca = 6,
}
/**
 * @generated from protobuf enum Authentication.ApplicationShareType
 */
export enum ApplicationShareType {
  /**
   * @generated from protobuf enum value: SHARE_TYPE_RECORD = 0;
   */
  SHARE_TYPE_RECORD = 0,
  /**
   * @generated from protobuf enum value: SHARE_TYPE_FOLDER = 1;
   */
  SHARE_TYPE_FOLDER = 1,
}
/**
 * @generated from protobuf enum Authentication.TimeLimitedAccessType
 */
export enum TimeLimitedAccessType {
  /**
   * @generated from protobuf enum value: INVALID_TIME_LIMITED_ACCESS_TYPE = 0;
   */
  INVALID_TIME_LIMITED_ACCESS_TYPE = 0,
  /**
   * @generated from protobuf enum value: USER_ACCESS_TO_RECORD = 1;
   */
  USER_ACCESS_TO_RECORD = 1,
  /**
   * @generated from protobuf enum value: USER_OR_TEAM_ACCESS_TO_SHAREDFOLDER = 2;
   */
  USER_OR_TEAM_ACCESS_TO_SHAREDFOLDER = 2,
  /**
   * @generated from protobuf enum value: RECORD_ACCESS_TO_SHAREDFOLDER = 3;
   */
  RECORD_ACCESS_TO_SHAREDFOLDER = 3,
}
/**
 * @generated from protobuf enum Authentication.BackupKeyType
 */
export enum BackupKeyType {
  /**
   * @generated from protobuf enum value: BKT_SEC_ANSWER = 0;
   */
  BKT_SEC_ANSWER = 0,
  /**
   * @generated from protobuf enum value: BKT_PASSPHRASE_HASH = 1;
   */
  BKT_PASSPHRASE_HASH = 1,
}
/**
 * @generated from protobuf enum Authentication.GenericStatus
 */
export enum GenericStatus {
  /**
   * @generated from protobuf enum value: SUCCESS = 0;
   */
  SUCCESS = 0,
  /**
   * @generated from protobuf enum value: INVALID_OBJECT = 1;
   */
  INVALID_OBJECT = 1,
  /**
   * @generated from protobuf enum value: ALREADY_EXISTS = 2;
   */
  ALREADY_EXISTS = 2,
  /**
   * @generated from protobuf enum value: ACCESS_DENIED = 3;
   */
  ACCESS_DENIED = 3,
}
/**
 * @generated from protobuf enum Authentication.AuthenticatorAttachment
 */
export enum AuthenticatorAttachment {
  /**
   * @generated from protobuf enum value: CROSS_PLATFORM = 0;
   */
  CROSS_PLATFORM = 0,
  /**
   * @generated from protobuf enum value: PLATFORM = 1;
   */
  PLATFORM = 1,
  /**
   * @generated from protobuf enum value: ALL_SUPPORTED = 2;
   */
  ALL_SUPPORTED = 2,
}
/**
 * @generated from protobuf enum Authentication.PasskeyPurpose
 */
export enum PasskeyPurpose {
  /**
   * @generated from protobuf enum value: PK_LOGIN = 0;
   */
  PK_LOGIN = 0,
  /**
   * @generated from protobuf enum value: PK_REAUTH = 1;
   */
  PK_REAUTH = 1,
}
/**
 * @generated from protobuf enum Authentication.ClientFormFactor
 */
export enum ClientFormFactor {
  /**
   * @generated from protobuf enum value: FF_EMPTY = 0;
   */
  FF_EMPTY = 0,
  /**
   * @generated from protobuf enum value: FF_PHONE = 1;
   */
  FF_PHONE = 1,
  /**
   * @generated from protobuf enum value: FF_TABLET = 2;
   */
  FF_TABLET = 2,
  /**
   * @generated from protobuf enum value: FF_WATCH = 3;
   */
  FF_WATCH = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class ApiRequest$Type extends MessageType<ApiRequest> {
  constructor() {
    super("Authentication.ApiRequest", [
      { no: 1, name: "encryptedTransmissionKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "publicKeyId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "locale", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "encryptedPayload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "encryptionType", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: "recaptcha", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: "subEnvironment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ApiRequest>): ApiRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedTransmissionKey = new Uint8Array(0);
    message.publicKeyId = 0;
    message.locale = "";
    message.encryptedPayload = new Uint8Array(0);
    message.encryptionType = 0;
    message.recaptcha = "";
    message.subEnvironment = "";
    if (value !== undefined) reflectionMergePartial<ApiRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApiRequest,
  ): ApiRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedTransmissionKey */ 1:
          message.encryptedTransmissionKey = reader.bytes();
          break;
        case /* int32 publicKeyId */ 2:
          message.publicKeyId = reader.int32();
          break;
        case /* string locale */ 3:
          message.locale = reader.string();
          break;
        case /* bytes encryptedPayload */ 4:
          message.encryptedPayload = reader.bytes();
          break;
        case /* int32 encryptionType */ 5:
          message.encryptionType = reader.int32();
          break;
        case /* string recaptcha */ 6:
          message.recaptcha = reader.string();
          break;
        case /* string subEnvironment */ 7:
          message.subEnvironment = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApiRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedTransmissionKey = 1; */
    if (message.encryptedTransmissionKey.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedTransmissionKey);
    /* int32 publicKeyId = 2; */
    if (message.publicKeyId !== 0) writer.tag(2, WireType.Varint).int32(message.publicKeyId);
    /* string locale = 3; */
    if (message.locale !== "") writer.tag(3, WireType.LengthDelimited).string(message.locale);
    /* bytes encryptedPayload = 4; */
    if (message.encryptedPayload.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedPayload);
    /* int32 encryptionType = 5; */
    if (message.encryptionType !== 0) writer.tag(5, WireType.Varint).int32(message.encryptionType);
    /* string recaptcha = 6; */
    if (message.recaptcha !== "") writer.tag(6, WireType.LengthDelimited).string(message.recaptcha);
    /* string subEnvironment = 7; */
    if (message.subEnvironment !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.subEnvironment);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApiRequest
 */
export const ApiRequest = new ApiRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApiRequestPayload$Type extends MessageType<ApiRequestPayload> {
  constructor() {
    super("Authentication.ApiRequestPayload", [
      { no: 1, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "timeToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "apiVersion", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<ApiRequestPayload>): ApiRequestPayload {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.payload = new Uint8Array(0);
    message.encryptedSessionToken = new Uint8Array(0);
    message.timeToken = new Uint8Array(0);
    message.apiVersion = 0;
    if (value !== undefined) reflectionMergePartial<ApiRequestPayload>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApiRequestPayload,
  ): ApiRequestPayload {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes payload */ 1:
          message.payload = reader.bytes();
          break;
        case /* bytes encryptedSessionToken */ 2:
          message.encryptedSessionToken = reader.bytes();
          break;
        case /* bytes timeToken */ 3:
          message.timeToken = reader.bytes();
          break;
        case /* int32 apiVersion */ 4:
          message.apiVersion = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApiRequestPayload,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes payload = 1; */
    if (message.payload.length) writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
    /* bytes encryptedSessionToken = 2; */
    if (message.encryptedSessionToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedSessionToken);
    /* bytes timeToken = 3; */
    if (message.timeToken.length) writer.tag(3, WireType.LengthDelimited).bytes(message.timeToken);
    /* int32 apiVersion = 4; */
    if (message.apiVersion !== 0) writer.tag(4, WireType.Varint).int32(message.apiVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApiRequestPayload
 */
export const ApiRequestPayload = new ApiRequestPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transform$Type extends MessageType<Transform> {
  constructor() {
    super("Authentication.Transform", [
      { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<Transform>): Transform {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = new Uint8Array(0);
    message.encryptedDeviceToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<Transform>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Transform,
  ): Transform {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes key */ 1:
          message.key = reader.bytes();
          break;
        case /* bytes encryptedDeviceToken */ 2:
          message.encryptedDeviceToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Transform,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes key = 1; */
    if (message.key.length) writer.tag(1, WireType.LengthDelimited).bytes(message.key);
    /* bytes encryptedDeviceToken = 2; */
    if (message.encryptedDeviceToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.Transform
 */
export const Transform = new Transform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceRequest$Type extends MessageType<DeviceRequest> {
  constructor() {
    super("Authentication.DeviceRequest", [
      { no: 1, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "devicePlatform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "clientFormFactor",
        kind: "enum",
        T: () => ["Authentication.ClientFormFactor", ClientFormFactor],
      },
      { no: 5, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DeviceRequest>): DeviceRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientVersion = "";
    message.deviceName = "";
    message.devicePlatform = "";
    message.clientFormFactor = 0;
    message.username = "";
    if (value !== undefined) reflectionMergePartial<DeviceRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceRequest,
  ): DeviceRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string clientVersion */ 1:
          message.clientVersion = reader.string();
          break;
        case /* string deviceName */ 2:
          message.deviceName = reader.string();
          break;
        case /* string devicePlatform */ 3:
          message.devicePlatform = reader.string();
          break;
        case /* Authentication.ClientFormFactor clientFormFactor */ 4:
          message.clientFormFactor = reader.int32();
          break;
        case /* string username */ 5:
          message.username = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string clientVersion = 1; */
    if (message.clientVersion !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.clientVersion);
    /* string deviceName = 2; */
    if (message.deviceName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.deviceName);
    /* string devicePlatform = 3; */
    if (message.devicePlatform !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.devicePlatform);
    /* Authentication.ClientFormFactor clientFormFactor = 4; */
    if (message.clientFormFactor !== 0)
      writer.tag(4, WireType.Varint).int32(message.clientFormFactor);
    /* string username = 5; */
    if (message.username !== "") writer.tag(5, WireType.LengthDelimited).string(message.username);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceRequest
 */
export const DeviceRequest = new DeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthRequest$Type extends MessageType<AuthRequest> {
  constructor() {
    super("Authentication.AuthRequest", [
      { no: 1, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<AuthRequest>): AuthRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientVersion = "";
    message.username = "";
    message.encryptedDeviceToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<AuthRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AuthRequest,
  ): AuthRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string clientVersion */ 1:
          message.clientVersion = reader.string();
          break;
        case /* string username */ 2:
          message.username = reader.string();
          break;
        case /* bytes encryptedDeviceToken */ 3:
          message.encryptedDeviceToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AuthRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string clientVersion = 1; */
    if (message.clientVersion !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.clientVersion);
    /* string username = 2; */
    if (message.username !== "") writer.tag(2, WireType.LengthDelimited).string(message.username);
    /* bytes encryptedDeviceToken = 3; */
    if (message.encryptedDeviceToken.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AuthRequest
 */
export const AuthRequest = new AuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewUserMinimumParams$Type extends MessageType<NewUserMinimumParams> {
  constructor() {
    super("Authentication.NewUserMinimumParams", [
      { no: 1, name: "minimumIterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: "passwordMatchRegex",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "passwordMatchDescription",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "isEnterpriseDomain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: "enterpriseEccPublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "forbidKeyType2", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<NewUserMinimumParams>): NewUserMinimumParams {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.minimumIterations = 0;
    message.passwordMatchRegex = [];
    message.passwordMatchDescription = [];
    message.isEnterpriseDomain = false;
    message.enterpriseEccPublicKey = new Uint8Array(0);
    message.forbidKeyType2 = false;
    if (value !== undefined) reflectionMergePartial<NewUserMinimumParams>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NewUserMinimumParams,
  ): NewUserMinimumParams {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 minimumIterations */ 1:
          message.minimumIterations = reader.int32();
          break;
        case /* repeated string passwordMatchRegex */ 2:
          message.passwordMatchRegex.push(reader.string());
          break;
        case /* repeated string passwordMatchDescription */ 3:
          message.passwordMatchDescription.push(reader.string());
          break;
        case /* bool isEnterpriseDomain */ 4:
          message.isEnterpriseDomain = reader.bool();
          break;
        case /* bytes enterpriseEccPublicKey */ 5:
          message.enterpriseEccPublicKey = reader.bytes();
          break;
        case /* bool forbidKeyType2 */ 6:
          message.forbidKeyType2 = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NewUserMinimumParams,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 minimumIterations = 1; */
    if (message.minimumIterations !== 0)
      writer.tag(1, WireType.Varint).int32(message.minimumIterations);
    /* repeated string passwordMatchRegex = 2; */
    for (let i = 0; i < message.passwordMatchRegex.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.passwordMatchRegex[i]);
    /* repeated string passwordMatchDescription = 3; */
    for (let i = 0; i < message.passwordMatchDescription.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.passwordMatchDescription[i]);
    /* bool isEnterpriseDomain = 4; */
    if (message.isEnterpriseDomain !== false)
      writer.tag(4, WireType.Varint).bool(message.isEnterpriseDomain);
    /* bytes enterpriseEccPublicKey = 5; */
    if (message.enterpriseEccPublicKey.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.enterpriseEccPublicKey);
    /* bool forbidKeyType2 = 6; */
    if (message.forbidKeyType2 !== false)
      writer.tag(6, WireType.Varint).bool(message.forbidKeyType2);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.NewUserMinimumParams
 */
export const NewUserMinimumParams = new NewUserMinimumParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreLoginRequest$Type extends MessageType<PreLoginRequest> {
  constructor() {
    super("Authentication.PreLoginRequest", [
      { no: 1, name: "authRequest", kind: "message", T: () => AuthRequest },
      { no: 2, name: "loginType", kind: "enum", T: () => ["Authentication.LoginType", LoginType] },
      { no: 3, name: "twoFactorToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<PreLoginRequest>): PreLoginRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.loginType = 0;
    message.twoFactorToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<PreLoginRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PreLoginRequest,
  ): PreLoginRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.AuthRequest authRequest */ 1:
          message.authRequest = AuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authRequest,
          );
          break;
        case /* Authentication.LoginType loginType */ 2:
          message.loginType = reader.int32();
          break;
        case /* bytes twoFactorToken */ 3:
          message.twoFactorToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PreLoginRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthRequest authRequest = 1; */
    if (message.authRequest)
      AuthRequest.internalBinaryWrite(
        message.authRequest,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Authentication.LoginType loginType = 2; */
    if (message.loginType !== 0) writer.tag(2, WireType.Varint).int32(message.loginType);
    /* bytes twoFactorToken = 3; */
    if (message.twoFactorToken.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.twoFactorToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PreLoginRequest
 */
export const PreLoginRequest = new PreLoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
  constructor() {
    super("Authentication.LoginRequest", [
      { no: 1, name: "authRequest", kind: "message", T: () => AuthRequest },
      { no: 2, name: "loginType", kind: "enum", T: () => ["Authentication.LoginType", LoginType] },
      { no: 3, name: "authenticationHashPrime", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "authResponse", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "mcEnterpriseId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: "push_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 8, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<LoginRequest>): LoginRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.loginType = 0;
    message.authenticationHashPrime = new Uint8Array(0);
    message.encryptedLoginToken = new Uint8Array(0);
    message.authResponse = new Uint8Array(0);
    message.mcEnterpriseId = 0;
    message.pushToken = "";
    message.platform = "";
    if (value !== undefined) reflectionMergePartial<LoginRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LoginRequest,
  ): LoginRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.AuthRequest authRequest */ 1:
          message.authRequest = AuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authRequest,
          );
          break;
        case /* Authentication.LoginType loginType */ 2:
          message.loginType = reader.int32();
          break;
        case /* bytes authenticationHashPrime */ 3:
          message.authenticationHashPrime = reader.bytes();
          break;
        case /* bytes encryptedLoginToken */ 4:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* bytes authResponse */ 5:
          message.authResponse = reader.bytes();
          break;
        case /* int32 mcEnterpriseId */ 6:
          message.mcEnterpriseId = reader.int32();
          break;
        case /* string push_token */ 7:
          message.pushToken = reader.string();
          break;
        case /* string platform */ 8:
          message.platform = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LoginRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthRequest authRequest = 1; */
    if (message.authRequest)
      AuthRequest.internalBinaryWrite(
        message.authRequest,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Authentication.LoginType loginType = 2; */
    if (message.loginType !== 0) writer.tag(2, WireType.Varint).int32(message.loginType);
    /* bytes authenticationHashPrime = 3; */
    if (message.authenticationHashPrime.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.authenticationHashPrime);
    /* bytes encryptedLoginToken = 4; */
    if (message.encryptedLoginToken.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* bytes authResponse = 5; */
    if (message.authResponse.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.authResponse);
    /* int32 mcEnterpriseId = 6; */
    if (message.mcEnterpriseId !== 0) writer.tag(6, WireType.Varint).int32(message.mcEnterpriseId);
    /* string push_token = 7; */
    if (message.pushToken !== "") writer.tag(7, WireType.LengthDelimited).string(message.pushToken);
    /* string platform = 8; */
    if (message.platform !== "") writer.tag(8, WireType.LengthDelimited).string(message.platform);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceResponse$Type extends MessageType<DeviceResponse> {
  constructor() {
    super("Authentication.DeviceResponse", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "status",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceResponse>): DeviceResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.status = 0;
    if (value !== undefined) reflectionMergePartial<DeviceResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceResponse,
  ): DeviceResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* Authentication.DeviceStatus status */ 2:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* Authentication.DeviceStatus status = 2; */
    if (message.status !== 0) writer.tag(2, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceResponse
 */
export const DeviceResponse = new DeviceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Salt$Type extends MessageType<Salt> {
  constructor() {
    super("Authentication.Salt", [
      { no: 1, name: "iterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "algorithm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<Salt>): Salt {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.iterations = 0;
    message.salt = new Uint8Array(0);
    message.algorithm = 0;
    message.uid = new Uint8Array(0);
    message.name = "";
    if (value !== undefined) reflectionMergePartial<Salt>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Salt,
  ): Salt {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 iterations */ 1:
          message.iterations = reader.int32();
          break;
        case /* bytes salt */ 2:
          message.salt = reader.bytes();
          break;
        case /* int32 algorithm */ 3:
          message.algorithm = reader.int32();
          break;
        case /* bytes uid */ 4:
          message.uid = reader.bytes();
          break;
        case /* string name */ 5:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Salt,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 iterations = 1; */
    if (message.iterations !== 0) writer.tag(1, WireType.Varint).int32(message.iterations);
    /* bytes salt = 2; */
    if (message.salt.length) writer.tag(2, WireType.LengthDelimited).bytes(message.salt);
    /* int32 algorithm = 3; */
    if (message.algorithm !== 0) writer.tag(3, WireType.Varint).int32(message.algorithm);
    /* bytes uid = 4; */
    if (message.uid.length) writer.tag(4, WireType.LengthDelimited).bytes(message.uid);
    /* string name = 5; */
    if (message.name !== "") writer.tag(5, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.Salt
 */
export const Salt = new Salt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorChannel$Type extends MessageType<TwoFactorChannel> {
  constructor() {
    super("Authentication.TwoFactorChannel", [
      { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<TwoFactorChannel>): TwoFactorChannel {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    if (value !== undefined) reflectionMergePartial<TwoFactorChannel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorChannel,
  ): TwoFactorChannel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 type */ 1:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorChannel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorChannel
 */
export const TwoFactorChannel = new TwoFactorChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartLoginRequest$Type extends MessageType<StartLoginRequest> {
  constructor() {
    super("Authentication.StartLoginRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "loginType", kind: "enum", T: () => ["Authentication.LoginType", LoginType] },
      { no: 7, name: "mcEnterpriseId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 8,
        name: "loginMethod",
        kind: "enum",
        T: () => ["Authentication.LoginMethod", LoginMethod],
      },
      { no: 9, name: "forceNewLogin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 10, name: "cloneCode", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 11, name: "v2TwoFactorToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 12, name: "accountUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 13, name: "fromSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<StartLoginRequest>): StartLoginRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.username = "";
    message.clientVersion = "";
    message.messageSessionUid = new Uint8Array(0);
    message.encryptedLoginToken = new Uint8Array(0);
    message.loginType = 0;
    message.mcEnterpriseId = 0;
    message.loginMethod = 0;
    message.forceNewLogin = false;
    message.cloneCode = new Uint8Array(0);
    message.v2TwoFactorToken = "";
    message.accountUid = new Uint8Array(0);
    message.fromSessionToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<StartLoginRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: StartLoginRequest,
  ): StartLoginRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string username */ 2:
          message.username = reader.string();
          break;
        case /* string clientVersion */ 3:
          message.clientVersion = reader.string();
          break;
        case /* bytes messageSessionUid */ 4:
          message.messageSessionUid = reader.bytes();
          break;
        case /* bytes encryptedLoginToken */ 5:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* Authentication.LoginType loginType */ 6:
          message.loginType = reader.int32();
          break;
        case /* int32 mcEnterpriseId */ 7:
          message.mcEnterpriseId = reader.int32();
          break;
        case /* Authentication.LoginMethod loginMethod */ 8:
          message.loginMethod = reader.int32();
          break;
        case /* bool forceNewLogin */ 9:
          message.forceNewLogin = reader.bool();
          break;
        case /* bytes cloneCode */ 10:
          message.cloneCode = reader.bytes();
          break;
        case /* string v2TwoFactorToken */ 11:
          message.v2TwoFactorToken = reader.string();
          break;
        case /* bytes accountUid */ 12:
          message.accountUid = reader.bytes();
          break;
        case /* bytes fromSessionToken */ 13:
          message.fromSessionToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: StartLoginRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string username = 2; */
    if (message.username !== "") writer.tag(2, WireType.LengthDelimited).string(message.username);
    /* string clientVersion = 3; */
    if (message.clientVersion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.clientVersion);
    /* bytes messageSessionUid = 4; */
    if (message.messageSessionUid.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* bytes encryptedLoginToken = 5; */
    if (message.encryptedLoginToken.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* Authentication.LoginType loginType = 6; */
    if (message.loginType !== 0) writer.tag(6, WireType.Varint).int32(message.loginType);
    /* int32 mcEnterpriseId = 7; */
    if (message.mcEnterpriseId !== 0) writer.tag(7, WireType.Varint).int32(message.mcEnterpriseId);
    /* Authentication.LoginMethod loginMethod = 8; */
    if (message.loginMethod !== 0) writer.tag(8, WireType.Varint).int32(message.loginMethod);
    /* bool forceNewLogin = 9; */
    if (message.forceNewLogin !== false) writer.tag(9, WireType.Varint).bool(message.forceNewLogin);
    /* bytes cloneCode = 10; */
    if (message.cloneCode.length) writer.tag(10, WireType.LengthDelimited).bytes(message.cloneCode);
    /* string v2TwoFactorToken = 11; */
    if (message.v2TwoFactorToken !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.v2TwoFactorToken);
    /* bytes accountUid = 12; */
    if (message.accountUid.length)
      writer.tag(12, WireType.LengthDelimited).bytes(message.accountUid);
    /* bytes fromSessionToken = 13; */
    if (message.fromSessionToken.length)
      writer.tag(13, WireType.LengthDelimited).bytes(message.fromSessionToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.StartLoginRequest
 */
export const StartLoginRequest = new StartLoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
  constructor() {
    super("Authentication.LoginResponse", [
      {
        no: 1,
        name: "loginState",
        kind: "enum",
        T: () => ["Authentication.LoginState", LoginState],
      },
      { no: 2, name: "accountUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "primaryUsername", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "encryptedDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "encryptedDataKeyType",
        kind: "enum",
        T: () => ["Authentication.EncryptedDataKeyType", EncryptedDataKeyType],
      },
      { no: 6, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 7, name: "encryptedSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 8,
        name: "sessionTokenType",
        kind: "enum",
        T: () => ["Authentication.SessionTokenType", SessionTokenType],
      },
      { no: 9, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 10, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 11,
        name: "channels",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TwoFactorChannelInfo,
      },
      { no: 12, name: "salt", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Salt },
      { no: 13, name: "cloneCode", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 14, name: "stateSpecificValue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 15, name: "ssoClientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 16, name: "sessionTokenTypeModifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<LoginResponse>): LoginResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.loginState = 0;
    message.accountUid = new Uint8Array(0);
    message.primaryUsername = "";
    message.encryptedDataKey = new Uint8Array(0);
    message.encryptedDataKeyType = 0;
    message.encryptedLoginToken = new Uint8Array(0);
    message.encryptedSessionToken = new Uint8Array(0);
    message.sessionTokenType = 0;
    message.message = "";
    message.url = "";
    message.channels = [];
    message.salt = [];
    message.cloneCode = new Uint8Array(0);
    message.stateSpecificValue = "";
    message.ssoClientVersion = "";
    message.sessionTokenTypeModifier = "";
    if (value !== undefined) reflectionMergePartial<LoginResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LoginResponse,
  ): LoginResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.LoginState loginState */ 1:
          message.loginState = reader.int32();
          break;
        case /* bytes accountUid */ 2:
          message.accountUid = reader.bytes();
          break;
        case /* string primaryUsername */ 3:
          message.primaryUsername = reader.string();
          break;
        case /* bytes encryptedDataKey */ 4:
          message.encryptedDataKey = reader.bytes();
          break;
        case /* Authentication.EncryptedDataKeyType encryptedDataKeyType */ 5:
          message.encryptedDataKeyType = reader.int32();
          break;
        case /* bytes encryptedLoginToken */ 6:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* bytes encryptedSessionToken */ 7:
          message.encryptedSessionToken = reader.bytes();
          break;
        case /* Authentication.SessionTokenType sessionTokenType */ 8:
          message.sessionTokenType = reader.int32();
          break;
        case /* string message */ 9:
          message.message = reader.string();
          break;
        case /* string url */ 10:
          message.url = reader.string();
          break;
        case /* repeated Authentication.TwoFactorChannelInfo channels */ 11:
          message.channels.push(
            TwoFactorChannelInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated Authentication.Salt salt */ 12:
          message.salt.push(Salt.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bytes cloneCode */ 13:
          message.cloneCode = reader.bytes();
          break;
        case /* string stateSpecificValue */ 14:
          message.stateSpecificValue = reader.string();
          break;
        case /* string ssoClientVersion */ 15:
          message.ssoClientVersion = reader.string();
          break;
        case /* string sessionTokenTypeModifier */ 16:
          message.sessionTokenTypeModifier = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LoginResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.LoginState loginState = 1; */
    if (message.loginState !== 0) writer.tag(1, WireType.Varint).int32(message.loginState);
    /* bytes accountUid = 2; */
    if (message.accountUid.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.accountUid);
    /* string primaryUsername = 3; */
    if (message.primaryUsername !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.primaryUsername);
    /* bytes encryptedDataKey = 4; */
    if (message.encryptedDataKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedDataKey);
    /* Authentication.EncryptedDataKeyType encryptedDataKeyType = 5; */
    if (message.encryptedDataKeyType !== 0)
      writer.tag(5, WireType.Varint).int32(message.encryptedDataKeyType);
    /* bytes encryptedLoginToken = 6; */
    if (message.encryptedLoginToken.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* bytes encryptedSessionToken = 7; */
    if (message.encryptedSessionToken.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.encryptedSessionToken);
    /* Authentication.SessionTokenType sessionTokenType = 8; */
    if (message.sessionTokenType !== 0)
      writer.tag(8, WireType.Varint).int32(message.sessionTokenType);
    /* string message = 9; */
    if (message.message !== "") writer.tag(9, WireType.LengthDelimited).string(message.message);
    /* string url = 10; */
    if (message.url !== "") writer.tag(10, WireType.LengthDelimited).string(message.url);
    /* repeated Authentication.TwoFactorChannelInfo channels = 11; */
    for (let i = 0; i < message.channels.length; i++)
      TwoFactorChannelInfo.internalBinaryWrite(
        message.channels[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.Salt salt = 12; */
    for (let i = 0; i < message.salt.length; i++)
      Salt.internalBinaryWrite(
        message.salt[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes cloneCode = 13; */
    if (message.cloneCode.length) writer.tag(13, WireType.LengthDelimited).bytes(message.cloneCode);
    /* string stateSpecificValue = 14; */
    if (message.stateSpecificValue !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.stateSpecificValue);
    /* string ssoClientVersion = 15; */
    if (message.ssoClientVersion !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.ssoClientVersion);
    /* string sessionTokenTypeModifier = 16; */
    if (message.sessionTokenTypeModifier !== "")
      writer.tag(16, WireType.LengthDelimited).string(message.sessionTokenTypeModifier);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchListElement$Type extends MessageType<SwitchListElement> {
  constructor() {
    super("Authentication.SwitchListElement", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "fullName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "authRequired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "isLinked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<SwitchListElement>): SwitchListElement {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.fullName = "";
    message.authRequired = false;
    message.isLinked = false;
    if (value !== undefined) reflectionMergePartial<SwitchListElement>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SwitchListElement,
  ): SwitchListElement {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* string fullName */ 2:
          message.fullName = reader.string();
          break;
        case /* bool authRequired */ 3:
          message.authRequired = reader.bool();
          break;
        case /* bool isLinked */ 4:
          message.isLinked = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SwitchListElement,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* string fullName = 2; */
    if (message.fullName !== "") writer.tag(2, WireType.LengthDelimited).string(message.fullName);
    /* bool authRequired = 3; */
    if (message.authRequired !== false) writer.tag(3, WireType.Varint).bool(message.authRequired);
    /* bool isLinked = 4; */
    if (message.isLinked !== false) writer.tag(4, WireType.Varint).bool(message.isLinked);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SwitchListElement
 */
export const SwitchListElement = new SwitchListElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchListResponse$Type extends MessageType<SwitchListResponse> {
  constructor() {
    super("Authentication.SwitchListResponse", [
      {
        no: 1,
        name: "elements",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SwitchListElement,
      },
    ]);
  }
  create(value?: PartialMessage<SwitchListResponse>): SwitchListResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.elements = [];
    if (value !== undefined) reflectionMergePartial<SwitchListResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SwitchListResponse,
  ): SwitchListResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.SwitchListElement elements */ 1:
          message.elements.push(
            SwitchListElement.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SwitchListResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.SwitchListElement elements = 1; */
    for (let i = 0; i < message.elements.length; i++)
      SwitchListElement.internalBinaryWrite(
        message.elements[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SwitchListResponse
 */
export const SwitchListResponse = new SwitchListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SsoUserInfo$Type extends MessageType<SsoUserInfo> {
  constructor() {
    super("Authentication.SsoUserInfo", [
      { no: 1, name: "companyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "samlRequest", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "samlRequestType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "ssoDomainName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "loginUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "logoutUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<SsoUserInfo>): SsoUserInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.companyName = "";
    message.samlRequest = "";
    message.samlRequestType = "";
    message.ssoDomainName = "";
    message.loginUrl = "";
    message.logoutUrl = "";
    if (value !== undefined) reflectionMergePartial<SsoUserInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SsoUserInfo,
  ): SsoUserInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string companyName */ 1:
          message.companyName = reader.string();
          break;
        case /* string samlRequest */ 2:
          message.samlRequest = reader.string();
          break;
        case /* string samlRequestType */ 3:
          message.samlRequestType = reader.string();
          break;
        case /* string ssoDomainName */ 4:
          message.ssoDomainName = reader.string();
          break;
        case /* string loginUrl */ 5:
          message.loginUrl = reader.string();
          break;
        case /* string logoutUrl */ 6:
          message.logoutUrl = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SsoUserInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string companyName = 1; */
    if (message.companyName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.companyName);
    /* string samlRequest = 2; */
    if (message.samlRequest !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.samlRequest);
    /* string samlRequestType = 3; */
    if (message.samlRequestType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.samlRequestType);
    /* string ssoDomainName = 4; */
    if (message.ssoDomainName !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.ssoDomainName);
    /* string loginUrl = 5; */
    if (message.loginUrl !== "") writer.tag(5, WireType.LengthDelimited).string(message.loginUrl);
    /* string logoutUrl = 6; */
    if (message.logoutUrl !== "") writer.tag(6, WireType.LengthDelimited).string(message.logoutUrl);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SsoUserInfo
 */
export const SsoUserInfo = new SsoUserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreLoginResponse$Type extends MessageType<PreLoginResponse> {
  constructor() {
    super("Authentication.PreLoginResponse", [
      {
        no: 1,
        name: "deviceStatus",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
      { no: 2, name: "salt", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Salt },
      {
        no: 3,
        name: "OBSOLETE_FIELD",
        kind: "message",
        jsonName: "OBSOLETEFIELD",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TwoFactorChannel,
      },
      { no: 4, name: "ssoUserInfo", kind: "message", T: () => SsoUserInfo },
    ]);
  }
  create(value?: PartialMessage<PreLoginResponse>): PreLoginResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deviceStatus = 0;
    message.salt = [];
    message.oBSOLETEFIELD = [];
    if (value !== undefined) reflectionMergePartial<PreLoginResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PreLoginResponse,
  ): PreLoginResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.DeviceStatus deviceStatus */ 1:
          message.deviceStatus = reader.int32();
          break;
        case /* repeated Authentication.Salt salt */ 2:
          message.salt.push(Salt.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated Authentication.TwoFactorChannel OBSOLETE_FIELD */ 3:
          message.oBSOLETEFIELD.push(
            TwoFactorChannel.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* Authentication.SsoUserInfo ssoUserInfo */ 4:
          message.ssoUserInfo = SsoUserInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ssoUserInfo,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PreLoginResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.DeviceStatus deviceStatus = 1; */
    if (message.deviceStatus !== 0) writer.tag(1, WireType.Varint).int32(message.deviceStatus);
    /* repeated Authentication.Salt salt = 2; */
    for (let i = 0; i < message.salt.length; i++)
      Salt.internalBinaryWrite(
        message.salt[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.TwoFactorChannel OBSOLETE_FIELD = 3; */
    for (let i = 0; i < message.oBSOLETEFIELD.length; i++)
      TwoFactorChannel.internalBinaryWrite(
        message.oBSOLETEFIELD[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Authentication.SsoUserInfo ssoUserInfo = 4; */
    if (message.ssoUserInfo)
      SsoUserInfo.internalBinaryWrite(
        message.ssoUserInfo,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PreLoginResponse
 */
export const PreLoginResponse = new PreLoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginAsUserRequest$Type extends MessageType<LoginAsUserRequest> {
  constructor() {
    super("Authentication.LoginAsUserRequest", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<LoginAsUserRequest>): LoginAsUserRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    if (value !== undefined) reflectionMergePartial<LoginAsUserRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LoginAsUserRequest,
  ): LoginAsUserRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LoginAsUserRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.LoginAsUserRequest
 */
export const LoginAsUserRequest = new LoginAsUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginAsUserResponse$Type extends MessageType<LoginAsUserResponse> {
  constructor() {
    super("Authentication.LoginAsUserResponse", [
      { no: 1, name: "encryptedSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedSharedAccountKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<LoginAsUserResponse>): LoginAsUserResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedSessionToken = new Uint8Array(0);
    message.encryptedSharedAccountKey = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<LoginAsUserResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LoginAsUserResponse,
  ): LoginAsUserResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedSessionToken */ 1:
          message.encryptedSessionToken = reader.bytes();
          break;
        case /* bytes encryptedSharedAccountKey */ 2:
          message.encryptedSharedAccountKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LoginAsUserResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedSessionToken = 1; */
    if (message.encryptedSessionToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedSessionToken);
    /* bytes encryptedSharedAccountKey = 2; */
    if (message.encryptedSharedAccountKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedSharedAccountKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.LoginAsUserResponse
 */
export const LoginAsUserResponse = new LoginAsUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateAuthHashRequest$Type extends MessageType<ValidateAuthHashRequest> {
  constructor() {
    super("Authentication.ValidateAuthHashRequest", [
      {
        no: 1,
        name: "passwordMethod",
        kind: "enum",
        T: () => ["Authentication.PasswordMethod", PasswordMethod],
      },
      { no: 2, name: "authResponse", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ValidateAuthHashRequest>): ValidateAuthHashRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.passwordMethod = 0;
    message.authResponse = new Uint8Array(0);
    message.encryptedLoginToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<ValidateAuthHashRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidateAuthHashRequest,
  ): ValidateAuthHashRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.PasswordMethod passwordMethod */ 1:
          message.passwordMethod = reader.int32();
          break;
        case /* bytes authResponse */ 2:
          message.authResponse = reader.bytes();
          break;
        case /* bytes encryptedLoginToken */ 3:
          message.encryptedLoginToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidateAuthHashRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.PasswordMethod passwordMethod = 1; */
    if (message.passwordMethod !== 0) writer.tag(1, WireType.Varint).int32(message.passwordMethod);
    /* bytes authResponse = 2; */
    if (message.authResponse.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.authResponse);
    /* bytes encryptedLoginToken = 3; */
    if (message.encryptedLoginToken.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ValidateAuthHashRequest
 */
export const ValidateAuthHashRequest = new ValidateAuthHashRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorChannelInfo$Type extends MessageType<TwoFactorChannelInfo> {
  constructor() {
    super("Authentication.TwoFactorChannelInfo", [
      {
        no: 1,
        name: "channelType",
        kind: "enum",
        T: () => ["Authentication.TwoFactorChannelType", TwoFactorChannelType],
      },
      { no: 2, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "channelName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "capabilities",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 6, name: "phoneNumber", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 7,
        name: "maxExpiration",
        kind: "enum",
        T: () => ["Authentication.TwoFactorExpiration", TwoFactorExpiration],
      },
      {
        no: 8,
        name: "createdOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 9,
        name: "lastFrequency",
        kind: "enum",
        T: () => ["Authentication.TwoFactorExpiration", TwoFactorExpiration],
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorChannelInfo>): TwoFactorChannelInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.channelType = 0;
    message.channelUid = new Uint8Array(0);
    message.channelName = "";
    message.challenge = "";
    message.capabilities = [];
    message.phoneNumber = "";
    message.maxExpiration = 0;
    message.createdOn = BigInt(0);
    message.lastFrequency = 0;
    if (value !== undefined) reflectionMergePartial<TwoFactorChannelInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorChannelInfo,
  ): TwoFactorChannelInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.TwoFactorChannelType channelType */ 1:
          message.channelType = reader.int32();
          break;
        case /* bytes channel_uid */ 2:
          message.channelUid = reader.bytes();
          break;
        case /* string channelName */ 3:
          message.channelName = reader.string();
          break;
        case /* string challenge */ 4:
          message.challenge = reader.string();
          break;
        case /* repeated string capabilities */ 5:
          message.capabilities.push(reader.string());
          break;
        case /* string phoneNumber */ 6:
          message.phoneNumber = reader.string();
          break;
        case /* Authentication.TwoFactorExpiration maxExpiration */ 7:
          message.maxExpiration = reader.int32();
          break;
        case /* int64 createdOn */ 8:
          message.createdOn = reader.int64().toBigInt();
          break;
        case /* Authentication.TwoFactorExpiration lastFrequency */ 9:
          message.lastFrequency = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorChannelInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.TwoFactorChannelType channelType = 1; */
    if (message.channelType !== 0) writer.tag(1, WireType.Varint).int32(message.channelType);
    /* bytes channel_uid = 2; */
    if (message.channelUid.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.channelUid);
    /* string channelName = 3; */
    if (message.channelName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.channelName);
    /* string challenge = 4; */
    if (message.challenge !== "") writer.tag(4, WireType.LengthDelimited).string(message.challenge);
    /* repeated string capabilities = 5; */
    for (let i = 0; i < message.capabilities.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.capabilities[i]);
    /* string phoneNumber = 6; */
    if (message.phoneNumber !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.phoneNumber);
    /* Authentication.TwoFactorExpiration maxExpiration = 7; */
    if (message.maxExpiration !== 0) writer.tag(7, WireType.Varint).int32(message.maxExpiration);
    /* int64 createdOn = 8; */
    if (message.createdOn !== BigInt(0)) writer.tag(8, WireType.Varint).int64(message.createdOn);
    /* Authentication.TwoFactorExpiration lastFrequency = 9; */
    if (message.lastFrequency !== 0) writer.tag(9, WireType.Varint).int32(message.lastFrequency);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorChannelInfo
 */
export const TwoFactorChannelInfo = new TwoFactorChannelInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorDuoStatus$Type extends MessageType<TwoFactorDuoStatus> {
  constructor() {
    super("Authentication.TwoFactorDuoStatus", [
      {
        no: 1,
        name: "capabilities",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "phoneNumber", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "enroll_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<TwoFactorDuoStatus>): TwoFactorDuoStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.capabilities = [];
    message.phoneNumber = "";
    message.enrollUrl = "";
    message.message = "";
    if (value !== undefined) reflectionMergePartial<TwoFactorDuoStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorDuoStatus,
  ): TwoFactorDuoStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string capabilities */ 1:
          message.capabilities.push(reader.string());
          break;
        case /* string phoneNumber */ 2:
          message.phoneNumber = reader.string();
          break;
        case /* string enroll_url */ 3:
          message.enrollUrl = reader.string();
          break;
        case /* string message */ 4:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorDuoStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string capabilities = 1; */
    for (let i = 0; i < message.capabilities.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.capabilities[i]);
    /* string phoneNumber = 2; */
    if (message.phoneNumber !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.phoneNumber);
    /* string enroll_url = 3; */
    if (message.enrollUrl !== "") writer.tag(3, WireType.LengthDelimited).string(message.enrollUrl);
    /* string message = 4; */
    if (message.message !== "") writer.tag(4, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorDuoStatus
 */
export const TwoFactorDuoStatus = new TwoFactorDuoStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorAddRequest$Type extends MessageType<TwoFactorAddRequest> {
  constructor() {
    super("Authentication.TwoFactorAddRequest", [
      {
        no: 1,
        name: "channelType",
        kind: "enum",
        T: () => ["Authentication.TwoFactorChannelType", TwoFactorChannelType],
      },
      { no: 2, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "channelName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "phoneNumber", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "duoPushType",
        kind: "enum",
        T: () => ["Authentication.TwoFactorPushType", TwoFactorPushType],
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorAddRequest>): TwoFactorAddRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.channelType = 0;
    message.channelUid = new Uint8Array(0);
    message.channelName = "";
    message.phoneNumber = "";
    message.duoPushType = 0;
    if (value !== undefined) reflectionMergePartial<TwoFactorAddRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorAddRequest,
  ): TwoFactorAddRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.TwoFactorChannelType channelType */ 1:
          message.channelType = reader.int32();
          break;
        case /* bytes channel_uid */ 2:
          message.channelUid = reader.bytes();
          break;
        case /* string channelName */ 3:
          message.channelName = reader.string();
          break;
        case /* string phoneNumber */ 4:
          message.phoneNumber = reader.string();
          break;
        case /* Authentication.TwoFactorPushType duoPushType */ 5:
          message.duoPushType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorAddRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.TwoFactorChannelType channelType = 1; */
    if (message.channelType !== 0) writer.tag(1, WireType.Varint).int32(message.channelType);
    /* bytes channel_uid = 2; */
    if (message.channelUid.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.channelUid);
    /* string channelName = 3; */
    if (message.channelName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.channelName);
    /* string phoneNumber = 4; */
    if (message.phoneNumber !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.phoneNumber);
    /* Authentication.TwoFactorPushType duoPushType = 5; */
    if (message.duoPushType !== 0) writer.tag(5, WireType.Varint).int32(message.duoPushType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorAddRequest
 */
export const TwoFactorAddRequest = new TwoFactorAddRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorRenameRequest$Type extends MessageType<TwoFactorRenameRequest> {
  constructor() {
    super("Authentication.TwoFactorRenameRequest", [
      { no: 1, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "channelName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<TwoFactorRenameRequest>): TwoFactorRenameRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.channelUid = new Uint8Array(0);
    message.channelName = "";
    if (value !== undefined) reflectionMergePartial<TwoFactorRenameRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorRenameRequest,
  ): TwoFactorRenameRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes channel_uid */ 1:
          message.channelUid = reader.bytes();
          break;
        case /* string channelName */ 2:
          message.channelName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorRenameRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes channel_uid = 1; */
    if (message.channelUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.channelUid);
    /* string channelName = 2; */
    if (message.channelName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.channelName);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorRenameRequest
 */
export const TwoFactorRenameRequest = new TwoFactorRenameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorAddResponse$Type extends MessageType<TwoFactorAddResponse> {
  constructor() {
    super("Authentication.TwoFactorAddResponse", [
      { no: 1, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "backupKeys",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorAddResponse>): TwoFactorAddResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.challenge = "";
    message.backupKeys = [];
    if (value !== undefined) reflectionMergePartial<TwoFactorAddResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorAddResponse,
  ): TwoFactorAddResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string challenge */ 1:
          message.challenge = reader.string();
          break;
        case /* repeated string backupKeys */ 2:
          message.backupKeys.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorAddResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string challenge = 1; */
    if (message.challenge !== "") writer.tag(1, WireType.LengthDelimited).string(message.challenge);
    /* repeated string backupKeys = 2; */
    for (let i = 0; i < message.backupKeys.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.backupKeys[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorAddResponse
 */
export const TwoFactorAddResponse = new TwoFactorAddResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorDeleteRequest$Type extends MessageType<TwoFactorDeleteRequest> {
  constructor() {
    super("Authentication.TwoFactorDeleteRequest", [
      { no: 1, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<TwoFactorDeleteRequest>): TwoFactorDeleteRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.channelUid = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<TwoFactorDeleteRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorDeleteRequest,
  ): TwoFactorDeleteRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes channel_uid */ 1:
          message.channelUid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorDeleteRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes channel_uid = 1; */
    if (message.channelUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.channelUid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorDeleteRequest
 */
export const TwoFactorDeleteRequest = new TwoFactorDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorListResponse$Type extends MessageType<TwoFactorListResponse> {
  constructor() {
    super("Authentication.TwoFactorListResponse", [
      {
        no: 1,
        name: "channels",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TwoFactorChannelInfo,
      },
      {
        no: 2,
        name: "expireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorListResponse>): TwoFactorListResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.channels = [];
    message.expireOn = BigInt(0);
    if (value !== undefined) reflectionMergePartial<TwoFactorListResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorListResponse,
  ): TwoFactorListResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.TwoFactorChannelInfo channels */ 1:
          message.channels.push(
            TwoFactorChannelInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int64 expireOn */ 2:
          message.expireOn = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorListResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.TwoFactorChannelInfo channels = 1; */
    for (let i = 0; i < message.channels.length; i++)
      TwoFactorChannelInfo.internalBinaryWrite(
        message.channels[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int64 expireOn = 2; */
    if (message.expireOn !== BigInt(0)) writer.tag(2, WireType.Varint).int64(message.expireOn);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorListResponse
 */
export const TwoFactorListResponse = new TwoFactorListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorUpdateExpirationRequest$Type extends MessageType<TwoFactorUpdateExpirationRequest> {
  constructor() {
    super("Authentication.TwoFactorUpdateExpirationRequest", [
      {
        no: 1,
        name: "expireIn",
        kind: "enum",
        T: () => ["Authentication.TwoFactorExpiration", TwoFactorExpiration],
      },
    ]);
  }
  create(
    value?: PartialMessage<TwoFactorUpdateExpirationRequest>,
  ): TwoFactorUpdateExpirationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.expireIn = 0;
    if (value !== undefined)
      reflectionMergePartial<TwoFactorUpdateExpirationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorUpdateExpirationRequest,
  ): TwoFactorUpdateExpirationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.TwoFactorExpiration expireIn */ 1:
          message.expireIn = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorUpdateExpirationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.TwoFactorExpiration expireIn = 1; */
    if (message.expireIn !== 0) writer.tag(1, WireType.Varint).int32(message.expireIn);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorUpdateExpirationRequest
 */
export const TwoFactorUpdateExpirationRequest = new TwoFactorUpdateExpirationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorValidateRequest$Type extends MessageType<TwoFactorValidateRequest> {
  constructor() {
    super("Authentication.TwoFactorValidateRequest", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "valueType",
        kind: "enum",
        T: () => ["Authentication.TwoFactorValueType", TwoFactorValueType],
      },
      { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "expireIn",
        kind: "enum",
        T: () => ["Authentication.TwoFactorExpiration", TwoFactorExpiration],
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorValidateRequest>): TwoFactorValidateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    message.valueType = 0;
    message.value = "";
    message.channelUid = new Uint8Array(0);
    message.expireIn = 0;
    if (value !== undefined) reflectionMergePartial<TwoFactorValidateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorValidateRequest,
  ): TwoFactorValidateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* Authentication.TwoFactorValueType valueType */ 2:
          message.valueType = reader.int32();
          break;
        case /* string value */ 3:
          message.value = reader.string();
          break;
        case /* bytes channel_uid */ 4:
          message.channelUid = reader.bytes();
          break;
        case /* Authentication.TwoFactorExpiration expireIn */ 5:
          message.expireIn = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorValidateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* Authentication.TwoFactorValueType valueType = 2; */
    if (message.valueType !== 0) writer.tag(2, WireType.Varint).int32(message.valueType);
    /* string value = 3; */
    if (message.value !== "") writer.tag(3, WireType.LengthDelimited).string(message.value);
    /* bytes channel_uid = 4; */
    if (message.channelUid.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.channelUid);
    /* Authentication.TwoFactorExpiration expireIn = 5; */
    if (message.expireIn !== 0) writer.tag(5, WireType.Varint).int32(message.expireIn);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorValidateRequest
 */
export const TwoFactorValidateRequest = new TwoFactorValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorValidateResponse$Type extends MessageType<TwoFactorValidateResponse> {
  constructor() {
    super("Authentication.TwoFactorValidateResponse", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<TwoFactorValidateResponse>): TwoFactorValidateResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<TwoFactorValidateResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorValidateResponse,
  ): TwoFactorValidateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorValidateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorValidateResponse
 */
export const TwoFactorValidateResponse = new TwoFactorValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwoFactorSendPushRequest$Type extends MessageType<TwoFactorSendPushRequest> {
  constructor() {
    super("Authentication.TwoFactorSendPushRequest", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "pushType",
        kind: "enum",
        T: () => ["Authentication.TwoFactorPushType", TwoFactorPushType],
      },
      { no: 3, name: "channel_uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 4,
        name: "expireIn",
        kind: "enum",
        T: () => ["Authentication.TwoFactorExpiration", TwoFactorExpiration],
      },
    ]);
  }
  create(value?: PartialMessage<TwoFactorSendPushRequest>): TwoFactorSendPushRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    message.pushType = 0;
    message.channelUid = new Uint8Array(0);
    message.expireIn = 0;
    if (value !== undefined) reflectionMergePartial<TwoFactorSendPushRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwoFactorSendPushRequest,
  ): TwoFactorSendPushRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* Authentication.TwoFactorPushType pushType */ 2:
          message.pushType = reader.int32();
          break;
        case /* bytes channel_uid */ 3:
          message.channelUid = reader.bytes();
          break;
        case /* Authentication.TwoFactorExpiration expireIn */ 4:
          message.expireIn = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TwoFactorSendPushRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* Authentication.TwoFactorPushType pushType = 2; */
    if (message.pushType !== 0) writer.tag(2, WireType.Varint).int32(message.pushType);
    /* bytes channel_uid = 3; */
    if (message.channelUid.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.channelUid);
    /* Authentication.TwoFactorExpiration expireIn = 4; */
    if (message.expireIn !== 0) writer.tag(4, WireType.Varint).int32(message.expireIn);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TwoFactorSendPushRequest
 */
export const TwoFactorSendPushRequest = new TwoFactorSendPushRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class License$Type extends MessageType<License> {
  constructor() {
    super("Authentication.License", [
      {
        no: 1,
        name: "created",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "expiration",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "licenseStatus",
        kind: "enum",
        T: () => ["Authentication.LicenseStatus", LicenseStatus],
      },
      { no: 4, name: "paid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<License>): License {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.created = BigInt(0);
    message.expiration = BigInt(0);
    message.licenseStatus = 0;
    message.paid = false;
    message.message = "";
    if (value !== undefined) reflectionMergePartial<License>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: License,
  ): License {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 created */ 1:
          message.created = reader.int64().toBigInt();
          break;
        case /* int64 expiration */ 2:
          message.expiration = reader.int64().toBigInt();
          break;
        case /* Authentication.LicenseStatus licenseStatus */ 3:
          message.licenseStatus = reader.int32();
          break;
        case /* bool paid */ 4:
          message.paid = reader.bool();
          break;
        case /* string message */ 5:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: License,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 created = 1; */
    if (message.created !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.created);
    /* int64 expiration = 2; */
    if (message.expiration !== BigInt(0)) writer.tag(2, WireType.Varint).int64(message.expiration);
    /* Authentication.LicenseStatus licenseStatus = 3; */
    if (message.licenseStatus !== 0) writer.tag(3, WireType.Varint).int32(message.licenseStatus);
    /* bool paid = 4; */
    if (message.paid !== false) writer.tag(4, WireType.Varint).bool(message.paid);
    /* string message = 5; */
    if (message.message !== "") writer.tag(5, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.License
 */
export const License = new License$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnerlessRecord$Type extends MessageType<OwnerlessRecord> {
  constructor() {
    super("Authentication.OwnerlessRecord", [
      { no: 1, name: "recordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "recordKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<OwnerlessRecord>): OwnerlessRecord {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recordUid = new Uint8Array(0);
    message.recordKey = new Uint8Array(0);
    message.status = 0;
    if (value !== undefined) reflectionMergePartial<OwnerlessRecord>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OwnerlessRecord,
  ): OwnerlessRecord {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes recordUid */ 1:
          message.recordUid = reader.bytes();
          break;
        case /* bytes recordKey */ 2:
          message.recordKey = reader.bytes();
          break;
        case /* int32 status */ 3:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: OwnerlessRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes recordUid = 1; */
    if (message.recordUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.recordUid);
    /* bytes recordKey = 2; */
    if (message.recordKey.length) writer.tag(2, WireType.LengthDelimited).bytes(message.recordKey);
    /* int32 status = 3; */
    if (message.status !== 0) writer.tag(3, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.OwnerlessRecord
 */
export const OwnerlessRecord = new OwnerlessRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnerlessRecords$Type extends MessageType<OwnerlessRecords> {
  constructor() {
    super("Authentication.OwnerlessRecords", [
      {
        no: 1,
        name: "ownerlessRecord",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => OwnerlessRecord,
      },
    ]);
  }
  create(value?: PartialMessage<OwnerlessRecords>): OwnerlessRecords {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ownerlessRecord = [];
    if (value !== undefined) reflectionMergePartial<OwnerlessRecords>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OwnerlessRecords,
  ): OwnerlessRecords {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.OwnerlessRecord ownerlessRecord */ 1:
          message.ownerlessRecord.push(
            OwnerlessRecord.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: OwnerlessRecords,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.OwnerlessRecord ownerlessRecord = 1; */
    for (let i = 0; i < message.ownerlessRecord.length; i++)
      OwnerlessRecord.internalBinaryWrite(
        message.ownerlessRecord[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.OwnerlessRecords
 */
export const OwnerlessRecords = new OwnerlessRecords$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserAuthRequest$Type extends MessageType<UserAuthRequest> {
  constructor() {
    super("Authentication.UserAuthRequest", [
      { no: 1, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "iterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "encryptedClientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "authHash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "encryptedDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 7, name: "loginType", kind: "enum", T: () => ["Authentication.LoginType", LoginType] },
      { no: 8, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: "algorithm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<UserAuthRequest>): UserAuthRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = new Uint8Array(0);
    message.salt = new Uint8Array(0);
    message.iterations = 0;
    message.encryptedClientKey = new Uint8Array(0);
    message.authHash = new Uint8Array(0);
    message.encryptedDataKey = new Uint8Array(0);
    message.loginType = 0;
    message.name = "";
    message.algorithm = 0;
    if (value !== undefined) reflectionMergePartial<UserAuthRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserAuthRequest,
  ): UserAuthRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes uid */ 1:
          message.uid = reader.bytes();
          break;
        case /* bytes salt */ 2:
          message.salt = reader.bytes();
          break;
        case /* int32 iterations */ 3:
          message.iterations = reader.int32();
          break;
        case /* bytes encryptedClientKey */ 4:
          message.encryptedClientKey = reader.bytes();
          break;
        case /* bytes authHash */ 5:
          message.authHash = reader.bytes();
          break;
        case /* bytes encryptedDataKey */ 6:
          message.encryptedDataKey = reader.bytes();
          break;
        case /* Authentication.LoginType loginType */ 7:
          message.loginType = reader.int32();
          break;
        case /* string name */ 8:
          message.name = reader.string();
          break;
        case /* int32 algorithm */ 9:
          message.algorithm = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserAuthRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes uid = 1; */
    if (message.uid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uid);
    /* bytes salt = 2; */
    if (message.salt.length) writer.tag(2, WireType.LengthDelimited).bytes(message.salt);
    /* int32 iterations = 3; */
    if (message.iterations !== 0) writer.tag(3, WireType.Varint).int32(message.iterations);
    /* bytes encryptedClientKey = 4; */
    if (message.encryptedClientKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedClientKey);
    /* bytes authHash = 5; */
    if (message.authHash.length) writer.tag(5, WireType.LengthDelimited).bytes(message.authHash);
    /* bytes encryptedDataKey = 6; */
    if (message.encryptedDataKey.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.encryptedDataKey);
    /* Authentication.LoginType loginType = 7; */
    if (message.loginType !== 0) writer.tag(7, WireType.Varint).int32(message.loginType);
    /* string name = 8; */
    if (message.name !== "") writer.tag(8, WireType.LengthDelimited).string(message.name);
    /* int32 algorithm = 9; */
    if (message.algorithm !== 0) writer.tag(9, WireType.Varint).int32(message.algorithm);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserAuthRequest
 */
export const UserAuthRequest = new UserAuthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidRequest$Type extends MessageType<UidRequest> {
  constructor() {
    super("Authentication.UidRequest", [
      {
        no: 1,
        name: "uid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<UidRequest>): UidRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = [];
    if (value !== undefined) reflectionMergePartial<UidRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UidRequest,
  ): UidRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes uid */ 1:
          message.uid.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UidRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes uid = 1; */
    for (let i = 0; i < message.uid.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.uid[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UidRequest
 */
export const UidRequest = new UidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceUpdateRequest$Type extends MessageType<DeviceUpdateRequest> {
  constructor() {
    super("Authentication.DeviceUpdateRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "devicePublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "deviceStatus",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
      { no: 6, name: "devicePlatform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 7,
        name: "clientFormFactor",
        kind: "enum",
        T: () => ["Authentication.ClientFormFactor", ClientFormFactor],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceUpdateRequest>): DeviceUpdateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.clientVersion = "";
    message.deviceName = "";
    message.devicePublicKey = new Uint8Array(0);
    message.deviceStatus = 0;
    message.devicePlatform = "";
    message.clientFormFactor = 0;
    if (value !== undefined) reflectionMergePartial<DeviceUpdateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceUpdateRequest,
  ): DeviceUpdateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string deviceName */ 3:
          message.deviceName = reader.string();
          break;
        case /* bytes devicePublicKey */ 4:
          message.devicePublicKey = reader.bytes();
          break;
        case /* Authentication.DeviceStatus deviceStatus */ 5:
          message.deviceStatus = reader.int32();
          break;
        case /* string devicePlatform */ 6:
          message.devicePlatform = reader.string();
          break;
        case /* Authentication.ClientFormFactor clientFormFactor */ 7:
          message.clientFormFactor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceUpdateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string deviceName = 3; */
    if (message.deviceName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.deviceName);
    /* bytes devicePublicKey = 4; */
    if (message.devicePublicKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.devicePublicKey);
    /* Authentication.DeviceStatus deviceStatus = 5; */
    if (message.deviceStatus !== 0) writer.tag(5, WireType.Varint).int32(message.deviceStatus);
    /* string devicePlatform = 6; */
    if (message.devicePlatform !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.devicePlatform);
    /* Authentication.ClientFormFactor clientFormFactor = 7; */
    if (message.clientFormFactor !== 0)
      writer.tag(7, WireType.Varint).int32(message.clientFormFactor);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceUpdateRequest
 */
export const DeviceUpdateRequest = new DeviceUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceUpdateResponse$Type extends MessageType<DeviceUpdateResponse> {
  constructor() {
    super("Authentication.DeviceUpdateResponse", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "devicePublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "deviceStatus",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
      { no: 6, name: "devicePlatform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 7,
        name: "clientFormFactor",
        kind: "enum",
        T: () => ["Authentication.ClientFormFactor", ClientFormFactor],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceUpdateResponse>): DeviceUpdateResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.clientVersion = "";
    message.deviceName = "";
    message.devicePublicKey = new Uint8Array(0);
    message.deviceStatus = 0;
    message.devicePlatform = "";
    message.clientFormFactor = 0;
    if (value !== undefined) reflectionMergePartial<DeviceUpdateResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceUpdateResponse,
  ): DeviceUpdateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string deviceName */ 3:
          message.deviceName = reader.string();
          break;
        case /* bytes devicePublicKey */ 4:
          message.devicePublicKey = reader.bytes();
          break;
        case /* Authentication.DeviceStatus deviceStatus */ 5:
          message.deviceStatus = reader.int32();
          break;
        case /* string devicePlatform */ 6:
          message.devicePlatform = reader.string();
          break;
        case /* Authentication.ClientFormFactor clientFormFactor */ 7:
          message.clientFormFactor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceUpdateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string deviceName = 3; */
    if (message.deviceName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.deviceName);
    /* bytes devicePublicKey = 4; */
    if (message.devicePublicKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.devicePublicKey);
    /* Authentication.DeviceStatus deviceStatus = 5; */
    if (message.deviceStatus !== 0) writer.tag(5, WireType.Varint).int32(message.deviceStatus);
    /* string devicePlatform = 6; */
    if (message.devicePlatform !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.devicePlatform);
    /* Authentication.ClientFormFactor clientFormFactor = 7; */
    if (message.clientFormFactor !== 0)
      writer.tag(7, WireType.Varint).int32(message.clientFormFactor);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceUpdateResponse
 */
export const DeviceUpdateResponse = new DeviceUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterDeviceInRegionRequest$Type extends MessageType<RegisterDeviceInRegionRequest> {
  constructor() {
    super("Authentication.RegisterDeviceInRegionRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "devicePublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "devicePlatform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 6,
        name: "clientFormFactor",
        kind: "enum",
        T: () => ["Authentication.ClientFormFactor", ClientFormFactor],
      },
    ]);
  }
  create(value?: PartialMessage<RegisterDeviceInRegionRequest>): RegisterDeviceInRegionRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.clientVersion = "";
    message.deviceName = "";
    message.devicePublicKey = new Uint8Array(0);
    message.devicePlatform = "";
    message.clientFormFactor = 0;
    if (value !== undefined)
      reflectionMergePartial<RegisterDeviceInRegionRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegisterDeviceInRegionRequest,
  ): RegisterDeviceInRegionRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string deviceName */ 3:
          message.deviceName = reader.string();
          break;
        case /* bytes devicePublicKey */ 4:
          message.devicePublicKey = reader.bytes();
          break;
        case /* string devicePlatform */ 5:
          message.devicePlatform = reader.string();
          break;
        case /* Authentication.ClientFormFactor clientFormFactor */ 6:
          message.clientFormFactor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RegisterDeviceInRegionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string deviceName = 3; */
    if (message.deviceName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.deviceName);
    /* bytes devicePublicKey = 4; */
    if (message.devicePublicKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.devicePublicKey);
    /* string devicePlatform = 5; */
    if (message.devicePlatform !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.devicePlatform);
    /* Authentication.ClientFormFactor clientFormFactor = 6; */
    if (message.clientFormFactor !== 0)
      writer.tag(6, WireType.Varint).int32(message.clientFormFactor);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RegisterDeviceInRegionRequest
 */
export const RegisterDeviceInRegionRequest = new RegisterDeviceInRegionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationRequest$Type extends MessageType<RegistrationRequest> {
  constructor() {
    super("Authentication.RegistrationRequest", [
      { no: 1, name: "authRequest", kind: "message", T: () => AuthRequest },
      { no: 2, name: "userAuthRequest", kind: "message", T: () => UserAuthRequest },
      { no: 3, name: "encryptedClientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "encryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: "deprecatedAuthHashHash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 8, name: "deprecatedEncryptedClientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 9, name: "deprecatedEncryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 10, name: "deprecatedEncryptionParams", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<RegistrationRequest>): RegistrationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedClientKey = new Uint8Array(0);
    message.encryptedPrivateKey = new Uint8Array(0);
    message.publicKey = new Uint8Array(0);
    message.verificationCode = "";
    message.deprecatedAuthHashHash = new Uint8Array(0);
    message.deprecatedEncryptedClientKey = new Uint8Array(0);
    message.deprecatedEncryptedPrivateKey = new Uint8Array(0);
    message.deprecatedEncryptionParams = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<RegistrationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegistrationRequest,
  ): RegistrationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.AuthRequest authRequest */ 1:
          message.authRequest = AuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authRequest,
          );
          break;
        case /* Authentication.UserAuthRequest userAuthRequest */ 2:
          message.userAuthRequest = UserAuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.userAuthRequest,
          );
          break;
        case /* bytes encryptedClientKey */ 3:
          message.encryptedClientKey = reader.bytes();
          break;
        case /* bytes encryptedPrivateKey */ 4:
          message.encryptedPrivateKey = reader.bytes();
          break;
        case /* bytes publicKey */ 5:
          message.publicKey = reader.bytes();
          break;
        case /* string verificationCode */ 6:
          message.verificationCode = reader.string();
          break;
        case /* bytes deprecatedAuthHashHash */ 7:
          message.deprecatedAuthHashHash = reader.bytes();
          break;
        case /* bytes deprecatedEncryptedClientKey */ 8:
          message.deprecatedEncryptedClientKey = reader.bytes();
          break;
        case /* bytes deprecatedEncryptedPrivateKey */ 9:
          message.deprecatedEncryptedPrivateKey = reader.bytes();
          break;
        case /* bytes deprecatedEncryptionParams */ 10:
          message.deprecatedEncryptionParams = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RegistrationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthRequest authRequest = 1; */
    if (message.authRequest)
      AuthRequest.internalBinaryWrite(
        message.authRequest,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Authentication.UserAuthRequest userAuthRequest = 2; */
    if (message.userAuthRequest)
      UserAuthRequest.internalBinaryWrite(
        message.userAuthRequest,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes encryptedClientKey = 3; */
    if (message.encryptedClientKey.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptedClientKey);
    /* bytes encryptedPrivateKey = 4; */
    if (message.encryptedPrivateKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedPrivateKey);
    /* bytes publicKey = 5; */
    if (message.publicKey.length) writer.tag(5, WireType.LengthDelimited).bytes(message.publicKey);
    /* string verificationCode = 6; */
    if (message.verificationCode !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.verificationCode);
    /* bytes deprecatedAuthHashHash = 7; */
    if (message.deprecatedAuthHashHash.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.deprecatedAuthHashHash);
    /* bytes deprecatedEncryptedClientKey = 8; */
    if (message.deprecatedEncryptedClientKey.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.deprecatedEncryptedClientKey);
    /* bytes deprecatedEncryptedPrivateKey = 9; */
    if (message.deprecatedEncryptedPrivateKey.length)
      writer.tag(9, WireType.LengthDelimited).bytes(message.deprecatedEncryptedPrivateKey);
    /* bytes deprecatedEncryptionParams = 10; */
    if (message.deprecatedEncryptionParams.length)
      writer.tag(10, WireType.LengthDelimited).bytes(message.deprecatedEncryptionParams);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RegistrationRequest
 */
export const RegistrationRequest = new RegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConvertUserToV3Request$Type extends MessageType<ConvertUserToV3Request> {
  constructor() {
    super("Authentication.ConvertUserToV3Request", [
      { no: 1, name: "authRequest", kind: "message", T: () => AuthRequest },
      { no: 2, name: "userAuthRequest", kind: "message", T: () => UserAuthRequest },
      { no: 3, name: "encryptedClientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "encryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ConvertUserToV3Request>): ConvertUserToV3Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedClientKey = new Uint8Array(0);
    message.encryptedPrivateKey = new Uint8Array(0);
    message.publicKey = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<ConvertUserToV3Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ConvertUserToV3Request,
  ): ConvertUserToV3Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.AuthRequest authRequest */ 1:
          message.authRequest = AuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authRequest,
          );
          break;
        case /* Authentication.UserAuthRequest userAuthRequest */ 2:
          message.userAuthRequest = UserAuthRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.userAuthRequest,
          );
          break;
        case /* bytes encryptedClientKey */ 3:
          message.encryptedClientKey = reader.bytes();
          break;
        case /* bytes encryptedPrivateKey */ 4:
          message.encryptedPrivateKey = reader.bytes();
          break;
        case /* bytes publicKey */ 5:
          message.publicKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ConvertUserToV3Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthRequest authRequest = 1; */
    if (message.authRequest)
      AuthRequest.internalBinaryWrite(
        message.authRequest,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Authentication.UserAuthRequest userAuthRequest = 2; */
    if (message.userAuthRequest)
      UserAuthRequest.internalBinaryWrite(
        message.userAuthRequest,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes encryptedClientKey = 3; */
    if (message.encryptedClientKey.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptedClientKey);
    /* bytes encryptedPrivateKey = 4; */
    if (message.encryptedPrivateKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedPrivateKey);
    /* bytes publicKey = 5; */
    if (message.publicKey.length) writer.tag(5, WireType.LengthDelimited).bytes(message.publicKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ConvertUserToV3Request
 */
export const ConvertUserToV3Request = new ConvertUserToV3Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevisionResponse$Type extends MessageType<RevisionResponse> {
  constructor() {
    super("Authentication.RevisionResponse", [
      {
        no: 1,
        name: "revision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<RevisionResponse>): RevisionResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.revision = BigInt(0);
    if (value !== undefined) reflectionMergePartial<RevisionResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RevisionResponse,
  ): RevisionResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 revision */ 1:
          message.revision = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RevisionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 revision = 1; */
    if (message.revision !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.revision);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RevisionResponse
 */
export const RevisionResponse = new RevisionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeEmailRequest$Type extends MessageType<ChangeEmailRequest> {
  constructor() {
    super("Authentication.ChangeEmailRequest", [
      { no: 1, name: "newEmail", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeEmailRequest>): ChangeEmailRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.newEmail = "";
    if (value !== undefined) reflectionMergePartial<ChangeEmailRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeEmailRequest,
  ): ChangeEmailRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string newEmail */ 1:
          message.newEmail = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeEmailRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string newEmail = 1; */
    if (message.newEmail !== "") writer.tag(1, WireType.LengthDelimited).string(message.newEmail);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeEmailRequest
 */
export const ChangeEmailRequest = new ChangeEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeEmailResponse$Type extends MessageType<ChangeEmailResponse> {
  constructor() {
    super("Authentication.ChangeEmailResponse", [
      { no: 1, name: "encryptedChangeEmailToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeEmailResponse>): ChangeEmailResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedChangeEmailToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<ChangeEmailResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeEmailResponse,
  ): ChangeEmailResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedChangeEmailToken */ 1:
          message.encryptedChangeEmailToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeEmailResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedChangeEmailToken = 1; */
    if (message.encryptedChangeEmailToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedChangeEmailToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeEmailResponse
 */
export const ChangeEmailResponse = new ChangeEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmailVerificationLinkResponse$Type extends MessageType<EmailVerificationLinkResponse> {
  constructor() {
    super("Authentication.EmailVerificationLinkResponse", [
      { no: 1, name: "emailVerified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<EmailVerificationLinkResponse>): EmailVerificationLinkResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.emailVerified = false;
    if (value !== undefined)
      reflectionMergePartial<EmailVerificationLinkResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EmailVerificationLinkResponse,
  ): EmailVerificationLinkResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool emailVerified */ 1:
          message.emailVerified = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EmailVerificationLinkResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool emailVerified = 1; */
    if (message.emailVerified !== false) writer.tag(1, WireType.Varint).bool(message.emailVerified);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EmailVerificationLinkResponse
 */
export const EmailVerificationLinkResponse = new EmailVerificationLinkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityData$Type extends MessageType<SecurityData> {
  constructor() {
    super("Authentication.SecurityData", [
      { no: 1, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SecurityData>): SecurityData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = new Uint8Array(0);
    message.data = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<SecurityData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityData,
  ): SecurityData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes uid */ 1:
          message.uid = reader.bytes();
          break;
        case /* bytes data */ 2:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes uid = 1; */
    if (message.uid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uid);
    /* bytes data = 2; */
    if (message.data.length) writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityData
 */
export const SecurityData = new SecurityData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityScoreData$Type extends MessageType<SecurityScoreData> {
  constructor() {
    super("Authentication.SecurityScoreData", [
      { no: 1, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "revision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<SecurityScoreData>): SecurityScoreData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = new Uint8Array(0);
    message.data = new Uint8Array(0);
    message.revision = BigInt(0);
    if (value !== undefined) reflectionMergePartial<SecurityScoreData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityScoreData,
  ): SecurityScoreData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes uid */ 1:
          message.uid = reader.bytes();
          break;
        case /* bytes data */ 2:
          message.data = reader.bytes();
          break;
        case /* int64 revision */ 3:
          message.revision = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityScoreData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes uid = 1; */
    if (message.uid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uid);
    /* bytes data = 2; */
    if (message.data.length) writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    /* int64 revision = 3; */
    if (message.revision !== BigInt(0)) writer.tag(3, WireType.Varint).int64(message.revision);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityScoreData
 */
export const SecurityScoreData = new SecurityScoreData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityDataRequest$Type extends MessageType<SecurityDataRequest> {
  constructor() {
    super("Authentication.SecurityDataRequest", [
      {
        no: 1,
        name: "recordSecurityData",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityData,
      },
      {
        no: 2,
        name: "masterPasswordSecurityData",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityData,
      },
      {
        no: 3,
        name: "encryptionType",
        kind: "enum",
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
      {
        no: 4,
        name: "recordSecurityScoreData",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityScoreData,
      },
    ]);
  }
  create(value?: PartialMessage<SecurityDataRequest>): SecurityDataRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recordSecurityData = [];
    message.masterPasswordSecurityData = [];
    message.encryptionType = 0;
    message.recordSecurityScoreData = [];
    if (value !== undefined) reflectionMergePartial<SecurityDataRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityDataRequest,
  ): SecurityDataRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.SecurityData recordSecurityData */ 1:
          message.recordSecurityData.push(
            SecurityData.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated Authentication.SecurityData masterPasswordSecurityData */ 2:
          message.masterPasswordSecurityData.push(
            SecurityData.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* Enterprise.EncryptedKeyType encryptionType */ 3:
          message.encryptionType = reader.int32();
          break;
        case /* repeated Authentication.SecurityScoreData recordSecurityScoreData */ 4:
          message.recordSecurityScoreData.push(
            SecurityScoreData.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityDataRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.SecurityData recordSecurityData = 1; */
    for (let i = 0; i < message.recordSecurityData.length; i++)
      SecurityData.internalBinaryWrite(
        message.recordSecurityData[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.SecurityData masterPasswordSecurityData = 2; */
    for (let i = 0; i < message.masterPasswordSecurityData.length; i++)
      SecurityData.internalBinaryWrite(
        message.masterPasswordSecurityData[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Enterprise.EncryptedKeyType encryptionType = 3; */
    if (message.encryptionType !== 0) writer.tag(3, WireType.Varint).int32(message.encryptionType);
    /* repeated Authentication.SecurityScoreData recordSecurityScoreData = 4; */
    for (let i = 0; i < message.recordSecurityScoreData.length; i++)
      SecurityScoreData.internalBinaryWrite(
        message.recordSecurityScoreData[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityDataRequest
 */
export const SecurityDataRequest = new SecurityDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReportIncrementalData$Type extends MessageType<SecurityReportIncrementalData> {
  constructor() {
    super("Authentication.SecurityReportIncrementalData", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "currentSecurityData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "currentSecurityDataRevision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 4, name: "oldSecurityData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "oldSecurityDataRevision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "currentDataEncryptionType",
        kind: "enum",
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
      {
        no: 7,
        name: "oldDataEncryptionType",
        kind: "enum",
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
      { no: 8, name: "recordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SecurityReportIncrementalData>): SecurityReportIncrementalData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.currentSecurityData = new Uint8Array(0);
    message.currentSecurityDataRevision = BigInt(0);
    message.oldSecurityData = new Uint8Array(0);
    message.oldSecurityDataRevision = BigInt(0);
    message.currentDataEncryptionType = 0;
    message.oldDataEncryptionType = 0;
    message.recordUid = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<SecurityReportIncrementalData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityReportIncrementalData,
  ): SecurityReportIncrementalData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* bytes currentSecurityData */ 2:
          message.currentSecurityData = reader.bytes();
          break;
        case /* int64 currentSecurityDataRevision */ 3:
          message.currentSecurityDataRevision = reader.int64().toBigInt();
          break;
        case /* bytes oldSecurityData */ 4:
          message.oldSecurityData = reader.bytes();
          break;
        case /* int64 oldSecurityDataRevision */ 5:
          message.oldSecurityDataRevision = reader.int64().toBigInt();
          break;
        case /* Enterprise.EncryptedKeyType currentDataEncryptionType */ 6:
          message.currentDataEncryptionType = reader.int32();
          break;
        case /* Enterprise.EncryptedKeyType oldDataEncryptionType */ 7:
          message.oldDataEncryptionType = reader.int32();
          break;
        case /* bytes recordUid */ 8:
          message.recordUid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityReportIncrementalData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* bytes currentSecurityData = 2; */
    if (message.currentSecurityData.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.currentSecurityData);
    /* int64 currentSecurityDataRevision = 3; */
    if (message.currentSecurityDataRevision !== BigInt(0))
      writer.tag(3, WireType.Varint).int64(message.currentSecurityDataRevision);
    /* bytes oldSecurityData = 4; */
    if (message.oldSecurityData.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.oldSecurityData);
    /* int64 oldSecurityDataRevision = 5; */
    if (message.oldSecurityDataRevision !== BigInt(0))
      writer.tag(5, WireType.Varint).int64(message.oldSecurityDataRevision);
    /* Enterprise.EncryptedKeyType currentDataEncryptionType = 6; */
    if (message.currentDataEncryptionType !== 0)
      writer.tag(6, WireType.Varint).int32(message.currentDataEncryptionType);
    /* Enterprise.EncryptedKeyType oldDataEncryptionType = 7; */
    if (message.oldDataEncryptionType !== 0)
      writer.tag(7, WireType.Varint).int32(message.oldDataEncryptionType);
    /* bytes recordUid = 8; */
    if (message.recordUid.length) writer.tag(8, WireType.LengthDelimited).bytes(message.recordUid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityReportIncrementalData
 */
export const SecurityReportIncrementalData = new SecurityReportIncrementalData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReport$Type extends MessageType<SecurityReport> {
  constructor() {
    super("Authentication.SecurityReport", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "encryptedReportData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "revision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 4, name: "twoFactor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "lastLogin",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 6, name: "numberOfReusedPassword", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 7,
        name: "securityReportIncrementalData",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityReportIncrementalData,
      },
      { no: 8, name: "userId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: "hasOldEncryption", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<SecurityReport>): SecurityReport {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.encryptedReportData = new Uint8Array(0);
    message.revision = BigInt(0);
    message.twoFactor = "";
    message.lastLogin = BigInt(0);
    message.numberOfReusedPassword = 0;
    message.securityReportIncrementalData = [];
    message.userId = 0;
    message.hasOldEncryption = false;
    if (value !== undefined) reflectionMergePartial<SecurityReport>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityReport,
  ): SecurityReport {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* bytes encryptedReportData */ 2:
          message.encryptedReportData = reader.bytes();
          break;
        case /* int64 revision */ 3:
          message.revision = reader.int64().toBigInt();
          break;
        case /* string twoFactor */ 4:
          message.twoFactor = reader.string();
          break;
        case /* int64 lastLogin */ 5:
          message.lastLogin = reader.int64().toBigInt();
          break;
        case /* int32 numberOfReusedPassword */ 6:
          message.numberOfReusedPassword = reader.int32();
          break;
        case /* repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData */ 7:
          message.securityReportIncrementalData.push(
            SecurityReportIncrementalData.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int32 userId */ 8:
          message.userId = reader.int32();
          break;
        case /* bool hasOldEncryption */ 9:
          message.hasOldEncryption = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityReport,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* bytes encryptedReportData = 2; */
    if (message.encryptedReportData.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedReportData);
    /* int64 revision = 3; */
    if (message.revision !== BigInt(0)) writer.tag(3, WireType.Varint).int64(message.revision);
    /* string twoFactor = 4; */
    if (message.twoFactor !== "") writer.tag(4, WireType.LengthDelimited).string(message.twoFactor);
    /* int64 lastLogin = 5; */
    if (message.lastLogin !== BigInt(0)) writer.tag(5, WireType.Varint).int64(message.lastLogin);
    /* int32 numberOfReusedPassword = 6; */
    if (message.numberOfReusedPassword !== 0)
      writer.tag(6, WireType.Varint).int32(message.numberOfReusedPassword);
    /* repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData = 7; */
    for (let i = 0; i < message.securityReportIncrementalData.length; i++)
      SecurityReportIncrementalData.internalBinaryWrite(
        message.securityReportIncrementalData[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 userId = 8; */
    if (message.userId !== 0) writer.tag(8, WireType.Varint).int32(message.userId);
    /* bool hasOldEncryption = 9; */
    if (message.hasOldEncryption !== false)
      writer.tag(9, WireType.Varint).bool(message.hasOldEncryption);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityReport
 */
export const SecurityReport = new SecurityReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReportSaveRequest$Type extends MessageType<SecurityReportSaveRequest> {
  constructor() {
    super("Authentication.SecurityReportSaveRequest", [
      {
        no: 1,
        name: "securityReport",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityReport,
      },
      { no: 2, name: "continuationToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SecurityReportSaveRequest>): SecurityReportSaveRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.securityReport = [];
    message.continuationToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<SecurityReportSaveRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityReportSaveRequest,
  ): SecurityReportSaveRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.SecurityReport securityReport */ 1:
          message.securityReport.push(
            SecurityReport.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bytes continuationToken */ 2:
          message.continuationToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityReportSaveRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.SecurityReport securityReport = 1; */
    for (let i = 0; i < message.securityReport.length; i++)
      SecurityReport.internalBinaryWrite(
        message.securityReport[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes continuationToken = 2; */
    if (message.continuationToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.continuationToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityReportSaveRequest
 */
export const SecurityReportSaveRequest = new SecurityReportSaveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReportRequest$Type extends MessageType<SecurityReportRequest> {
  constructor() {
    super("Authentication.SecurityReportRequest", [
      {
        no: 1,
        name: "fromPage",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<SecurityReportRequest>): SecurityReportRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.fromPage = BigInt(0);
    if (value !== undefined) reflectionMergePartial<SecurityReportRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityReportRequest,
  ): SecurityReportRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 fromPage */ 1:
          message.fromPage = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityReportRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 fromPage = 1; */
    if (message.fromPage !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.fromPage);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityReportRequest
 */
export const SecurityReportRequest = new SecurityReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityReportResponse$Type extends MessageType<SecurityReportResponse> {
  constructor() {
    super("Authentication.SecurityReportResponse", [
      { no: 1, name: "enterprisePrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "securityReport",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityReport,
      },
      {
        no: 3,
        name: "asOfRevision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "fromPage",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 5,
        name: "toPage",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 6, name: "complete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 7, name: "enterpriseEccPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 8, name: "hasIncrementalData", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<SecurityReportResponse>): SecurityReportResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterprisePrivateKey = new Uint8Array(0);
    message.securityReport = [];
    message.asOfRevision = BigInt(0);
    message.fromPage = BigInt(0);
    message.toPage = BigInt(0);
    message.complete = false;
    message.enterpriseEccPrivateKey = new Uint8Array(0);
    message.hasIncrementalData = false;
    if (value !== undefined) reflectionMergePartial<SecurityReportResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SecurityReportResponse,
  ): SecurityReportResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes enterprisePrivateKey */ 1:
          message.enterprisePrivateKey = reader.bytes();
          break;
        case /* repeated Authentication.SecurityReport securityReport */ 2:
          message.securityReport.push(
            SecurityReport.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int64 asOfRevision */ 3:
          message.asOfRevision = reader.int64().toBigInt();
          break;
        case /* int64 fromPage */ 4:
          message.fromPage = reader.int64().toBigInt();
          break;
        case /* int64 toPage */ 5:
          message.toPage = reader.int64().toBigInt();
          break;
        case /* bool complete */ 6:
          message.complete = reader.bool();
          break;
        case /* bytes enterpriseEccPrivateKey */ 7:
          message.enterpriseEccPrivateKey = reader.bytes();
          break;
        case /* bool hasIncrementalData */ 8:
          message.hasIncrementalData = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SecurityReportResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes enterprisePrivateKey = 1; */
    if (message.enterprisePrivateKey.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.enterprisePrivateKey);
    /* repeated Authentication.SecurityReport securityReport = 2; */
    for (let i = 0; i < message.securityReport.length; i++)
      SecurityReport.internalBinaryWrite(
        message.securityReport[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int64 asOfRevision = 3; */
    if (message.asOfRevision !== BigInt(0))
      writer.tag(3, WireType.Varint).int64(message.asOfRevision);
    /* int64 fromPage = 4; */
    if (message.fromPage !== BigInt(0)) writer.tag(4, WireType.Varint).int64(message.fromPage);
    /* int64 toPage = 5; */
    if (message.toPage !== BigInt(0)) writer.tag(5, WireType.Varint).int64(message.toPage);
    /* bool complete = 6; */
    if (message.complete !== false) writer.tag(6, WireType.Varint).bool(message.complete);
    /* bytes enterpriseEccPrivateKey = 7; */
    if (message.enterpriseEccPrivateKey.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.enterpriseEccPrivateKey);
    /* bool hasIncrementalData = 8; */
    if (message.hasIncrementalData !== false)
      writer.tag(8, WireType.Varint).bool(message.hasIncrementalData);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SecurityReportResponse
 */
export const SecurityReportResponse = new SecurityReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IncrementalSecurityDataRequest$Type extends MessageType<IncrementalSecurityDataRequest> {
  constructor() {
    super("Authentication.IncrementalSecurityDataRequest", [
      { no: 1, name: "continuationToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<IncrementalSecurityDataRequest>): IncrementalSecurityDataRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.continuationToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<IncrementalSecurityDataRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IncrementalSecurityDataRequest,
  ): IncrementalSecurityDataRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes continuationToken */ 1:
          message.continuationToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: IncrementalSecurityDataRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes continuationToken = 1; */
    if (message.continuationToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.continuationToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.IncrementalSecurityDataRequest
 */
export const IncrementalSecurityDataRequest = new IncrementalSecurityDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IncrementalSecurityDataResponse$Type extends MessageType<IncrementalSecurityDataResponse> {
  constructor() {
    super("Authentication.IncrementalSecurityDataResponse", [
      {
        no: 1,
        name: "securityReportIncrementalData",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SecurityReportIncrementalData,
      },
      { no: 2, name: "continuationToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<IncrementalSecurityDataResponse>): IncrementalSecurityDataResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.securityReportIncrementalData = [];
    message.continuationToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<IncrementalSecurityDataResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IncrementalSecurityDataResponse,
  ): IncrementalSecurityDataResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData */ 1:
          message.securityReportIncrementalData.push(
            SecurityReportIncrementalData.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bytes continuationToken */ 2:
          message.continuationToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: IncrementalSecurityDataResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.SecurityReportIncrementalData securityReportIncrementalData = 1; */
    for (let i = 0; i < message.securityReportIncrementalData.length; i++)
      SecurityReportIncrementalData.internalBinaryWrite(
        message.securityReportIncrementalData[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes continuationToken = 2; */
    if (message.continuationToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.continuationToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.IncrementalSecurityDataResponse
 */
export const IncrementalSecurityDataResponse = new IncrementalSecurityDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReusedPasswordsRequest$Type extends MessageType<ReusedPasswordsRequest> {
  constructor() {
    super("Authentication.ReusedPasswordsRequest", [
      { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<ReusedPasswordsRequest>): ReusedPasswordsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.count = 0;
    if (value !== undefined) reflectionMergePartial<ReusedPasswordsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ReusedPasswordsRequest,
  ): ReusedPasswordsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 count */ 1:
          message.count = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ReusedPasswordsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 count = 1; */
    if (message.count !== 0) writer.tag(1, WireType.Varint).int32(message.count);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ReusedPasswordsRequest
 */
export const ReusedPasswordsRequest = new ReusedPasswordsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryConsoleReport$Type extends MessageType<SummaryConsoleReport> {
  constructor() {
    super("Authentication.SummaryConsoleReport", [
      { no: 1, name: "reportType", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "reportData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SummaryConsoleReport>): SummaryConsoleReport {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.reportType = 0;
    message.reportData = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<SummaryConsoleReport>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SummaryConsoleReport,
  ): SummaryConsoleReport {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 reportType */ 1:
          message.reportType = reader.int32();
          break;
        case /* bytes reportData */ 2:
          message.reportData = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SummaryConsoleReport,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 reportType = 1; */
    if (message.reportType !== 0) writer.tag(1, WireType.Varint).int32(message.reportType);
    /* bytes reportData = 2; */
    if (message.reportData.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.reportData);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SummaryConsoleReport
 */
export const SummaryConsoleReport = new SummaryConsoleReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeToKeyTypeOne$Type extends MessageType<ChangeToKeyTypeOne> {
  constructor() {
    super("Authentication.ChangeToKeyTypeOne", [
      {
        no: 1,
        name: "objectType",
        kind: "enum",
        T: () => ["Authentication.ObjectTypes", ObjectTypes],
      },
      { no: 2, name: "primaryUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "secondaryUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeToKeyTypeOne>): ChangeToKeyTypeOne {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objectType = 0;
    message.primaryUid = new Uint8Array(0);
    message.secondaryUid = new Uint8Array(0);
    message.key = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<ChangeToKeyTypeOne>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeToKeyTypeOne,
  ): ChangeToKeyTypeOne {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.ObjectTypes objectType */ 1:
          message.objectType = reader.int32();
          break;
        case /* bytes primaryUid */ 2:
          message.primaryUid = reader.bytes();
          break;
        case /* bytes secondaryUid */ 3:
          message.secondaryUid = reader.bytes();
          break;
        case /* bytes key */ 4:
          message.key = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeToKeyTypeOne,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.ObjectTypes objectType = 1; */
    if (message.objectType !== 0) writer.tag(1, WireType.Varint).int32(message.objectType);
    /* bytes primaryUid = 2; */
    if (message.primaryUid.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.primaryUid);
    /* bytes secondaryUid = 3; */
    if (message.secondaryUid.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.secondaryUid);
    /* bytes key = 4; */
    if (message.key.length) writer.tag(4, WireType.LengthDelimited).bytes(message.key);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeToKeyTypeOne
 */
export const ChangeToKeyTypeOne = new ChangeToKeyTypeOne$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeToKeyTypeOneRequest$Type extends MessageType<ChangeToKeyTypeOneRequest> {
  constructor() {
    super("Authentication.ChangeToKeyTypeOneRequest", [
      {
        no: 1,
        name: "changeToKeyTypeOne",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ChangeToKeyTypeOne,
      },
    ]);
  }
  create(value?: PartialMessage<ChangeToKeyTypeOneRequest>): ChangeToKeyTypeOneRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.changeToKeyTypeOne = [];
    if (value !== undefined)
      reflectionMergePartial<ChangeToKeyTypeOneRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeToKeyTypeOneRequest,
  ): ChangeToKeyTypeOneRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.ChangeToKeyTypeOne changeToKeyTypeOne */ 1:
          message.changeToKeyTypeOne.push(
            ChangeToKeyTypeOne.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeToKeyTypeOneRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.ChangeToKeyTypeOne changeToKeyTypeOne = 1; */
    for (let i = 0; i < message.changeToKeyTypeOne.length; i++)
      ChangeToKeyTypeOne.internalBinaryWrite(
        message.changeToKeyTypeOne[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeToKeyTypeOneRequest
 */
export const ChangeToKeyTypeOneRequest = new ChangeToKeyTypeOneRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeToKeyTypeOneStatus$Type extends MessageType<ChangeToKeyTypeOneStatus> {
  constructor() {
    super("Authentication.ChangeToKeyTypeOneStatus", [
      { no: 1, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeToKeyTypeOneStatus>): ChangeToKeyTypeOneStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = new Uint8Array(0);
    message.type = "";
    message.status = "";
    message.reason = "";
    if (value !== undefined) reflectionMergePartial<ChangeToKeyTypeOneStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeToKeyTypeOneStatus,
  ): ChangeToKeyTypeOneStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes uid */ 1:
          message.uid = reader.bytes();
          break;
        case /* string type */ 2:
          message.type = reader.string();
          break;
        case /* string status */ 3:
          message.status = reader.string();
          break;
        case /* string reason */ 4:
          message.reason = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeToKeyTypeOneStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes uid = 1; */
    if (message.uid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uid);
    /* string type = 2; */
    if (message.type !== "") writer.tag(2, WireType.LengthDelimited).string(message.type);
    /* string status = 3; */
    if (message.status !== "") writer.tag(3, WireType.LengthDelimited).string(message.status);
    /* string reason = 4; */
    if (message.reason !== "") writer.tag(4, WireType.LengthDelimited).string(message.reason);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeToKeyTypeOneStatus
 */
export const ChangeToKeyTypeOneStatus = new ChangeToKeyTypeOneStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeToKeyTypeOneResponse$Type extends MessageType<ChangeToKeyTypeOneResponse> {
  constructor() {
    super("Authentication.ChangeToKeyTypeOneResponse", [
      {
        no: 1,
        name: "changeToKeyTypeOneStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ChangeToKeyTypeOneStatus,
      },
    ]);
  }
  create(value?: PartialMessage<ChangeToKeyTypeOneResponse>): ChangeToKeyTypeOneResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.changeToKeyTypeOneStatus = [];
    if (value !== undefined)
      reflectionMergePartial<ChangeToKeyTypeOneResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeToKeyTypeOneResponse,
  ): ChangeToKeyTypeOneResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.ChangeToKeyTypeOneStatus changeToKeyTypeOneStatus */ 1:
          message.changeToKeyTypeOneStatus.push(
            ChangeToKeyTypeOneStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeToKeyTypeOneResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.ChangeToKeyTypeOneStatus changeToKeyTypeOneStatus = 1; */
    for (let i = 0; i < message.changeToKeyTypeOneStatus.length; i++)
      ChangeToKeyTypeOneStatus.internalBinaryWrite(
        message.changeToKeyTypeOneStatus[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeToKeyTypeOneResponse
 */
export const ChangeToKeyTypeOneResponse = new ChangeToKeyTypeOneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChangeKeyTypesRequest$Type extends MessageType<GetChangeKeyTypesRequest> {
  constructor() {
    super("Authentication.GetChangeKeyTypesRequest", [
      {
        no: 1,
        name: "onlyTheseObjects",
        kind: "enum",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ["Authentication.EncryptedObjectType", EncryptedObjectType],
      },
      { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "includeRecommended", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "includeKeys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: "includeAllowedKeyTypes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<GetChangeKeyTypesRequest>): GetChangeKeyTypesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.onlyTheseObjects = [];
    message.limit = 0;
    message.includeRecommended = false;
    message.includeKeys = false;
    message.includeAllowedKeyTypes = false;
    if (value !== undefined) reflectionMergePartial<GetChangeKeyTypesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetChangeKeyTypesRequest,
  ): GetChangeKeyTypesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.EncryptedObjectType onlyTheseObjects */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.onlyTheseObjects.push(reader.int32());
          else message.onlyTheseObjects.push(reader.int32());
          break;
        case /* int32 limit */ 2:
          message.limit = reader.int32();
          break;
        case /* bool includeRecommended */ 3:
          message.includeRecommended = reader.bool();
          break;
        case /* bool includeKeys */ 4:
          message.includeKeys = reader.bool();
          break;
        case /* bool includeAllowedKeyTypes */ 5:
          message.includeAllowedKeyTypes = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetChangeKeyTypesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.EncryptedObjectType onlyTheseObjects = 1; */
    if (message.onlyTheseObjects.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.onlyTheseObjects.length; i++)
        writer.int32(message.onlyTheseObjects[i]);
      writer.join();
    }
    /* int32 limit = 2; */
    if (message.limit !== 0) writer.tag(2, WireType.Varint).int32(message.limit);
    /* bool includeRecommended = 3; */
    if (message.includeRecommended !== false)
      writer.tag(3, WireType.Varint).bool(message.includeRecommended);
    /* bool includeKeys = 4; */
    if (message.includeKeys !== false) writer.tag(4, WireType.Varint).bool(message.includeKeys);
    /* bool includeAllowedKeyTypes = 5; */
    if (message.includeAllowedKeyTypes !== false)
      writer.tag(5, WireType.Varint).bool(message.includeAllowedKeyTypes);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetChangeKeyTypesRequest
 */
export const GetChangeKeyTypesRequest = new GetChangeKeyTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChangeKeyTypesResponse$Type extends MessageType<GetChangeKeyTypesResponse> {
  constructor() {
    super("Authentication.GetChangeKeyTypesResponse", [
      {
        no: 1,
        name: "keys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ChangeKeyType,
      },
      {
        no: 2,
        name: "allowedKeyTypes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => AllowedKeyTypes,
      },
    ]);
  }
  create(value?: PartialMessage<GetChangeKeyTypesResponse>): GetChangeKeyTypesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keys = [];
    message.allowedKeyTypes = [];
    if (value !== undefined)
      reflectionMergePartial<GetChangeKeyTypesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetChangeKeyTypesResponse,
  ): GetChangeKeyTypesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.ChangeKeyType keys */ 1:
          message.keys.push(ChangeKeyType.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated Authentication.AllowedKeyTypes allowedKeyTypes */ 2:
          message.allowedKeyTypes.push(
            AllowedKeyTypes.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetChangeKeyTypesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.ChangeKeyType keys = 1; */
    for (let i = 0; i < message.keys.length; i++)
      ChangeKeyType.internalBinaryWrite(
        message.keys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.AllowedKeyTypes allowedKeyTypes = 2; */
    for (let i = 0; i < message.allowedKeyTypes.length; i++)
      AllowedKeyTypes.internalBinaryWrite(
        message.allowedKeyTypes[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetChangeKeyTypesResponse
 */
export const GetChangeKeyTypesResponse = new GetChangeKeyTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllowedKeyTypes$Type extends MessageType<AllowedKeyTypes> {
  constructor() {
    super("Authentication.AllowedKeyTypes", [
      {
        no: 1,
        name: "objectType",
        kind: "enum",
        T: () => ["Authentication.EncryptedObjectType", EncryptedObjectType],
      },
      {
        no: 2,
        name: "allowedKeyTypes",
        kind: "enum",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
    ]);
  }
  create(value?: PartialMessage<AllowedKeyTypes>): AllowedKeyTypes {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objectType = 0;
    message.allowedKeyTypes = [];
    if (value !== undefined) reflectionMergePartial<AllowedKeyTypes>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AllowedKeyTypes,
  ): AllowedKeyTypes {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.EncryptedObjectType objectType */ 1:
          message.objectType = reader.int32();
          break;
        case /* repeated Enterprise.EncryptedKeyType allowedKeyTypes */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.allowedKeyTypes.push(reader.int32());
          else message.allowedKeyTypes.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AllowedKeyTypes,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.EncryptedObjectType objectType = 1; */
    if (message.objectType !== 0) writer.tag(1, WireType.Varint).int32(message.objectType);
    /* repeated Enterprise.EncryptedKeyType allowedKeyTypes = 2; */
    if (message.allowedKeyTypes.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.allowedKeyTypes.length; i++)
        writer.int32(message.allowedKeyTypes[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AllowedKeyTypes
 */
export const AllowedKeyTypes = new AllowedKeyTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeKeyTypes$Type extends MessageType<ChangeKeyTypes> {
  constructor() {
    super("Authentication.ChangeKeyTypes", [
      {
        no: 1,
        name: "keys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ChangeKeyType,
      },
    ]);
  }
  create(value?: PartialMessage<ChangeKeyTypes>): ChangeKeyTypes {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keys = [];
    if (value !== undefined) reflectionMergePartial<ChangeKeyTypes>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeKeyTypes,
  ): ChangeKeyTypes {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.ChangeKeyType keys */ 1:
          message.keys.push(ChangeKeyType.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeKeyTypes,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.ChangeKeyType keys = 1; */
    for (let i = 0; i < message.keys.length; i++)
      ChangeKeyType.internalBinaryWrite(
        message.keys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeKeyTypes
 */
export const ChangeKeyTypes = new ChangeKeyTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeKeyType$Type extends MessageType<ChangeKeyType> {
  constructor() {
    super("Authentication.ChangeKeyType", [
      {
        no: 1,
        name: "objectType",
        kind: "enum",
        T: () => ["Authentication.EncryptedObjectType", EncryptedObjectType],
      },
      { no: 2, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "secondaryUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "keyType",
        kind: "enum",
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
      {
        no: 6,
        name: "status",
        kind: "enum",
        T: () => ["Authentication.GenericStatus", GenericStatus],
      },
    ]);
  }
  create(value?: PartialMessage<ChangeKeyType>): ChangeKeyType {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.objectType = 0;
    message.uid = new Uint8Array(0);
    message.secondaryUid = new Uint8Array(0);
    message.key = new Uint8Array(0);
    message.keyType = 0;
    message.status = 0;
    if (value !== undefined) reflectionMergePartial<ChangeKeyType>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeKeyType,
  ): ChangeKeyType {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.EncryptedObjectType objectType */ 1:
          message.objectType = reader.int32();
          break;
        case /* bytes uid */ 2:
          message.uid = reader.bytes();
          break;
        case /* bytes secondaryUid */ 3:
          message.secondaryUid = reader.bytes();
          break;
        case /* bytes key */ 4:
          message.key = reader.bytes();
          break;
        case /* Enterprise.EncryptedKeyType keyType */ 5:
          message.keyType = reader.int32();
          break;
        case /* Authentication.GenericStatus status */ 6:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeKeyType,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.EncryptedObjectType objectType = 1; */
    if (message.objectType !== 0) writer.tag(1, WireType.Varint).int32(message.objectType);
    /* bytes uid = 2; */
    if (message.uid.length) writer.tag(2, WireType.LengthDelimited).bytes(message.uid);
    /* bytes secondaryUid = 3; */
    if (message.secondaryUid.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.secondaryUid);
    /* bytes key = 4; */
    if (message.key.length) writer.tag(4, WireType.LengthDelimited).bytes(message.key);
    /* Enterprise.EncryptedKeyType keyType = 5; */
    if (message.keyType !== 0) writer.tag(5, WireType.Varint).int32(message.keyType);
    /* Authentication.GenericStatus status = 6; */
    if (message.status !== 0) writer.tag(6, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeKeyType
 */
export const ChangeKeyType = new ChangeKeyType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKey$Type extends MessageType<SetKey> {
  constructor() {
    super("Authentication.SetKey", [
      { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
      { no: 2, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SetKey>): SetKey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = BigInt(0);
    message.key = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<SetKey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetKey,
  ): SetKey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 id */ 1:
          message.id = reader.int64().toBigInt();
          break;
        case /* bytes key */ 2:
          message.key = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SetKey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 id = 1; */
    if (message.id !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.id);
    /* bytes key = 2; */
    if (message.key.length) writer.tag(2, WireType.LengthDelimited).bytes(message.key);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SetKey
 */
export const SetKey = new SetKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeyRequest$Type extends MessageType<SetKeyRequest> {
  constructor() {
    super("Authentication.SetKeyRequest", [
      { no: 1, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SetKey },
    ]);
  }
  create(value?: PartialMessage<SetKeyRequest>): SetKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keys = [];
    if (value !== undefined) reflectionMergePartial<SetKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetKeyRequest,
  ): SetKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.SetKey keys */ 1:
          message.keys.push(SetKey.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SetKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.SetKey keys = 1; */
    for (let i = 0; i < message.keys.length; i++)
      SetKey.internalBinaryWrite(
        message.keys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SetKeyRequest
 */
export const SetKeyRequest = new SetKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
  constructor() {
    super("Authentication.CreateUserRequest", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "authVerifier", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "encryptionParams", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "rsaPublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "rsaEncryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "eccPublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 7, name: "eccEncryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 8, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 9, name: "encryptedClientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 10, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 11, name: "encryptedDeviceDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 12, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 13, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 14, name: "installReferrer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 15, name: "mccMNC", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 16, name: "mfg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 17, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 18, name: "brand", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 19, name: "product", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 20, name: "device", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 21, name: "carrier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 22, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 23, name: "enterpriseRegistration", kind: "message", T: () => EnterpriseRegistration },
      { no: 24, name: "encryptedVerificationToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 25, name: "enterpriseUsersDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.authVerifier = new Uint8Array(0);
    message.encryptionParams = new Uint8Array(0);
    message.rsaPublicKey = new Uint8Array(0);
    message.rsaEncryptedPrivateKey = new Uint8Array(0);
    message.eccPublicKey = new Uint8Array(0);
    message.eccEncryptedPrivateKey = new Uint8Array(0);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.encryptedClientKey = new Uint8Array(0);
    message.clientVersion = "";
    message.encryptedDeviceDataKey = new Uint8Array(0);
    message.encryptedLoginToken = new Uint8Array(0);
    message.messageSessionUid = new Uint8Array(0);
    message.installReferrer = "";
    message.mccMNC = 0;
    message.mfg = "";
    message.model = "";
    message.brand = "";
    message.product = "";
    message.device = "";
    message.carrier = "";
    message.verificationCode = "";
    message.encryptedVerificationToken = new Uint8Array(0);
    message.enterpriseUsersDataKey = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<CreateUserRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateUserRequest,
  ): CreateUserRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* bytes authVerifier */ 2:
          message.authVerifier = reader.bytes();
          break;
        case /* bytes encryptionParams */ 3:
          message.encryptionParams = reader.bytes();
          break;
        case /* bytes rsaPublicKey */ 4:
          message.rsaPublicKey = reader.bytes();
          break;
        case /* bytes rsaEncryptedPrivateKey */ 5:
          message.rsaEncryptedPrivateKey = reader.bytes();
          break;
        case /* bytes eccPublicKey */ 6:
          message.eccPublicKey = reader.bytes();
          break;
        case /* bytes eccEncryptedPrivateKey */ 7:
          message.eccEncryptedPrivateKey = reader.bytes();
          break;
        case /* bytes encryptedDeviceToken */ 8:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* bytes encryptedClientKey */ 9:
          message.encryptedClientKey = reader.bytes();
          break;
        case /* string clientVersion */ 10:
          message.clientVersion = reader.string();
          break;
        case /* bytes encryptedDeviceDataKey */ 11:
          message.encryptedDeviceDataKey = reader.bytes();
          break;
        case /* bytes encryptedLoginToken */ 12:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* bytes messageSessionUid */ 13:
          message.messageSessionUid = reader.bytes();
          break;
        case /* string installReferrer */ 14:
          message.installReferrer = reader.string();
          break;
        case /* int32 mccMNC */ 15:
          message.mccMNC = reader.int32();
          break;
        case /* string mfg */ 16:
          message.mfg = reader.string();
          break;
        case /* string model */ 17:
          message.model = reader.string();
          break;
        case /* string brand */ 18:
          message.brand = reader.string();
          break;
        case /* string product */ 19:
          message.product = reader.string();
          break;
        case /* string device */ 20:
          message.device = reader.string();
          break;
        case /* string carrier */ 21:
          message.carrier = reader.string();
          break;
        case /* string verificationCode */ 22:
          message.verificationCode = reader.string();
          break;
        case /* Enterprise.EnterpriseRegistration enterpriseRegistration */ 23:
          message.enterpriseRegistration = EnterpriseRegistration.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.enterpriseRegistration,
          );
          break;
        case /* bytes encryptedVerificationToken */ 24:
          message.encryptedVerificationToken = reader.bytes();
          break;
        case /* bytes enterpriseUsersDataKey */ 25:
          message.enterpriseUsersDataKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateUserRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* bytes authVerifier = 2; */
    if (message.authVerifier.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.authVerifier);
    /* bytes encryptionParams = 3; */
    if (message.encryptionParams.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptionParams);
    /* bytes rsaPublicKey = 4; */
    if (message.rsaPublicKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.rsaPublicKey);
    /* bytes rsaEncryptedPrivateKey = 5; */
    if (message.rsaEncryptedPrivateKey.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.rsaEncryptedPrivateKey);
    /* bytes eccPublicKey = 6; */
    if (message.eccPublicKey.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.eccPublicKey);
    /* bytes eccEncryptedPrivateKey = 7; */
    if (message.eccEncryptedPrivateKey.length)
      writer.tag(7, WireType.LengthDelimited).bytes(message.eccEncryptedPrivateKey);
    /* bytes encryptedDeviceToken = 8; */
    if (message.encryptedDeviceToken.length)
      writer.tag(8, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* bytes encryptedClientKey = 9; */
    if (message.encryptedClientKey.length)
      writer.tag(9, WireType.LengthDelimited).bytes(message.encryptedClientKey);
    /* string clientVersion = 10; */
    if (message.clientVersion !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.clientVersion);
    /* bytes encryptedDeviceDataKey = 11; */
    if (message.encryptedDeviceDataKey.length)
      writer.tag(11, WireType.LengthDelimited).bytes(message.encryptedDeviceDataKey);
    /* bytes encryptedLoginToken = 12; */
    if (message.encryptedLoginToken.length)
      writer.tag(12, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* bytes messageSessionUid = 13; */
    if (message.messageSessionUid.length)
      writer.tag(13, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* string installReferrer = 14; */
    if (message.installReferrer !== "")
      writer.tag(14, WireType.LengthDelimited).string(message.installReferrer);
    /* int32 mccMNC = 15; */
    if (message.mccMNC !== 0) writer.tag(15, WireType.Varint).int32(message.mccMNC);
    /* string mfg = 16; */
    if (message.mfg !== "") writer.tag(16, WireType.LengthDelimited).string(message.mfg);
    /* string model = 17; */
    if (message.model !== "") writer.tag(17, WireType.LengthDelimited).string(message.model);
    /* string brand = 18; */
    if (message.brand !== "") writer.tag(18, WireType.LengthDelimited).string(message.brand);
    /* string product = 19; */
    if (message.product !== "") writer.tag(19, WireType.LengthDelimited).string(message.product);
    /* string device = 20; */
    if (message.device !== "") writer.tag(20, WireType.LengthDelimited).string(message.device);
    /* string carrier = 21; */
    if (message.carrier !== "") writer.tag(21, WireType.LengthDelimited).string(message.carrier);
    /* string verificationCode = 22; */
    if (message.verificationCode !== "")
      writer.tag(22, WireType.LengthDelimited).string(message.verificationCode);
    /* Enterprise.EnterpriseRegistration enterpriseRegistration = 23; */
    if (message.enterpriseRegistration)
      EnterpriseRegistration.internalBinaryWrite(
        message.enterpriseRegistration,
        writer.tag(23, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes encryptedVerificationToken = 24; */
    if (message.encryptedVerificationToken.length)
      writer.tag(24, WireType.LengthDelimited).bytes(message.encryptedVerificationToken);
    /* bytes enterpriseUsersDataKey = 25; */
    if (message.enterpriseUsersDataKey.length)
      writer.tag(25, WireType.LengthDelimited).bytes(message.enterpriseUsersDataKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeEnforcementAddOrUpdateRequest$Type extends MessageType<NodeEnforcementAddOrUpdateRequest> {
  constructor() {
    super("Authentication.NodeEnforcementAddOrUpdateRequest", [
      {
        no: 1,
        name: "nodeId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "enforcement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<NodeEnforcementAddOrUpdateRequest>,
  ): NodeEnforcementAddOrUpdateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = BigInt(0);
    message.enforcement = "";
    message.value = "";
    if (value !== undefined)
      reflectionMergePartial<NodeEnforcementAddOrUpdateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeEnforcementAddOrUpdateRequest,
  ): NodeEnforcementAddOrUpdateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 nodeId */ 1:
          message.nodeId = reader.int64().toBigInt();
          break;
        case /* string enforcement */ 2:
          message.enforcement = reader.string();
          break;
        case /* string value */ 3:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NodeEnforcementAddOrUpdateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 nodeId = 1; */
    if (message.nodeId !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.nodeId);
    /* string enforcement = 2; */
    if (message.enforcement !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.enforcement);
    /* string value = 3; */
    if (message.value !== "") writer.tag(3, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.NodeEnforcementAddOrUpdateRequest
 */
export const NodeEnforcementAddOrUpdateRequest = new NodeEnforcementAddOrUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeEnforcementRemoveRequest$Type extends MessageType<NodeEnforcementRemoveRequest> {
  constructor() {
    super("Authentication.NodeEnforcementRemoveRequest", [
      {
        no: 1,
        name: "nodeId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "enforcement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<NodeEnforcementRemoveRequest>): NodeEnforcementRemoveRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = BigInt(0);
    message.enforcement = "";
    if (value !== undefined)
      reflectionMergePartial<NodeEnforcementRemoveRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeEnforcementRemoveRequest,
  ): NodeEnforcementRemoveRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 nodeId */ 1:
          message.nodeId = reader.int64().toBigInt();
          break;
        case /* string enforcement */ 2:
          message.enforcement = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NodeEnforcementRemoveRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 nodeId = 1; */
    if (message.nodeId !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.nodeId);
    /* string enforcement = 2; */
    if (message.enforcement !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.enforcement);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.NodeEnforcementRemoveRequest
 */
export const NodeEnforcementRemoveRequest = new NodeEnforcementRemoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApiRequestByKey$Type extends MessageType<ApiRequestByKey> {
  constructor() {
    super("Authentication.ApiRequestByKey", [
      { no: 1, name: "keyId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "locale", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "supportedLanguage",
        kind: "enum",
        T: () => ["Authentication.SupportedLanguage", SupportedLanguage],
      },
      { no: 6, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<ApiRequestByKey>): ApiRequestByKey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keyId = 0;
    message.payload = new Uint8Array(0);
    message.username = "";
    message.locale = "";
    message.supportedLanguage = 0;
    message.type = 0;
    if (value !== undefined) reflectionMergePartial<ApiRequestByKey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApiRequestByKey,
  ): ApiRequestByKey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 keyId */ 1:
          message.keyId = reader.int32();
          break;
        case /* bytes payload */ 2:
          message.payload = reader.bytes();
          break;
        case /* string username */ 3:
          message.username = reader.string();
          break;
        case /* string locale */ 4:
          message.locale = reader.string();
          break;
        case /* Authentication.SupportedLanguage supportedLanguage */ 5:
          message.supportedLanguage = reader.int32();
          break;
        case /* int32 type */ 6:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApiRequestByKey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 keyId = 1; */
    if (message.keyId !== 0) writer.tag(1, WireType.Varint).int32(message.keyId);
    /* bytes payload = 2; */
    if (message.payload.length) writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
    /* string username = 3; */
    if (message.username !== "") writer.tag(3, WireType.LengthDelimited).string(message.username);
    /* string locale = 4; */
    if (message.locale !== "") writer.tag(4, WireType.LengthDelimited).string(message.locale);
    /* Authentication.SupportedLanguage supportedLanguage = 5; */
    if (message.supportedLanguage !== 0)
      writer.tag(5, WireType.Varint).int32(message.supportedLanguage);
    /* int32 type = 6; */
    if (message.type !== 0) writer.tag(6, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApiRequestByKey
 */
export const ApiRequestByKey = new ApiRequestByKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApiRequestByKAtoKAKey$Type extends MessageType<ApiRequestByKAtoKAKey> {
  constructor() {
    super("Authentication.ApiRequestByKAtoKAKey", [
      { no: 1, name: "sourceRegion", kind: "enum", T: () => ["Authentication.Region", Region] },
      { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "supportedLanguage",
        kind: "enum",
        T: () => ["Authentication.SupportedLanguage", SupportedLanguage],
      },
      {
        no: 4,
        name: "destinationRegion",
        kind: "enum",
        T: () => ["Authentication.Region", Region],
      },
    ]);
  }
  create(value?: PartialMessage<ApiRequestByKAtoKAKey>): ApiRequestByKAtoKAKey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.sourceRegion = 0;
    message.payload = new Uint8Array(0);
    message.supportedLanguage = 0;
    message.destinationRegion = 0;
    if (value !== undefined) reflectionMergePartial<ApiRequestByKAtoKAKey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApiRequestByKAtoKAKey,
  ): ApiRequestByKAtoKAKey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.Region sourceRegion */ 1:
          message.sourceRegion = reader.int32();
          break;
        case /* bytes payload */ 2:
          message.payload = reader.bytes();
          break;
        case /* Authentication.SupportedLanguage supportedLanguage */ 3:
          message.supportedLanguage = reader.int32();
          break;
        case /* Authentication.Region destinationRegion */ 4:
          message.destinationRegion = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApiRequestByKAtoKAKey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.Region sourceRegion = 1; */
    if (message.sourceRegion !== 0) writer.tag(1, WireType.Varint).int32(message.sourceRegion);
    /* bytes payload = 2; */
    if (message.payload.length) writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
    /* Authentication.SupportedLanguage supportedLanguage = 3; */
    if (message.supportedLanguage !== 0)
      writer.tag(3, WireType.Varint).int32(message.supportedLanguage);
    /* Authentication.Region destinationRegion = 4; */
    if (message.destinationRegion !== 0)
      writer.tag(4, WireType.Varint).int32(message.destinationRegion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApiRequestByKAtoKAKey
 */
export const ApiRequestByKAtoKAKey = new ApiRequestByKAtoKAKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemcacheRequest$Type extends MessageType<MemcacheRequest> {
  constructor() {
    super("Authentication.MemcacheRequest", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "userId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<MemcacheRequest>): MemcacheRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.userId = 0;
    if (value !== undefined) reflectionMergePartial<MemcacheRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MemcacheRequest,
  ): MemcacheRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* int32 userId */ 2:
          message.userId = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MemcacheRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "") writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* int32 userId = 2; */
    if (message.userId !== 0) writer.tag(2, WireType.Varint).int32(message.userId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.MemcacheRequest
 */
export const MemcacheRequest = new MemcacheRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemcacheResponse$Type extends MessageType<MemcacheResponse> {
  constructor() {
    super("Authentication.MemcacheResponse", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<MemcacheResponse>): MemcacheResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.value = "";
    if (value !== undefined) reflectionMergePartial<MemcacheResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MemcacheResponse,
  ): MemcacheResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string value */ 2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MemcacheResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "") writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string value = 2; */
    if (message.value !== "") writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.MemcacheResponse
 */
export const MemcacheResponse = new MemcacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MasterPasswordReentryRequest$Type extends MessageType<MasterPasswordReentryRequest> {
  constructor() {
    super("Authentication.MasterPasswordReentryRequest", [
      { no: 1, name: "pbkdf2Password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "action",
        kind: "enum",
        T: () => [
          "Authentication.MasterPasswordReentryActionType",
          MasterPasswordReentryActionType,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<MasterPasswordReentryRequest>): MasterPasswordReentryRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.pbkdf2Password = "";
    message.action = 0;
    if (value !== undefined)
      reflectionMergePartial<MasterPasswordReentryRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MasterPasswordReentryRequest,
  ): MasterPasswordReentryRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string pbkdf2Password */ 1:
          message.pbkdf2Password = reader.string();
          break;
        case /* Authentication.MasterPasswordReentryActionType action */ 2:
          message.action = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MasterPasswordReentryRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string pbkdf2Password = 1; */
    if (message.pbkdf2Password !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.pbkdf2Password);
    /* Authentication.MasterPasswordReentryActionType action = 2; */
    if (message.action !== 0) writer.tag(2, WireType.Varint).int32(message.action);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.MasterPasswordReentryRequest
 */
export const MasterPasswordReentryRequest = new MasterPasswordReentryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MasterPasswordReentryResponse$Type extends MessageType<MasterPasswordReentryResponse> {
  constructor() {
    super("Authentication.MasterPasswordReentryResponse", [
      {
        no: 1,
        name: "status",
        kind: "enum",
        T: () => ["Authentication.MasterPasswordReentryStatus", MasterPasswordReentryStatus],
      },
    ]);
  }
  create(value?: PartialMessage<MasterPasswordReentryResponse>): MasterPasswordReentryResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.status = 0;
    if (value !== undefined)
      reflectionMergePartial<MasterPasswordReentryResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MasterPasswordReentryResponse,
  ): MasterPasswordReentryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.MasterPasswordReentryStatus status */ 1:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MasterPasswordReentryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.MasterPasswordReentryStatus status = 1; */
    if (message.status !== 0) writer.tag(1, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.MasterPasswordReentryResponse
 */
export const MasterPasswordReentryResponse = new MasterPasswordReentryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceRegistrationRequest$Type extends MessageType<DeviceRegistrationRequest> {
  constructor() {
    super("Authentication.DeviceRegistrationRequest", [
      { no: 1, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "devicePublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "devicePlatform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "clientFormFactor",
        kind: "enum",
        T: () => ["Authentication.ClientFormFactor", ClientFormFactor],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceRegistrationRequest>): DeviceRegistrationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientVersion = "";
    message.deviceName = "";
    message.devicePublicKey = new Uint8Array(0);
    message.devicePlatform = "";
    message.clientFormFactor = 0;
    if (value !== undefined)
      reflectionMergePartial<DeviceRegistrationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceRegistrationRequest,
  ): DeviceRegistrationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string clientVersion */ 1:
          message.clientVersion = reader.string();
          break;
        case /* string deviceName */ 2:
          message.deviceName = reader.string();
          break;
        case /* bytes devicePublicKey */ 3:
          message.devicePublicKey = reader.bytes();
          break;
        case /* string devicePlatform */ 4:
          message.devicePlatform = reader.string();
          break;
        case /* Authentication.ClientFormFactor clientFormFactor */ 5:
          message.clientFormFactor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceRegistrationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string clientVersion = 1; */
    if (message.clientVersion !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.clientVersion);
    /* string deviceName = 2; */
    if (message.deviceName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.deviceName);
    /* bytes devicePublicKey = 3; */
    if (message.devicePublicKey.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.devicePublicKey);
    /* string devicePlatform = 4; */
    if (message.devicePlatform !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.devicePlatform);
    /* Authentication.ClientFormFactor clientFormFactor = 5; */
    if (message.clientFormFactor !== 0)
      writer.tag(5, WireType.Varint).int32(message.clientFormFactor);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceRegistrationRequest
 */
export const DeviceRegistrationRequest = new DeviceRegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceVerificationRequest$Type extends MessageType<DeviceVerificationRequest> {
  constructor() {
    super("Authentication.DeviceVerificationRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "verificationChannel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DeviceVerificationRequest>): DeviceVerificationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.username = "";
    message.verificationChannel = "";
    message.messageSessionUid = new Uint8Array(0);
    message.clientVersion = "";
    if (value !== undefined)
      reflectionMergePartial<DeviceVerificationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceVerificationRequest,
  ): DeviceVerificationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string username */ 2:
          message.username = reader.string();
          break;
        case /* string verificationChannel */ 3:
          message.verificationChannel = reader.string();
          break;
        case /* bytes messageSessionUid */ 4:
          message.messageSessionUid = reader.bytes();
          break;
        case /* string clientVersion */ 5:
          message.clientVersion = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceVerificationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string username = 2; */
    if (message.username !== "") writer.tag(2, WireType.LengthDelimited).string(message.username);
    /* string verificationChannel = 3; */
    if (message.verificationChannel !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.verificationChannel);
    /* bytes messageSessionUid = 4; */
    if (message.messageSessionUid.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* string clientVersion = 5; */
    if (message.clientVersion !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.clientVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceVerificationRequest
 */
export const DeviceVerificationRequest = new DeviceVerificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceVerificationResponse$Type extends MessageType<DeviceVerificationResponse> {
  constructor() {
    super("Authentication.DeviceVerificationResponse", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "deviceStatus",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceVerificationResponse>): DeviceVerificationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.username = "";
    message.messageSessionUid = new Uint8Array(0);
    message.clientVersion = "";
    message.deviceStatus = 0;
    if (value !== undefined)
      reflectionMergePartial<DeviceVerificationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceVerificationResponse,
  ): DeviceVerificationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string username */ 2:
          message.username = reader.string();
          break;
        case /* bytes messageSessionUid */ 3:
          message.messageSessionUid = reader.bytes();
          break;
        case /* string clientVersion */ 4:
          message.clientVersion = reader.string();
          break;
        case /* Authentication.DeviceStatus deviceStatus */ 5:
          message.deviceStatus = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceVerificationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string username = 2; */
    if (message.username !== "") writer.tag(2, WireType.LengthDelimited).string(message.username);
    /* bytes messageSessionUid = 3; */
    if (message.messageSessionUid.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* string clientVersion = 4; */
    if (message.clientVersion !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.clientVersion);
    /* Authentication.DeviceStatus deviceStatus = 5; */
    if (message.deviceStatus !== 0) writer.tag(5, WireType.Varint).int32(message.deviceStatus);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceVerificationResponse
 */
export const DeviceVerificationResponse = new DeviceVerificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceApprovalRequest$Type extends MessageType<DeviceApprovalRequest> {
  constructor() {
    super("Authentication.DeviceApprovalRequest", [
      { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "twoFactorChannel", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "locale", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "totpCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: "deviceIp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 8, name: "deviceTokenExpireDays", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DeviceApprovalRequest>): DeviceApprovalRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.email = "";
    message.twoFactorChannel = "";
    message.clientVersion = "";
    message.locale = "";
    message.encryptedDeviceToken = new Uint8Array(0);
    message.totpCode = "";
    message.deviceIp = "";
    message.deviceTokenExpireDays = "";
    if (value !== undefined) reflectionMergePartial<DeviceApprovalRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceApprovalRequest,
  ): DeviceApprovalRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.email = reader.string();
          break;
        case /* string twoFactorChannel */ 2:
          message.twoFactorChannel = reader.string();
          break;
        case /* string clientVersion */ 3:
          message.clientVersion = reader.string();
          break;
        case /* string locale */ 4:
          message.locale = reader.string();
          break;
        case /* bytes encryptedDeviceToken */ 5:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* string totpCode */ 6:
          message.totpCode = reader.string();
          break;
        case /* string deviceIp */ 7:
          message.deviceIp = reader.string();
          break;
        case /* string deviceTokenExpireDays */ 8:
          message.deviceTokenExpireDays = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceApprovalRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.email !== "") writer.tag(1, WireType.LengthDelimited).string(message.email);
    /* string twoFactorChannel = 2; */
    if (message.twoFactorChannel !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.twoFactorChannel);
    /* string clientVersion = 3; */
    if (message.clientVersion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.clientVersion);
    /* string locale = 4; */
    if (message.locale !== "") writer.tag(4, WireType.LengthDelimited).string(message.locale);
    /* bytes encryptedDeviceToken = 5; */
    if (message.encryptedDeviceToken.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string totpCode = 6; */
    if (message.totpCode !== "") writer.tag(6, WireType.LengthDelimited).string(message.totpCode);
    /* string deviceIp = 7; */
    if (message.deviceIp !== "") writer.tag(7, WireType.LengthDelimited).string(message.deviceIp);
    /* string deviceTokenExpireDays = 8; */
    if (message.deviceTokenExpireDays !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.deviceTokenExpireDays);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceApprovalRequest
 */
export const DeviceApprovalRequest = new DeviceApprovalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceApprovalResponse$Type extends MessageType<DeviceApprovalResponse> {
  constructor() {
    super("Authentication.DeviceApprovalResponse", [
      { no: 1, name: "encryptedTwoFactorToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<DeviceApprovalResponse>): DeviceApprovalResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedTwoFactorToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<DeviceApprovalResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceApprovalResponse,
  ): DeviceApprovalResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedTwoFactorToken */ 1:
          message.encryptedTwoFactorToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceApprovalResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedTwoFactorToken = 1; */
    if (message.encryptedTwoFactorToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedTwoFactorToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceApprovalResponse
 */
export const DeviceApprovalResponse = new DeviceApprovalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApproveDeviceRequest$Type extends MessageType<ApproveDeviceRequest> {
  constructor() {
    super("Authentication.ApproveDeviceRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedDeviceDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "denyApproval", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "linkDevice", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ApproveDeviceRequest>): ApproveDeviceRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.encryptedDeviceDataKey = new Uint8Array(0);
    message.denyApproval = false;
    message.linkDevice = false;
    if (value !== undefined) reflectionMergePartial<ApproveDeviceRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApproveDeviceRequest,
  ): ApproveDeviceRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* bytes encryptedDeviceDataKey */ 2:
          message.encryptedDeviceDataKey = reader.bytes();
          break;
        case /* bool denyApproval */ 3:
          message.denyApproval = reader.bool();
          break;
        case /* bool linkDevice */ 4:
          message.linkDevice = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApproveDeviceRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* bytes encryptedDeviceDataKey = 2; */
    if (message.encryptedDeviceDataKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedDeviceDataKey);
    /* bool denyApproval = 3; */
    if (message.denyApproval !== false) writer.tag(3, WireType.Varint).bool(message.denyApproval);
    /* bool linkDevice = 4; */
    if (message.linkDevice !== false) writer.tag(4, WireType.Varint).bool(message.linkDevice);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApproveDeviceRequest
 */
export const ApproveDeviceRequest = new ApproveDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserAliasRequest$Type extends MessageType<EnterpriseUserAliasRequest> {
  constructor() {
    super("Authentication.EnterpriseUserAliasRequest", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserAliasRequest>): EnterpriseUserAliasRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.alias = "";
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserAliasRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserAliasRequest,
  ): EnterpriseUserAliasRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* string alias */ 2:
          message.alias = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserAliasRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* string alias = 2; */
    if (message.alias !== "") writer.tag(2, WireType.LengthDelimited).string(message.alias);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserAliasRequest
 */
export const EnterpriseUserAliasRequest = new EnterpriseUserAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserAddAliasRequest$Type extends MessageType<EnterpriseUserAddAliasRequest> {
  constructor() {
    super("Authentication.EnterpriseUserAddAliasRequest", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "alias", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserAddAliasRequest>): EnterpriseUserAddAliasRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.alias = "";
    message.primary = false;
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserAddAliasRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserAddAliasRequest,
  ): EnterpriseUserAddAliasRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* string alias */ 2:
          message.alias = reader.string();
          break;
        case /* bool primary */ 3:
          message.primary = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserAddAliasRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* string alias = 2; */
    if (message.alias !== "") writer.tag(2, WireType.LengthDelimited).string(message.alias);
    /* bool primary = 3; */
    if (message.primary !== false) writer.tag(3, WireType.Varint).bool(message.primary);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserAddAliasRequest
 */
export const EnterpriseUserAddAliasRequest = new EnterpriseUserAddAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserAddAliasRequestV2$Type extends MessageType<EnterpriseUserAddAliasRequestV2> {
  constructor() {
    super("Authentication.EnterpriseUserAddAliasRequestV2", [
      {
        no: 1,
        name: "enterpriseUserAddAliasRequest",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => EnterpriseUserAddAliasRequest,
      },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserAddAliasRequestV2>): EnterpriseUserAddAliasRequestV2 {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserAddAliasRequest = [];
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserAddAliasRequestV2>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserAddAliasRequestV2,
  ): EnterpriseUserAddAliasRequestV2 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.EnterpriseUserAddAliasRequest enterpriseUserAddAliasRequest */ 1:
          message.enterpriseUserAddAliasRequest.push(
            EnterpriseUserAddAliasRequest.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserAddAliasRequestV2,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.EnterpriseUserAddAliasRequest enterpriseUserAddAliasRequest = 1; */
    for (let i = 0; i < message.enterpriseUserAddAliasRequest.length; i++)
      EnterpriseUserAddAliasRequest.internalBinaryWrite(
        message.enterpriseUserAddAliasRequest[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserAddAliasRequestV2
 */
export const EnterpriseUserAddAliasRequestV2 = new EnterpriseUserAddAliasRequestV2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserAddAliasStatus$Type extends MessageType<EnterpriseUserAddAliasStatus> {
  constructor() {
    super("Authentication.EnterpriseUserAddAliasStatus", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserAddAliasStatus>): EnterpriseUserAddAliasStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.status = "";
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserAddAliasStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserAddAliasStatus,
  ): EnterpriseUserAddAliasStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* string status */ 2:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserAddAliasStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* string status = 2; */
    if (message.status !== "") writer.tag(2, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserAddAliasStatus
 */
export const EnterpriseUserAddAliasStatus = new EnterpriseUserAddAliasStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserAddAliasResponse$Type extends MessageType<EnterpriseUserAddAliasResponse> {
  constructor() {
    super("Authentication.EnterpriseUserAddAliasResponse", [
      {
        no: 1,
        name: "status",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => EnterpriseUserAddAliasStatus,
      },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserAddAliasResponse>): EnterpriseUserAddAliasResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.status = [];
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserAddAliasResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserAddAliasResponse,
  ): EnterpriseUserAddAliasResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.EnterpriseUserAddAliasStatus status */ 1:
          message.status.push(
            EnterpriseUserAddAliasStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserAddAliasResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.EnterpriseUserAddAliasStatus status = 1; */
    for (let i = 0; i < message.status.length; i++)
      EnterpriseUserAddAliasStatus.internalBinaryWrite(
        message.status[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserAddAliasResponse
 */
export const EnterpriseUserAddAliasResponse = new EnterpriseUserAddAliasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Device$Type extends MessageType<Device> {
  constructor() {
    super("Authentication.Device", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<Device>): Device {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<Device>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Device,
  ): Device {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Device,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.Device
 */
export const Device = new Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterDeviceDataKeyRequest$Type extends MessageType<RegisterDeviceDataKeyRequest> {
  constructor() {
    super("Authentication.RegisterDeviceDataKeyRequest", [
      { no: 1, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedDeviceDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<RegisterDeviceDataKeyRequest>): RegisterDeviceDataKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedDeviceToken = new Uint8Array(0);
    message.encryptedDeviceDataKey = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<RegisterDeviceDataKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegisterDeviceDataKeyRequest,
  ): RegisterDeviceDataKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedDeviceToken */ 1:
          message.encryptedDeviceToken = reader.bytes();
          break;
        case /* bytes encryptedDeviceDataKey */ 2:
          message.encryptedDeviceDataKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RegisterDeviceDataKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedDeviceToken = 1; */
    if (message.encryptedDeviceToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* bytes encryptedDeviceDataKey = 2; */
    if (message.encryptedDeviceDataKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedDeviceDataKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RegisterDeviceDataKeyRequest
 */
export const RegisterDeviceDataKeyRequest = new RegisterDeviceDataKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateCreateUserVerificationCodeRequest$Type extends MessageType<ValidateCreateUserVerificationCodeRequest> {
  constructor() {
    super("Authentication.ValidateCreateUserVerificationCodeRequest", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<ValidateCreateUserVerificationCodeRequest>,
  ): ValidateCreateUserVerificationCodeRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.clientVersion = "";
    message.verificationCode = "";
    if (value !== undefined)
      reflectionMergePartial<ValidateCreateUserVerificationCodeRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidateCreateUserVerificationCodeRequest,
  ): ValidateCreateUserVerificationCodeRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string verificationCode */ 3:
          message.verificationCode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidateCreateUserVerificationCodeRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string verificationCode = 3; */
    if (message.verificationCode !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.verificationCode);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ValidateCreateUserVerificationCodeRequest
 */
export const ValidateCreateUserVerificationCodeRequest =
  new ValidateCreateUserVerificationCodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateDeviceVerificationCodeRequest$Type extends MessageType<ValidateDeviceVerificationCodeRequest> {
  constructor() {
    super("Authentication.ValidateDeviceVerificationCodeRequest", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(
    value?: PartialMessage<ValidateDeviceVerificationCodeRequest>,
  ): ValidateDeviceVerificationCodeRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.clientVersion = "";
    message.verificationCode = "";
    message.messageSessionUid = new Uint8Array(0);
    message.encryptedDeviceToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<ValidateDeviceVerificationCodeRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidateDeviceVerificationCodeRequest,
  ): ValidateDeviceVerificationCodeRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string verificationCode */ 3:
          message.verificationCode = reader.string();
          break;
        case /* bytes messageSessionUid */ 4:
          message.messageSessionUid = reader.bytes();
          break;
        case /* bytes encryptedDeviceToken */ 5:
          message.encryptedDeviceToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidateDeviceVerificationCodeRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string verificationCode = 3; */
    if (message.verificationCode !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.verificationCode);
    /* bytes messageSessionUid = 4; */
    if (message.messageSessionUid.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* bytes encryptedDeviceToken = 5; */
    if (message.encryptedDeviceToken.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ValidateDeviceVerificationCodeRequest
 */
export const ValidateDeviceVerificationCodeRequest =
  new ValidateDeviceVerificationCodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendSessionMessageRequest$Type extends MessageType<SendSessionMessageRequest> {
  constructor() {
    super("Authentication.SendSessionMessageRequest", [
      { no: 1, name: "messageSessionUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<SendSessionMessageRequest>): SendSessionMessageRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.messageSessionUid = new Uint8Array(0);
    message.command = "";
    message.username = "";
    if (value !== undefined)
      reflectionMergePartial<SendSessionMessageRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SendSessionMessageRequest,
  ): SendSessionMessageRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes messageSessionUid */ 1:
          message.messageSessionUid = reader.bytes();
          break;
        case /* string command */ 2:
          message.command = reader.string();
          break;
        case /* string username */ 3:
          message.username = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SendSessionMessageRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes messageSessionUid = 1; */
    if (message.messageSessionUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.messageSessionUid);
    /* string command = 2; */
    if (message.command !== "") writer.tag(2, WireType.LengthDelimited).string(message.command);
    /* string username = 3; */
    if (message.username !== "") writer.tag(3, WireType.LengthDelimited).string(message.username);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SendSessionMessageRequest
 */
export const SendSessionMessageRequest = new SendSessionMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalUserAccount$Type extends MessageType<GlobalUserAccount> {
  constructor() {
    super("Authentication.GlobalUserAccount", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "accountUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "regionName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<GlobalUserAccount>): GlobalUserAccount {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.accountUid = new Uint8Array(0);
    message.regionName = "";
    if (value !== undefined) reflectionMergePartial<GlobalUserAccount>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GlobalUserAccount,
  ): GlobalUserAccount {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* bytes accountUid */ 2:
          message.accountUid = reader.bytes();
          break;
        case /* string regionName */ 3:
          message.regionName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GlobalUserAccount,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* bytes accountUid = 2; */
    if (message.accountUid.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.accountUid);
    /* string regionName = 3; */
    if (message.regionName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.regionName);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GlobalUserAccount
 */
export const GlobalUserAccount = new GlobalUserAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountUsername$Type extends MessageType<AccountUsername> {
  constructor() {
    super("Authentication.AccountUsername", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "dateActive", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<AccountUsername>): AccountUsername {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.dateActive = "";
    if (value !== undefined) reflectionMergePartial<AccountUsername>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AccountUsername,
  ): AccountUsername {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* string dateActive */ 2:
          message.dateActive = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AccountUsername,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* string dateActive = 2; */
    if (message.dateActive !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.dateActive);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AccountUsername
 */
export const AccountUsername = new AccountUsername$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SsoServiceProviderRequest$Type extends MessageType<SsoServiceProviderRequest> {
  constructor() {
    super("Authentication.SsoServiceProviderRequest", [
      { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "locale", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<SsoServiceProviderRequest>): SsoServiceProviderRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = "";
    message.clientVersion = "";
    message.locale = "";
    if (value !== undefined)
      reflectionMergePartial<SsoServiceProviderRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SsoServiceProviderRequest,
  ): SsoServiceProviderRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string clientVersion */ 2:
          message.clientVersion = reader.string();
          break;
        case /* string locale */ 3:
          message.locale = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SsoServiceProviderRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== "") writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string clientVersion = 2; */
    if (message.clientVersion !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.clientVersion);
    /* string locale = 3; */
    if (message.locale !== "") writer.tag(3, WireType.LengthDelimited).string(message.locale);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SsoServiceProviderRequest
 */
export const SsoServiceProviderRequest = new SsoServiceProviderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SsoServiceProviderResponse$Type extends MessageType<SsoServiceProviderResponse> {
  constructor() {
    super("Authentication.SsoServiceProviderResponse", [
      { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "spUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "isCloud", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<SsoServiceProviderResponse>): SsoServiceProviderResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = "";
    message.spUrl = "";
    message.isCloud = false;
    message.clientVersion = "";
    if (value !== undefined)
      reflectionMergePartial<SsoServiceProviderResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SsoServiceProviderResponse,
  ): SsoServiceProviderResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string spUrl */ 2:
          message.spUrl = reader.string();
          break;
        case /* bool isCloud */ 3:
          message.isCloud = reader.bool();
          break;
        case /* string clientVersion */ 4:
          message.clientVersion = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SsoServiceProviderResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== "") writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string spUrl = 2; */
    if (message.spUrl !== "") writer.tag(2, WireType.LengthDelimited).string(message.spUrl);
    /* bool isCloud = 3; */
    if (message.isCloud !== false) writer.tag(3, WireType.Varint).bool(message.isCloud);
    /* string clientVersion = 4; */
    if (message.clientVersion !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.clientVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SsoServiceProviderResponse
 */
export const SsoServiceProviderResponse = new SsoServiceProviderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSettingRequest$Type extends MessageType<UserSettingRequest> {
  constructor() {
    super("Authentication.UserSettingRequest", [
      { no: 1, name: "setting", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<UserSettingRequest>): UserSettingRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.setting = "";
    message.value = "";
    if (value !== undefined) reflectionMergePartial<UserSettingRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserSettingRequest,
  ): UserSettingRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string setting */ 1:
          message.setting = reader.string();
          break;
        case /* string value */ 2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserSettingRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string setting = 1; */
    if (message.setting !== "") writer.tag(1, WireType.LengthDelimited).string(message.setting);
    /* string value = 2; */
    if (message.value !== "") writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserSettingRequest
 */
export const UserSettingRequest = new UserSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThrottleState$Type extends MessageType<ThrottleState> {
  constructor() {
    super("Authentication.ThrottleState", [
      { no: 1, name: "type", kind: "enum", T: () => ["Authentication.ThrottleType", ThrottleType] },
      { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ThrottleState>): ThrottleState {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    message.key = "";
    message.value = "";
    message.state = false;
    if (value !== undefined) reflectionMergePartial<ThrottleState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ThrottleState,
  ): ThrottleState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.ThrottleType type */ 1:
          message.type = reader.int32();
          break;
        case /* string key */ 2:
          message.key = reader.string();
          break;
        case /* string value */ 3:
          message.value = reader.string();
          break;
        case /* bool state */ 4:
          message.state = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ThrottleState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.ThrottleType type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    /* string key = 2; */
    if (message.key !== "") writer.tag(2, WireType.LengthDelimited).string(message.key);
    /* string value = 3; */
    if (message.value !== "") writer.tag(3, WireType.LengthDelimited).string(message.value);
    /* bool state = 4; */
    if (message.state !== false) writer.tag(4, WireType.Varint).bool(message.state);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ThrottleState
 */
export const ThrottleState = new ThrottleState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThrottleState2$Type extends MessageType<ThrottleState2> {
  constructor() {
    super("Authentication.ThrottleState2", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "keyDescription", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "valueDescription", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 7, name: "includedInAllClear", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 8, name: "expireSeconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<ThrottleState2>): ThrottleState2 {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.keyDescription = "";
    message.value = "";
    message.valueDescription = "";
    message.identifier = "";
    message.locked = false;
    message.includedInAllClear = false;
    message.expireSeconds = 0;
    if (value !== undefined) reflectionMergePartial<ThrottleState2>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ThrottleState2,
  ): ThrottleState2 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string keyDescription */ 2:
          message.keyDescription = reader.string();
          break;
        case /* string value */ 3:
          message.value = reader.string();
          break;
        case /* string valueDescription */ 4:
          message.valueDescription = reader.string();
          break;
        case /* string identifier */ 5:
          message.identifier = reader.string();
          break;
        case /* bool locked */ 6:
          message.locked = reader.bool();
          break;
        case /* bool includedInAllClear */ 7:
          message.includedInAllClear = reader.bool();
          break;
        case /* int32 expireSeconds */ 8:
          message.expireSeconds = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ThrottleState2,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "") writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string keyDescription = 2; */
    if (message.keyDescription !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.keyDescription);
    /* string value = 3; */
    if (message.value !== "") writer.tag(3, WireType.LengthDelimited).string(message.value);
    /* string valueDescription = 4; */
    if (message.valueDescription !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.valueDescription);
    /* string identifier = 5; */
    if (message.identifier !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.identifier);
    /* bool locked = 6; */
    if (message.locked !== false) writer.tag(6, WireType.Varint).bool(message.locked);
    /* bool includedInAllClear = 7; */
    if (message.includedInAllClear !== false)
      writer.tag(7, WireType.Varint).bool(message.includedInAllClear);
    /* int32 expireSeconds = 8; */
    if (message.expireSeconds !== 0) writer.tag(8, WireType.Varint).int32(message.expireSeconds);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ThrottleState2
 */
export const ThrottleState2 = new ThrottleState2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInformation$Type extends MessageType<DeviceInformation> {
  constructor() {
    super("Authentication.DeviceInformation", [
      {
        no: 1,
        name: "deviceId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "deviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "lastLogin",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 5,
        name: "deviceStatus",
        kind: "enum",
        T: () => ["Authentication.DeviceStatus", DeviceStatus],
      },
    ]);
  }
  create(value?: PartialMessage<DeviceInformation>): DeviceInformation {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deviceId = BigInt(0);
    message.deviceName = "";
    message.clientVersion = "";
    message.lastLogin = BigInt(0);
    message.deviceStatus = 0;
    if (value !== undefined) reflectionMergePartial<DeviceInformation>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeviceInformation,
  ): DeviceInformation {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 deviceId */ 1:
          message.deviceId = reader.int64().toBigInt();
          break;
        case /* string deviceName */ 2:
          message.deviceName = reader.string();
          break;
        case /* string clientVersion */ 3:
          message.clientVersion = reader.string();
          break;
        case /* int64 lastLogin */ 4:
          message.lastLogin = reader.int64().toBigInt();
          break;
        case /* Authentication.DeviceStatus deviceStatus */ 5:
          message.deviceStatus = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeviceInformation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 deviceId = 1; */
    if (message.deviceId !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.deviceId);
    /* string deviceName = 2; */
    if (message.deviceName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.deviceName);
    /* string clientVersion = 3; */
    if (message.clientVersion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.clientVersion);
    /* int64 lastLogin = 4; */
    if (message.lastLogin !== BigInt(0)) writer.tag(4, WireType.Varint).int64(message.lastLogin);
    /* Authentication.DeviceStatus deviceStatus = 5; */
    if (message.deviceStatus !== 0) writer.tag(5, WireType.Varint).int32(message.deviceStatus);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeviceInformation
 */
export const DeviceInformation = new DeviceInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSetting$Type extends MessageType<UserSetting> {
  constructor() {
    super("Authentication.UserSetting", [
      { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<UserSetting>): UserSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = "";
    message.value = false;
    if (value !== undefined) reflectionMergePartial<UserSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserSetting,
  ): UserSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* bool value */ 2:
          message.value = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== "") writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* bool value = 2; */
    if (message.value !== false) writer.tag(2, WireType.Varint).bool(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserSetting
 */
export const UserSetting = new UserSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataKeyRequest$Type extends MessageType<UserDataKeyRequest> {
  constructor() {
    super("Authentication.UserDataKeyRequest", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<UserDataKeyRequest>): UserDataKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = [];
    if (value !== undefined) reflectionMergePartial<UserDataKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserDataKeyRequest,
  ): UserDataKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated int64 enterpriseUserId */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.enterpriseUserId.push(reader.int64().toBigInt());
          else message.enterpriseUserId.push(reader.int64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserDataKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.enterpriseUserId.length; i++)
        writer.int64(message.enterpriseUserId[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserDataKeyRequest
 */
export const UserDataKeyRequest = new UserDataKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataKeyByNodeRequest$Type extends MessageType<UserDataKeyByNodeRequest> {
  constructor() {
    super("Authentication.UserDataKeyByNodeRequest", [
      {
        no: 1,
        name: "nodeIds",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<UserDataKeyByNodeRequest>): UserDataKeyByNodeRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeIds = [];
    if (value !== undefined) reflectionMergePartial<UserDataKeyByNodeRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserDataKeyByNodeRequest,
  ): UserDataKeyByNodeRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated int64 nodeIds */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.nodeIds.push(reader.int64().toBigInt());
          else message.nodeIds.push(reader.int64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserDataKeyByNodeRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated int64 nodeIds = 1; */
    if (message.nodeIds.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.nodeIds.length; i++) writer.int64(message.nodeIds[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserDataKeyByNodeRequest
 */
export const UserDataKeyByNodeRequest = new UserDataKeyByNodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterpriseUserIdDataKeyPair$Type extends MessageType<EnterpriseUserIdDataKeyPair> {
  constructor() {
    super("Authentication.EnterpriseUserIdDataKeyPair", [
      {
        no: 1,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "encryptedDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "keyType",
        kind: "enum",
        T: () => ["Enterprise.EncryptedKeyType", EncryptedKeyType],
      },
    ]);
  }
  create(value?: PartialMessage<EnterpriseUserIdDataKeyPair>): EnterpriseUserIdDataKeyPair {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterpriseUserId = BigInt(0);
    message.encryptedDataKey = new Uint8Array(0);
    message.keyType = 0;
    if (value !== undefined)
      reflectionMergePartial<EnterpriseUserIdDataKeyPair>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterpriseUserIdDataKeyPair,
  ): EnterpriseUserIdDataKeyPair {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 enterpriseUserId */ 1:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* bytes encryptedDataKey */ 2:
          message.encryptedDataKey = reader.bytes();
          break;
        case /* Enterprise.EncryptedKeyType keyType */ 3:
          message.keyType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterpriseUserIdDataKeyPair,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 enterpriseUserId = 1; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.enterpriseUserId);
    /* bytes encryptedDataKey = 2; */
    if (message.encryptedDataKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedDataKey);
    /* Enterprise.EncryptedKeyType keyType = 3; */
    if (message.keyType !== 0) writer.tag(3, WireType.Varint).int32(message.keyType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EnterpriseUserIdDataKeyPair
 */
export const EnterpriseUserIdDataKeyPair = new EnterpriseUserIdDataKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataKey$Type extends MessageType<UserDataKey> {
  constructor() {
    super("Authentication.UserDataKey", [
      {
        no: 1,
        name: "roleId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 2, name: "roleKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "privateKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "enterpriseUserIdDataKeyPairs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => EnterpriseUserIdDataKeyPair,
      },
    ]);
  }
  create(value?: PartialMessage<UserDataKey>): UserDataKey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.roleId = BigInt(0);
    message.roleKey = new Uint8Array(0);
    message.privateKey = "";
    message.enterpriseUserIdDataKeyPairs = [];
    if (value !== undefined) reflectionMergePartial<UserDataKey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserDataKey,
  ): UserDataKey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 roleId */ 1:
          message.roleId = reader.int64().toBigInt();
          break;
        case /* bytes roleKey */ 2:
          message.roleKey = reader.bytes();
          break;
        case /* string privateKey */ 3:
          message.privateKey = reader.string();
          break;
        case /* repeated Authentication.EnterpriseUserIdDataKeyPair enterpriseUserIdDataKeyPairs */ 4:
          message.enterpriseUserIdDataKeyPairs.push(
            EnterpriseUserIdDataKeyPair.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserDataKey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 roleId = 1; */
    if (message.roleId !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.roleId);
    /* bytes roleKey = 2; */
    if (message.roleKey.length) writer.tag(2, WireType.LengthDelimited).bytes(message.roleKey);
    /* string privateKey = 3; */
    if (message.privateKey !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.privateKey);
    /* repeated Authentication.EnterpriseUserIdDataKeyPair enterpriseUserIdDataKeyPairs = 4; */
    for (let i = 0; i < message.enterpriseUserIdDataKeyPairs.length; i++)
      EnterpriseUserIdDataKeyPair.internalBinaryWrite(
        message.enterpriseUserIdDataKeyPairs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserDataKey
 */
export const UserDataKey = new UserDataKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDataKeyResponse$Type extends MessageType<UserDataKeyResponse> {
  constructor() {
    super("Authentication.UserDataKeyResponse", [
      {
        no: 1,
        name: "userDataKeys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => UserDataKey,
      },
      {
        no: 2,
        name: "accessDenied",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "noEncryptedDataKey",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<UserDataKeyResponse>): UserDataKeyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.userDataKeys = [];
    message.accessDenied = [];
    message.noEncryptedDataKey = [];
    if (value !== undefined) reflectionMergePartial<UserDataKeyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserDataKeyResponse,
  ): UserDataKeyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.UserDataKey userDataKeys */ 1:
          message.userDataKeys.push(
            UserDataKey.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated int64 accessDenied */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.accessDenied.push(reader.int64().toBigInt());
          else message.accessDenied.push(reader.int64().toBigInt());
          break;
        case /* repeated int64 noEncryptedDataKey */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.noEncryptedDataKey.push(reader.int64().toBigInt());
          else message.noEncryptedDataKey.push(reader.int64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserDataKeyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.UserDataKey userDataKeys = 1; */
    for (let i = 0; i < message.userDataKeys.length; i++)
      UserDataKey.internalBinaryWrite(
        message.userDataKeys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int64 accessDenied = 2; */
    if (message.accessDenied.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.accessDenied.length; i++) writer.int64(message.accessDenied[i]);
      writer.join();
    }
    /* repeated int64 noEncryptedDataKey = 3; */
    if (message.noEncryptedDataKey.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.noEncryptedDataKey.length; i++)
        writer.int64(message.noEncryptedDataKey[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserDataKeyResponse
 */
export const UserDataKeyResponse = new UserDataKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MasterPasswordRecoveryVerificationRequest$Type extends MessageType<MasterPasswordRecoveryVerificationRequest> {
  constructor() {
    super("Authentication.MasterPasswordRecoveryVerificationRequest", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(
    value?: PartialMessage<MasterPasswordRecoveryVerificationRequest>,
  ): MasterPasswordRecoveryVerificationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<MasterPasswordRecoveryVerificationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MasterPasswordRecoveryVerificationRequest,
  ): MasterPasswordRecoveryVerificationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MasterPasswordRecoveryVerificationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.MasterPasswordRecoveryVerificationRequest
 */
export const MasterPasswordRecoveryVerificationRequest =
  new MasterPasswordRecoveryVerificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSecurityQuestionV3Request$Type extends MessageType<GetSecurityQuestionV3Request> {
  constructor() {
    super("Authentication.GetSecurityQuestionV3Request", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<GetSecurityQuestionV3Request>): GetSecurityQuestionV3Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    message.verificationCode = "";
    if (value !== undefined)
      reflectionMergePartial<GetSecurityQuestionV3Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetSecurityQuestionV3Request,
  ): GetSecurityQuestionV3Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* string verificationCode */ 2:
          message.verificationCode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetSecurityQuestionV3Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* string verificationCode = 2; */
    if (message.verificationCode !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.verificationCode);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetSecurityQuestionV3Request
 */
export const GetSecurityQuestionV3Request = new GetSecurityQuestionV3Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSecurityQuestionV3Response$Type extends MessageType<GetSecurityQuestionV3Response> {
  constructor() {
    super("Authentication.GetSecurityQuestionV3Response", [
      { no: 1, name: "securityQuestion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "backupKeyDate",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 3, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "iterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<GetSecurityQuestionV3Response>): GetSecurityQuestionV3Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.securityQuestion = "";
    message.backupKeyDate = BigInt(0);
    message.salt = new Uint8Array(0);
    message.iterations = 0;
    if (value !== undefined)
      reflectionMergePartial<GetSecurityQuestionV3Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetSecurityQuestionV3Response,
  ): GetSecurityQuestionV3Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string securityQuestion */ 1:
          message.securityQuestion = reader.string();
          break;
        case /* int64 backupKeyDate */ 2:
          message.backupKeyDate = reader.int64().toBigInt();
          break;
        case /* bytes salt */ 3:
          message.salt = reader.bytes();
          break;
        case /* int32 iterations */ 4:
          message.iterations = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetSecurityQuestionV3Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string securityQuestion = 1; */
    if (message.securityQuestion !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.securityQuestion);
    /* int64 backupKeyDate = 2; */
    if (message.backupKeyDate !== BigInt(0))
      writer.tag(2, WireType.Varint).int64(message.backupKeyDate);
    /* bytes salt = 3; */
    if (message.salt.length) writer.tag(3, WireType.LengthDelimited).bytes(message.salt);
    /* int32 iterations = 4; */
    if (message.iterations !== 0) writer.tag(4, WireType.Varint).int32(message.iterations);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetSecurityQuestionV3Response
 */
export const GetSecurityQuestionV3Response = new GetSecurityQuestionV3Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDataKeyBackupV3Request$Type extends MessageType<GetDataKeyBackupV3Request> {
  constructor() {
    super("Authentication.GetDataKeyBackupV3Request", [
      { no: 1, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "verificationCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "securityAnswerHash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<GetDataKeyBackupV3Request>): GetDataKeyBackupV3Request {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedLoginToken = new Uint8Array(0);
    message.verificationCode = "";
    message.securityAnswerHash = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<GetDataKeyBackupV3Request>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetDataKeyBackupV3Request,
  ): GetDataKeyBackupV3Request {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 1:
          message.encryptedLoginToken = reader.bytes();
          break;
        case /* string verificationCode */ 2:
          message.verificationCode = reader.string();
          break;
        case /* bytes securityAnswerHash */ 3:
          message.securityAnswerHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetDataKeyBackupV3Request,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedLoginToken = 1; */
    if (message.encryptedLoginToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    /* string verificationCode = 2; */
    if (message.verificationCode !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.verificationCode);
    /* bytes securityAnswerHash = 3; */
    if (message.securityAnswerHash.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.securityAnswerHash);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetDataKeyBackupV3Request
 */
export const GetDataKeyBackupV3Request = new GetDataKeyBackupV3Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordRules$Type extends MessageType<PasswordRules> {
  constructor() {
    super("Authentication.PasswordRules", [
      { no: 1, name: "ruleType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "match", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "minimum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<PasswordRules>): PasswordRules {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ruleType = "";
    message.match = false;
    message.pattern = "";
    message.description = "";
    message.minimum = 0;
    message.value = "";
    if (value !== undefined) reflectionMergePartial<PasswordRules>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasswordRules,
  ): PasswordRules {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ruleType */ 1:
          message.ruleType = reader.string();
          break;
        case /* bool match */ 2:
          message.match = reader.bool();
          break;
        case /* string pattern */ 3:
          message.pattern = reader.string();
          break;
        case /* string description */ 4:
          message.description = reader.string();
          break;
        case /* int32 minimum */ 5:
          message.minimum = reader.int32();
          break;
        case /* string value */ 6:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasswordRules,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ruleType = 1; */
    if (message.ruleType !== "") writer.tag(1, WireType.LengthDelimited).string(message.ruleType);
    /* bool match = 2; */
    if (message.match !== false) writer.tag(2, WireType.Varint).bool(message.match);
    /* string pattern = 3; */
    if (message.pattern !== "") writer.tag(3, WireType.LengthDelimited).string(message.pattern);
    /* string description = 4; */
    if (message.description !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.description);
    /* int32 minimum = 5; */
    if (message.minimum !== 0) writer.tag(5, WireType.Varint).int32(message.minimum);
    /* string value = 6; */
    if (message.value !== "") writer.tag(6, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasswordRules
 */
export const PasswordRules = new PasswordRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDataKeyBackupV3Response$Type extends MessageType<GetDataKeyBackupV3Response> {
  constructor() {
    super("Authentication.GetDataKeyBackupV3Response", [
      { no: 1, name: "dataKeyBackup", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "dataKeyBackupDate",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 3, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "encryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "clientKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 6, name: "encryptedSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 7,
        name: "passwordRules",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PasswordRules,
      },
      { no: 8, name: "passwordRulesIntro", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: "minimumPbkdf2Iterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 10, name: "keyType", kind: "enum", T: () => ["Enterprise.KeyType", KeyType] },
    ]);
  }
  create(value?: PartialMessage<GetDataKeyBackupV3Response>): GetDataKeyBackupV3Response {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.dataKeyBackup = new Uint8Array(0);
    message.dataKeyBackupDate = BigInt(0);
    message.publicKey = new Uint8Array(0);
    message.encryptedPrivateKey = new Uint8Array(0);
    message.clientKey = new Uint8Array(0);
    message.encryptedSessionToken = new Uint8Array(0);
    message.passwordRules = [];
    message.passwordRulesIntro = "";
    message.minimumPbkdf2Iterations = 0;
    message.keyType = 0;
    if (value !== undefined)
      reflectionMergePartial<GetDataKeyBackupV3Response>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetDataKeyBackupV3Response,
  ): GetDataKeyBackupV3Response {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes dataKeyBackup */ 1:
          message.dataKeyBackup = reader.bytes();
          break;
        case /* int64 dataKeyBackupDate */ 2:
          message.dataKeyBackupDate = reader.int64().toBigInt();
          break;
        case /* bytes publicKey */ 3:
          message.publicKey = reader.bytes();
          break;
        case /* bytes encryptedPrivateKey */ 4:
          message.encryptedPrivateKey = reader.bytes();
          break;
        case /* bytes clientKey */ 5:
          message.clientKey = reader.bytes();
          break;
        case /* bytes encryptedSessionToken */ 6:
          message.encryptedSessionToken = reader.bytes();
          break;
        case /* repeated Authentication.PasswordRules passwordRules */ 7:
          message.passwordRules.push(
            PasswordRules.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string passwordRulesIntro */ 8:
          message.passwordRulesIntro = reader.string();
          break;
        case /* int32 minimumPbkdf2Iterations */ 9:
          message.minimumPbkdf2Iterations = reader.int32();
          break;
        case /* Enterprise.KeyType keyType */ 10:
          message.keyType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetDataKeyBackupV3Response,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes dataKeyBackup = 1; */
    if (message.dataKeyBackup.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.dataKeyBackup);
    /* int64 dataKeyBackupDate = 2; */
    if (message.dataKeyBackupDate !== BigInt(0))
      writer.tag(2, WireType.Varint).int64(message.dataKeyBackupDate);
    /* bytes publicKey = 3; */
    if (message.publicKey.length) writer.tag(3, WireType.LengthDelimited).bytes(message.publicKey);
    /* bytes encryptedPrivateKey = 4; */
    if (message.encryptedPrivateKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedPrivateKey);
    /* bytes clientKey = 5; */
    if (message.clientKey.length) writer.tag(5, WireType.LengthDelimited).bytes(message.clientKey);
    /* bytes encryptedSessionToken = 6; */
    if (message.encryptedSessionToken.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.encryptedSessionToken);
    /* repeated Authentication.PasswordRules passwordRules = 7; */
    for (let i = 0; i < message.passwordRules.length; i++)
      PasswordRules.internalBinaryWrite(
        message.passwordRules[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string passwordRulesIntro = 8; */
    if (message.passwordRulesIntro !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.passwordRulesIntro);
    /* int32 minimumPbkdf2Iterations = 9; */
    if (message.minimumPbkdf2Iterations !== 0)
      writer.tag(9, WireType.Varint).int32(message.minimumPbkdf2Iterations);
    /* Enterprise.KeyType keyType = 10; */
    if (message.keyType !== 0) writer.tag(10, WireType.Varint).int32(message.keyType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetDataKeyBackupV3Response
 */
export const GetDataKeyBackupV3Response = new GetDataKeyBackupV3Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPublicKeysRequest$Type extends MessageType<GetPublicKeysRequest> {
  constructor() {
    super("Authentication.GetPublicKeysRequest", [
      {
        no: 1,
        name: "usernames",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<GetPublicKeysRequest>): GetPublicKeysRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.usernames = [];
    if (value !== undefined) reflectionMergePartial<GetPublicKeysRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetPublicKeysRequest,
  ): GetPublicKeysRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string usernames */ 1:
          message.usernames.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetPublicKeysRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string usernames = 1; */
    for (let i = 0; i < message.usernames.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.usernames[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetPublicKeysRequest
 */
export const GetPublicKeysRequest = new GetPublicKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKeyResponse$Type extends MessageType<PublicKeyResponse> {
  constructor() {
    super("Authentication.PublicKeyResponse", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "publicEccKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "errorCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<PublicKeyResponse>): PublicKeyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    message.publicKey = new Uint8Array(0);
    message.publicEccKey = new Uint8Array(0);
    message.message = "";
    message.errorCode = "";
    if (value !== undefined) reflectionMergePartial<PublicKeyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PublicKeyResponse,
  ): PublicKeyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        case /* bytes publicKey */ 2:
          message.publicKey = reader.bytes();
          break;
        case /* bytes publicEccKey */ 3:
          message.publicEccKey = reader.bytes();
          break;
        case /* string message */ 4:
          message.message = reader.string();
          break;
        case /* string errorCode */ 5:
          message.errorCode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PublicKeyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    /* bytes publicKey = 2; */
    if (message.publicKey.length) writer.tag(2, WireType.LengthDelimited).bytes(message.publicKey);
    /* bytes publicEccKey = 3; */
    if (message.publicEccKey.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.publicEccKey);
    /* string message = 4; */
    if (message.message !== "") writer.tag(4, WireType.LengthDelimited).string(message.message);
    /* string errorCode = 5; */
    if (message.errorCode !== "") writer.tag(5, WireType.LengthDelimited).string(message.errorCode);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PublicKeyResponse
 */
export const PublicKeyResponse = new PublicKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPublicKeysResponse$Type extends MessageType<GetPublicKeysResponse> {
  constructor() {
    super("Authentication.GetPublicKeysResponse", [
      {
        no: 1,
        name: "keyResponses",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PublicKeyResponse,
      },
    ]);
  }
  create(value?: PartialMessage<GetPublicKeysResponse>): GetPublicKeysResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keyResponses = [];
    if (value !== undefined) reflectionMergePartial<GetPublicKeysResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetPublicKeysResponse,
  ): GetPublicKeysResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.PublicKeyResponse keyResponses */ 1:
          message.keyResponses.push(
            PublicKeyResponse.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetPublicKeysResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.PublicKeyResponse keyResponses = 1; */
    for (let i = 0; i < message.keyResponses.length; i++)
      PublicKeyResponse.internalBinaryWrite(
        message.keyResponses[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetPublicKeysResponse
 */
export const GetPublicKeysResponse = new GetPublicKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEccKeyPairRequest$Type extends MessageType<SetEccKeyPairRequest> {
  constructor() {
    super("Authentication.SetEccKeyPairRequest", [
      { no: 1, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<SetEccKeyPairRequest>): SetEccKeyPairRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.publicKey = new Uint8Array(0);
    message.encryptedPrivateKey = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<SetEccKeyPairRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetEccKeyPairRequest,
  ): SetEccKeyPairRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes publicKey */ 1:
          message.publicKey = reader.bytes();
          break;
        case /* bytes encryptedPrivateKey */ 2:
          message.encryptedPrivateKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SetEccKeyPairRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes publicKey = 1; */
    if (message.publicKey.length) writer.tag(1, WireType.LengthDelimited).bytes(message.publicKey);
    /* bytes encryptedPrivateKey = 2; */
    if (message.encryptedPrivateKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedPrivateKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SetEccKeyPairRequest
 */
export const SetEccKeyPairRequest = new SetEccKeyPairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEccKeyPairsRequest$Type extends MessageType<SetEccKeyPairsRequest> {
  constructor() {
    super("Authentication.SetEccKeyPairsRequest", [
      {
        no: 1,
        name: "teamKeys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TeamEccKeyPair,
      },
    ]);
  }
  create(value?: PartialMessage<SetEccKeyPairsRequest>): SetEccKeyPairsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.teamKeys = [];
    if (value !== undefined) reflectionMergePartial<SetEccKeyPairsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetEccKeyPairsRequest,
  ): SetEccKeyPairsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.TeamEccKeyPair teamKeys */ 1:
          message.teamKeys.push(
            TeamEccKeyPair.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SetEccKeyPairsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.TeamEccKeyPair teamKeys = 1; */
    for (let i = 0; i < message.teamKeys.length; i++)
      TeamEccKeyPair.internalBinaryWrite(
        message.teamKeys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SetEccKeyPairsRequest
 */
export const SetEccKeyPairsRequest = new SetEccKeyPairsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetEccKeyPairsResponse$Type extends MessageType<SetEccKeyPairsResponse> {
  constructor() {
    super("Authentication.SetEccKeyPairsResponse", [
      {
        no: 1,
        name: "teamKeys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TeamEccKeyPairResponse,
      },
    ]);
  }
  create(value?: PartialMessage<SetEccKeyPairsResponse>): SetEccKeyPairsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.teamKeys = [];
    if (value !== undefined) reflectionMergePartial<SetEccKeyPairsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetEccKeyPairsResponse,
  ): SetEccKeyPairsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.TeamEccKeyPairResponse teamKeys */ 1:
          message.teamKeys.push(
            TeamEccKeyPairResponse.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SetEccKeyPairsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.TeamEccKeyPairResponse teamKeys = 1; */
    for (let i = 0; i < message.teamKeys.length; i++)
      TeamEccKeyPairResponse.internalBinaryWrite(
        message.teamKeys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SetEccKeyPairsResponse
 */
export const SetEccKeyPairsResponse = new SetEccKeyPairsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamEccKeyPair$Type extends MessageType<TeamEccKeyPair> {
  constructor() {
    super("Authentication.TeamEccKeyPair", [
      { no: 1, name: "teamUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "encryptedPrivateKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<TeamEccKeyPair>): TeamEccKeyPair {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.teamUid = new Uint8Array(0);
    message.publicKey = new Uint8Array(0);
    message.encryptedPrivateKey = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<TeamEccKeyPair>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TeamEccKeyPair,
  ): TeamEccKeyPair {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes teamUid */ 1:
          message.teamUid = reader.bytes();
          break;
        case /* bytes publicKey */ 2:
          message.publicKey = reader.bytes();
          break;
        case /* bytes encryptedPrivateKey */ 3:
          message.encryptedPrivateKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TeamEccKeyPair,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes teamUid = 1; */
    if (message.teamUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.teamUid);
    /* bytes publicKey = 2; */
    if (message.publicKey.length) writer.tag(2, WireType.LengthDelimited).bytes(message.publicKey);
    /* bytes encryptedPrivateKey = 3; */
    if (message.encryptedPrivateKey.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.encryptedPrivateKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TeamEccKeyPair
 */
export const TeamEccKeyPair = new TeamEccKeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamEccKeyPairResponse$Type extends MessageType<TeamEccKeyPairResponse> {
  constructor() {
    super("Authentication.TeamEccKeyPairResponse", [
      { no: 1, name: "teamUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "status",
        kind: "enum",
        T: () => ["Authentication.GenericStatus", GenericStatus],
      },
    ]);
  }
  create(value?: PartialMessage<TeamEccKeyPairResponse>): TeamEccKeyPairResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.teamUid = new Uint8Array(0);
    message.status = 0;
    if (value !== undefined) reflectionMergePartial<TeamEccKeyPairResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TeamEccKeyPairResponse,
  ): TeamEccKeyPairResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes teamUid */ 1:
          message.teamUid = reader.bytes();
          break;
        case /* Authentication.GenericStatus status */ 2:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TeamEccKeyPairResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes teamUid = 1; */
    if (message.teamUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.teamUid);
    /* Authentication.GenericStatus status = 2; */
    if (message.status !== 0) writer.tag(2, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TeamEccKeyPairResponse
 */
export const TeamEccKeyPairResponse = new TeamEccKeyPairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKsmPublicKeysRequest$Type extends MessageType<GetKsmPublicKeysRequest> {
  constructor() {
    super("Authentication.GetKsmPublicKeysRequest", [
      {
        no: 1,
        name: "clientIds",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 2,
        name: "controllerUids",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<GetKsmPublicKeysRequest>): GetKsmPublicKeysRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientIds = [];
    message.controllerUids = [];
    if (value !== undefined) reflectionMergePartial<GetKsmPublicKeysRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetKsmPublicKeysRequest,
  ): GetKsmPublicKeysRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes clientIds */ 1:
          message.clientIds.push(reader.bytes());
          break;
        case /* repeated bytes controllerUids */ 2:
          message.controllerUids.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetKsmPublicKeysRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes clientIds = 1; */
    for (let i = 0; i < message.clientIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.clientIds[i]);
    /* repeated bytes controllerUids = 2; */
    for (let i = 0; i < message.controllerUids.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.controllerUids[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetKsmPublicKeysRequest
 */
export const GetKsmPublicKeysRequest = new GetKsmPublicKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DevicePublicKeyResponse$Type extends MessageType<DevicePublicKeyResponse> {
  constructor() {
    super("Authentication.DevicePublicKeyResponse", [
      { no: 1, name: "clientId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "controllerUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<DevicePublicKeyResponse>): DevicePublicKeyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.clientId = new Uint8Array(0);
    message.publicKey = new Uint8Array(0);
    message.controllerUid = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<DevicePublicKeyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DevicePublicKeyResponse,
  ): DevicePublicKeyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes clientId */ 1:
          message.clientId = reader.bytes();
          break;
        case /* bytes publicKey */ 2:
          message.publicKey = reader.bytes();
          break;
        case /* bytes controllerUid */ 3:
          message.controllerUid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DevicePublicKeyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes clientId = 1; */
    if (message.clientId.length) writer.tag(1, WireType.LengthDelimited).bytes(message.clientId);
    /* bytes publicKey = 2; */
    if (message.publicKey.length) writer.tag(2, WireType.LengthDelimited).bytes(message.publicKey);
    /* bytes controllerUid = 3; */
    if (message.controllerUid.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.controllerUid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DevicePublicKeyResponse
 */
export const DevicePublicKeyResponse = new DevicePublicKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKsmPublicKeysResponse$Type extends MessageType<GetKsmPublicKeysResponse> {
  constructor() {
    super("Authentication.GetKsmPublicKeysResponse", [
      {
        no: 1,
        name: "keyResponses",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => DevicePublicKeyResponse,
      },
    ]);
  }
  create(value?: PartialMessage<GetKsmPublicKeysResponse>): GetKsmPublicKeysResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keyResponses = [];
    if (value !== undefined) reflectionMergePartial<GetKsmPublicKeysResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetKsmPublicKeysResponse,
  ): GetKsmPublicKeysResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.DevicePublicKeyResponse keyResponses */ 1:
          message.keyResponses.push(
            DevicePublicKeyResponse.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetKsmPublicKeysResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.DevicePublicKeyResponse keyResponses = 1; */
    for (let i = 0; i < message.keyResponses.length; i++)
      DevicePublicKeyResponse.internalBinaryWrite(
        message.keyResponses[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetKsmPublicKeysResponse
 */
export const GetKsmPublicKeysResponse = new GetKsmPublicKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddAppSharesRequest$Type extends MessageType<AddAppSharesRequest> {
  constructor() {
    super("Authentication.AddAppSharesRequest", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "shares",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => AppShareAdd,
      },
    ]);
  }
  create(value?: PartialMessage<AddAppSharesRequest>): AddAppSharesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.shares = [];
    if (value !== undefined) reflectionMergePartial<AddAppSharesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddAppSharesRequest,
  ): AddAppSharesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* repeated Authentication.AppShareAdd shares */ 2:
          message.shares.push(AppShareAdd.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddAppSharesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* repeated Authentication.AppShareAdd shares = 2; */
    for (let i = 0; i < message.shares.length; i++)
      AppShareAdd.internalBinaryWrite(
        message.shares[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AddAppSharesRequest
 */
export const AddAppSharesRequest = new AddAppSharesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveAppSharesRequest$Type extends MessageType<RemoveAppSharesRequest> {
  constructor() {
    super("Authentication.RemoveAppSharesRequest", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "shares",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<RemoveAppSharesRequest>): RemoveAppSharesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.shares = [];
    if (value !== undefined) reflectionMergePartial<RemoveAppSharesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveAppSharesRequest,
  ): RemoveAppSharesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* repeated bytes shares */ 2:
          message.shares.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveAppSharesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* repeated bytes shares = 2; */
    for (let i = 0; i < message.shares.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.shares[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RemoveAppSharesRequest
 */
export const RemoveAppSharesRequest = new RemoveAppSharesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppShareAdd$Type extends MessageType<AppShareAdd> {
  constructor() {
    super("Authentication.AppShareAdd", [
      { no: 2, name: "secretUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "shareType",
        kind: "enum",
        T: () => ["Authentication.ApplicationShareType", ApplicationShareType],
      },
      { no: 4, name: "encryptedSecretKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "editable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<AppShareAdd>): AppShareAdd {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.secretUid = new Uint8Array(0);
    message.shareType = 0;
    message.encryptedSecretKey = new Uint8Array(0);
    message.editable = false;
    if (value !== undefined) reflectionMergePartial<AppShareAdd>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppShareAdd,
  ): AppShareAdd {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes secretUid */ 2:
          message.secretUid = reader.bytes();
          break;
        case /* Authentication.ApplicationShareType shareType */ 3:
          message.shareType = reader.int32();
          break;
        case /* bytes encryptedSecretKey */ 4:
          message.encryptedSecretKey = reader.bytes();
          break;
        case /* bool editable */ 5:
          message.editable = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppShareAdd,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes secretUid = 2; */
    if (message.secretUid.length) writer.tag(2, WireType.LengthDelimited).bytes(message.secretUid);
    /* Authentication.ApplicationShareType shareType = 3; */
    if (message.shareType !== 0) writer.tag(3, WireType.Varint).int32(message.shareType);
    /* bytes encryptedSecretKey = 4; */
    if (message.encryptedSecretKey.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedSecretKey);
    /* bool editable = 5; */
    if (message.editable !== false) writer.tag(5, WireType.Varint).bool(message.editable);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AppShareAdd
 */
export const AppShareAdd = new AppShareAdd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppShare$Type extends MessageType<AppShare> {
  constructor() {
    super("Authentication.AppShare", [
      { no: 1, name: "secretUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "shareType",
        kind: "enum",
        T: () => ["Authentication.ApplicationShareType", ApplicationShareType],
      },
      { no: 3, name: "editable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 4,
        name: "createdOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 5, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<AppShare>): AppShare {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.secretUid = new Uint8Array(0);
    message.shareType = 0;
    message.editable = false;
    message.createdOn = BigInt(0);
    message.data = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<AppShare>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppShare,
  ): AppShare {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes secretUid */ 1:
          message.secretUid = reader.bytes();
          break;
        case /* Authentication.ApplicationShareType shareType */ 2:
          message.shareType = reader.int32();
          break;
        case /* bool editable */ 3:
          message.editable = reader.bool();
          break;
        case /* int64 createdOn */ 4:
          message.createdOn = reader.int64().toBigInt();
          break;
        case /* bytes data */ 5:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppShare,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes secretUid = 1; */
    if (message.secretUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.secretUid);
    /* Authentication.ApplicationShareType shareType = 2; */
    if (message.shareType !== 0) writer.tag(2, WireType.Varint).int32(message.shareType);
    /* bool editable = 3; */
    if (message.editable !== false) writer.tag(3, WireType.Varint).bool(message.editable);
    /* int64 createdOn = 4; */
    if (message.createdOn !== BigInt(0)) writer.tag(4, WireType.Varint).int64(message.createdOn);
    /* bytes data = 5; */
    if (message.data.length) writer.tag(5, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AppShare
 */
export const AppShare = new AppShare$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddAppClientRequest$Type extends MessageType<AddAppClientRequest> {
  constructor() {
    super("Authentication.AddAppClientRequest", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedAppKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "clientId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 4, name: "lockIp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 5,
        name: "firstAccessExpireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "accessExpireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 7, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 8,
        name: "appClientType",
        kind: "enum",
        T: () => ["Enterprise.AppClientType", AppClientType],
      },
    ]);
  }
  create(value?: PartialMessage<AddAppClientRequest>): AddAppClientRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.encryptedAppKey = new Uint8Array(0);
    message.clientId = new Uint8Array(0);
    message.lockIp = false;
    message.firstAccessExpireOn = BigInt(0);
    message.accessExpireOn = BigInt(0);
    message.id = "";
    message.appClientType = 0;
    if (value !== undefined) reflectionMergePartial<AddAppClientRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddAppClientRequest,
  ): AddAppClientRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* bytes encryptedAppKey */ 2:
          message.encryptedAppKey = reader.bytes();
          break;
        case /* bytes clientId */ 3:
          message.clientId = reader.bytes();
          break;
        case /* bool lockIp */ 4:
          message.lockIp = reader.bool();
          break;
        case /* int64 firstAccessExpireOn */ 5:
          message.firstAccessExpireOn = reader.int64().toBigInt();
          break;
        case /* int64 accessExpireOn */ 6:
          message.accessExpireOn = reader.int64().toBigInt();
          break;
        case /* string id */ 7:
          message.id = reader.string();
          break;
        case /* Enterprise.AppClientType appClientType */ 8:
          message.appClientType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddAppClientRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* bytes encryptedAppKey = 2; */
    if (message.encryptedAppKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedAppKey);
    /* bytes clientId = 3; */
    if (message.clientId.length) writer.tag(3, WireType.LengthDelimited).bytes(message.clientId);
    /* bool lockIp = 4; */
    if (message.lockIp !== false) writer.tag(4, WireType.Varint).bool(message.lockIp);
    /* int64 firstAccessExpireOn = 5; */
    if (message.firstAccessExpireOn !== BigInt(0))
      writer.tag(5, WireType.Varint).int64(message.firstAccessExpireOn);
    /* int64 accessExpireOn = 6; */
    if (message.accessExpireOn !== BigInt(0))
      writer.tag(6, WireType.Varint).int64(message.accessExpireOn);
    /* string id = 7; */
    if (message.id !== "") writer.tag(7, WireType.LengthDelimited).string(message.id);
    /* Enterprise.AppClientType appClientType = 8; */
    if (message.appClientType !== 0) writer.tag(8, WireType.Varint).int32(message.appClientType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AddAppClientRequest
 */
export const AddAppClientRequest = new AddAppClientRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveAppClientsRequest$Type extends MessageType<RemoveAppClientsRequest> {
  constructor() {
    super("Authentication.RemoveAppClientsRequest", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "clients",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<RemoveAppClientsRequest>): RemoveAppClientsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.clients = [];
    if (value !== undefined) reflectionMergePartial<RemoveAppClientsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveAppClientsRequest,
  ): RemoveAppClientsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* repeated bytes clients */ 2:
          message.clients.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveAppClientsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* repeated bytes clients = 2; */
    for (let i = 0; i < message.clients.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.clients[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RemoveAppClientsRequest
 */
export const RemoveAppClientsRequest = new RemoveAppClientsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddExternalShareRequest$Type extends MessageType<AddExternalShareRequest> {
  constructor() {
    super("Authentication.AddExternalShareRequest", [
      { no: 1, name: "recordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedRecordKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "clientId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 4,
        name: "accessExpireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 5, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "isSelfDestruct", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 7, name: "isEditable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<AddExternalShareRequest>): AddExternalShareRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recordUid = new Uint8Array(0);
    message.encryptedRecordKey = new Uint8Array(0);
    message.clientId = new Uint8Array(0);
    message.accessExpireOn = BigInt(0);
    message.id = "";
    message.isSelfDestruct = false;
    message.isEditable = false;
    if (value !== undefined) reflectionMergePartial<AddExternalShareRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddExternalShareRequest,
  ): AddExternalShareRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes recordUid */ 1:
          message.recordUid = reader.bytes();
          break;
        case /* bytes encryptedRecordKey */ 2:
          message.encryptedRecordKey = reader.bytes();
          break;
        case /* bytes clientId */ 3:
          message.clientId = reader.bytes();
          break;
        case /* int64 accessExpireOn */ 4:
          message.accessExpireOn = reader.int64().toBigInt();
          break;
        case /* string id */ 5:
          message.id = reader.string();
          break;
        case /* bool isSelfDestruct */ 6:
          message.isSelfDestruct = reader.bool();
          break;
        case /* bool isEditable */ 7:
          message.isEditable = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddExternalShareRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes recordUid = 1; */
    if (message.recordUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.recordUid);
    /* bytes encryptedRecordKey = 2; */
    if (message.encryptedRecordKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedRecordKey);
    /* bytes clientId = 3; */
    if (message.clientId.length) writer.tag(3, WireType.LengthDelimited).bytes(message.clientId);
    /* int64 accessExpireOn = 4; */
    if (message.accessExpireOn !== BigInt(0))
      writer.tag(4, WireType.Varint).int64(message.accessExpireOn);
    /* string id = 5; */
    if (message.id !== "") writer.tag(5, WireType.LengthDelimited).string(message.id);
    /* bool isSelfDestruct = 6; */
    if (message.isSelfDestruct !== false)
      writer.tag(6, WireType.Varint).bool(message.isSelfDestruct);
    /* bool isEditable = 7; */
    if (message.isEditable !== false) writer.tag(7, WireType.Varint).bool(message.isEditable);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AddExternalShareRequest
 */
export const AddExternalShareRequest = new AddExternalShareRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppClient$Type extends MessageType<AppClient> {
  constructor() {
    super("Authentication.AppClient", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "clientId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "createdOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "firstAccess",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 5,
        name: "lastAccess",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 6, name: "publicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 7, name: "lockIp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 8, name: "ipAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 9,
        name: "firstAccessExpireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 10,
        name: "accessExpireOn",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 11,
        name: "appClientType",
        kind: "enum",
        T: () => ["Enterprise.AppClientType", AppClientType],
      },
      { no: 12, name: "canEdit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<AppClient>): AppClient {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.clientId = new Uint8Array(0);
    message.createdOn = BigInt(0);
    message.firstAccess = BigInt(0);
    message.lastAccess = BigInt(0);
    message.publicKey = new Uint8Array(0);
    message.lockIp = false;
    message.ipAddress = "";
    message.firstAccessExpireOn = BigInt(0);
    message.accessExpireOn = BigInt(0);
    message.appClientType = 0;
    message.canEdit = false;
    if (value !== undefined) reflectionMergePartial<AppClient>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppClient,
  ): AppClient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* bytes clientId */ 2:
          message.clientId = reader.bytes();
          break;
        case /* int64 createdOn */ 3:
          message.createdOn = reader.int64().toBigInt();
          break;
        case /* int64 firstAccess */ 4:
          message.firstAccess = reader.int64().toBigInt();
          break;
        case /* int64 lastAccess */ 5:
          message.lastAccess = reader.int64().toBigInt();
          break;
        case /* bytes publicKey */ 6:
          message.publicKey = reader.bytes();
          break;
        case /* bool lockIp */ 7:
          message.lockIp = reader.bool();
          break;
        case /* string ipAddress */ 8:
          message.ipAddress = reader.string();
          break;
        case /* int64 firstAccessExpireOn */ 9:
          message.firstAccessExpireOn = reader.int64().toBigInt();
          break;
        case /* int64 accessExpireOn */ 10:
          message.accessExpireOn = reader.int64().toBigInt();
          break;
        case /* Enterprise.AppClientType appClientType */ 11:
          message.appClientType = reader.int32();
          break;
        case /* bool canEdit */ 12:
          message.canEdit = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppClient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "") writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* bytes clientId = 2; */
    if (message.clientId.length) writer.tag(2, WireType.LengthDelimited).bytes(message.clientId);
    /* int64 createdOn = 3; */
    if (message.createdOn !== BigInt(0)) writer.tag(3, WireType.Varint).int64(message.createdOn);
    /* int64 firstAccess = 4; */
    if (message.firstAccess !== BigInt(0))
      writer.tag(4, WireType.Varint).int64(message.firstAccess);
    /* int64 lastAccess = 5; */
    if (message.lastAccess !== BigInt(0)) writer.tag(5, WireType.Varint).int64(message.lastAccess);
    /* bytes publicKey = 6; */
    if (message.publicKey.length) writer.tag(6, WireType.LengthDelimited).bytes(message.publicKey);
    /* bool lockIp = 7; */
    if (message.lockIp !== false) writer.tag(7, WireType.Varint).bool(message.lockIp);
    /* string ipAddress = 8; */
    if (message.ipAddress !== "") writer.tag(8, WireType.LengthDelimited).string(message.ipAddress);
    /* int64 firstAccessExpireOn = 9; */
    if (message.firstAccessExpireOn !== BigInt(0))
      writer.tag(9, WireType.Varint).int64(message.firstAccessExpireOn);
    /* int64 accessExpireOn = 10; */
    if (message.accessExpireOn !== BigInt(0))
      writer.tag(10, WireType.Varint).int64(message.accessExpireOn);
    /* Enterprise.AppClientType appClientType = 11; */
    if (message.appClientType !== 0) writer.tag(11, WireType.Varint).int32(message.appClientType);
    /* bool canEdit = 12; */
    if (message.canEdit !== false) writer.tag(12, WireType.Varint).bool(message.canEdit);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AppClient
 */
export const AppClient = new AppClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppInfoRequest$Type extends MessageType<GetAppInfoRequest> {
  constructor() {
    super("Authentication.GetAppInfoRequest", [
      {
        no: 1,
        name: "appRecordUid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<GetAppInfoRequest>): GetAppInfoRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = [];
    if (value !== undefined) reflectionMergePartial<GetAppInfoRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetAppInfoRequest,
  ): GetAppInfoRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes appRecordUid */ 1:
          message.appRecordUid.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetAppInfoRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes appRecordUid = 1; */
    for (let i = 0; i < message.appRecordUid.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetAppInfoRequest
 */
export const GetAppInfoRequest = new GetAppInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppInfo$Type extends MessageType<AppInfo> {
  constructor() {
    super("Authentication.AppInfo", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "shares",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => AppShare,
      },
      {
        no: 3,
        name: "clients",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => AppClient,
      },
      { no: 4, name: "isExternalShare", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<AppInfo>): AppInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.shares = [];
    message.clients = [];
    message.isExternalShare = false;
    if (value !== undefined) reflectionMergePartial<AppInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppInfo,
  ): AppInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* repeated Authentication.AppShare shares */ 2:
          message.shares.push(AppShare.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated Authentication.AppClient clients */ 3:
          message.clients.push(AppClient.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool isExternalShare */ 4:
          message.isExternalShare = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* repeated Authentication.AppShare shares = 2; */
    for (let i = 0; i < message.shares.length; i++)
      AppShare.internalBinaryWrite(
        message.shares[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.AppClient clients = 3; */
    for (let i = 0; i < message.clients.length; i++)
      AppClient.internalBinaryWrite(
        message.clients[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool isExternalShare = 4; */
    if (message.isExternalShare !== false)
      writer.tag(4, WireType.Varint).bool(message.isExternalShare);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AppInfo
 */
export const AppInfo = new AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppInfoResponse$Type extends MessageType<GetAppInfoResponse> {
  constructor() {
    super("Authentication.GetAppInfoResponse", [
      {
        no: 1,
        name: "appInfo",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => AppInfo,
      },
    ]);
  }
  create(value?: PartialMessage<GetAppInfoResponse>): GetAppInfoResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appInfo = [];
    if (value !== undefined) reflectionMergePartial<GetAppInfoResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetAppInfoResponse,
  ): GetAppInfoResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.AppInfo appInfo */ 1:
          message.appInfo.push(AppInfo.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetAppInfoResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.AppInfo appInfo = 1; */
    for (let i = 0; i < message.appInfo.length; i++)
      AppInfo.internalBinaryWrite(
        message.appInfo[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetAppInfoResponse
 */
export const GetAppInfoResponse = new GetAppInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplicationSummary$Type extends MessageType<ApplicationSummary> {
  constructor() {
    super("Authentication.ApplicationSummary", [
      { no: 1, name: "appRecordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "lastAccess",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 3, name: "recordShares", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "folderShares", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: "folderRecords", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: "clientCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: "expiredClientCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: "appData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ApplicationSummary>): ApplicationSummary {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.appRecordUid = new Uint8Array(0);
    message.lastAccess = BigInt(0);
    message.recordShares = 0;
    message.folderShares = 0;
    message.folderRecords = 0;
    message.clientCount = 0;
    message.expiredClientCount = 0;
    message.username = "";
    message.appData = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<ApplicationSummary>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ApplicationSummary,
  ): ApplicationSummary {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes appRecordUid */ 1:
          message.appRecordUid = reader.bytes();
          break;
        case /* int64 lastAccess */ 2:
          message.lastAccess = reader.int64().toBigInt();
          break;
        case /* int32 recordShares */ 3:
          message.recordShares = reader.int32();
          break;
        case /* int32 folderShares */ 4:
          message.folderShares = reader.int32();
          break;
        case /* int32 folderRecords */ 5:
          message.folderRecords = reader.int32();
          break;
        case /* int32 clientCount */ 6:
          message.clientCount = reader.int32();
          break;
        case /* int32 expiredClientCount */ 7:
          message.expiredClientCount = reader.int32();
          break;
        case /* string username */ 8:
          message.username = reader.string();
          break;
        case /* bytes appData */ 9:
          message.appData = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ApplicationSummary,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes appRecordUid = 1; */
    if (message.appRecordUid.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.appRecordUid);
    /* int64 lastAccess = 2; */
    if (message.lastAccess !== BigInt(0)) writer.tag(2, WireType.Varint).int64(message.lastAccess);
    /* int32 recordShares = 3; */
    if (message.recordShares !== 0) writer.tag(3, WireType.Varint).int32(message.recordShares);
    /* int32 folderShares = 4; */
    if (message.folderShares !== 0) writer.tag(4, WireType.Varint).int32(message.folderShares);
    /* int32 folderRecords = 5; */
    if (message.folderRecords !== 0) writer.tag(5, WireType.Varint).int32(message.folderRecords);
    /* int32 clientCount = 6; */
    if (message.clientCount !== 0) writer.tag(6, WireType.Varint).int32(message.clientCount);
    /* int32 expiredClientCount = 7; */
    if (message.expiredClientCount !== 0)
      writer.tag(7, WireType.Varint).int32(message.expiredClientCount);
    /* string username = 8; */
    if (message.username !== "") writer.tag(8, WireType.LengthDelimited).string(message.username);
    /* bytes appData = 9; */
    if (message.appData.length) writer.tag(9, WireType.LengthDelimited).bytes(message.appData);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ApplicationSummary
 */
export const ApplicationSummary = new ApplicationSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetApplicationsSummaryResponse$Type extends MessageType<GetApplicationsSummaryResponse> {
  constructor() {
    super("Authentication.GetApplicationsSummaryResponse", [
      {
        no: 1,
        name: "applicationSummary",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ApplicationSummary,
      },
    ]);
  }
  create(value?: PartialMessage<GetApplicationsSummaryResponse>): GetApplicationsSummaryResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.applicationSummary = [];
    if (value !== undefined)
      reflectionMergePartial<GetApplicationsSummaryResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetApplicationsSummaryResponse,
  ): GetApplicationsSummaryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.ApplicationSummary applicationSummary */ 1:
          message.applicationSummary.push(
            ApplicationSummary.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetApplicationsSummaryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.ApplicationSummary applicationSummary = 1; */
    for (let i = 0; i < message.applicationSummary.length; i++)
      ApplicationSummary.internalBinaryWrite(
        message.applicationSummary[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetApplicationsSummaryResponse
 */
export const GetApplicationsSummaryResponse = new GetApplicationsSummaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVerificationTokenRequest$Type extends MessageType<GetVerificationTokenRequest> {
  constructor() {
    super("Authentication.GetVerificationTokenRequest", [
      { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<GetVerificationTokenRequest>): GetVerificationTokenRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.username = "";
    if (value !== undefined)
      reflectionMergePartial<GetVerificationTokenRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetVerificationTokenRequest,
  ): GetVerificationTokenRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 1:
          message.username = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetVerificationTokenRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string username = 1; */
    if (message.username !== "") writer.tag(1, WireType.LengthDelimited).string(message.username);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetVerificationTokenRequest
 */
export const GetVerificationTokenRequest = new GetVerificationTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVerificationTokenResponse$Type extends MessageType<GetVerificationTokenResponse> {
  constructor() {
    super("Authentication.GetVerificationTokenResponse", [
      { no: 1, name: "encryptedVerificationToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<GetVerificationTokenResponse>): GetVerificationTokenResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedVerificationToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<GetVerificationTokenResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetVerificationTokenResponse,
  ): GetVerificationTokenResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedVerificationToken */ 1:
          message.encryptedVerificationToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetVerificationTokenResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedVerificationToken = 1; */
    if (message.encryptedVerificationToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedVerificationToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GetVerificationTokenResponse
 */
export const GetVerificationTokenResponse = new GetVerificationTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendShareInviteRequest$Type extends MessageType<SendShareInviteRequest> {
  constructor() {
    super("Authentication.SendShareInviteRequest", [
      { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<SendShareInviteRequest>): SendShareInviteRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.email = "";
    if (value !== undefined) reflectionMergePartial<SendShareInviteRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SendShareInviteRequest,
  ): SendShareInviteRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.email = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SendShareInviteRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.email !== "") writer.tag(1, WireType.LengthDelimited).string(message.email);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.SendShareInviteRequest
 */
export const SendShareInviteRequest = new SendShareInviteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeLimitedAccessRequest$Type extends MessageType<TimeLimitedAccessRequest> {
  constructor() {
    super("Authentication.TimeLimitedAccessRequest", [
      {
        no: 1,
        name: "accountUid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 2,
        name: "teamUid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "recordUid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
      { no: 4, name: "sharedObjectUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: "timeLimitedAccessType",
        kind: "enum",
        T: () => ["Authentication.TimeLimitedAccessType", TimeLimitedAccessType],
      },
      {
        no: 6,
        name: "expiration",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<TimeLimitedAccessRequest>): TimeLimitedAccessRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.accountUid = [];
    message.teamUid = [];
    message.recordUid = [];
    message.sharedObjectUid = new Uint8Array(0);
    message.timeLimitedAccessType = 0;
    message.expiration = BigInt(0);
    if (value !== undefined) reflectionMergePartial<TimeLimitedAccessRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TimeLimitedAccessRequest,
  ): TimeLimitedAccessRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes accountUid */ 1:
          message.accountUid.push(reader.bytes());
          break;
        case /* repeated bytes teamUid */ 2:
          message.teamUid.push(reader.bytes());
          break;
        case /* repeated bytes recordUid */ 3:
          message.recordUid.push(reader.bytes());
          break;
        case /* bytes sharedObjectUid */ 4:
          message.sharedObjectUid = reader.bytes();
          break;
        case /* Authentication.TimeLimitedAccessType timeLimitedAccessType */ 5:
          message.timeLimitedAccessType = reader.int32();
          break;
        case /* int64 expiration */ 6:
          message.expiration = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TimeLimitedAccessRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes accountUid = 1; */
    for (let i = 0; i < message.accountUid.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.accountUid[i]);
    /* repeated bytes teamUid = 2; */
    for (let i = 0; i < message.teamUid.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.teamUid[i]);
    /* repeated bytes recordUid = 3; */
    for (let i = 0; i < message.recordUid.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.recordUid[i]);
    /* bytes sharedObjectUid = 4; */
    if (message.sharedObjectUid.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.sharedObjectUid);
    /* Authentication.TimeLimitedAccessType timeLimitedAccessType = 5; */
    if (message.timeLimitedAccessType !== 0)
      writer.tag(5, WireType.Varint).int32(message.timeLimitedAccessType);
    /* int64 expiration = 6; */
    if (message.expiration !== BigInt(0)) writer.tag(6, WireType.Varint).int64(message.expiration);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TimeLimitedAccessRequest
 */
export const TimeLimitedAccessRequest = new TimeLimitedAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeLimitedAccessStatus$Type extends MessageType<TimeLimitedAccessStatus> {
  constructor() {
    super("Authentication.TimeLimitedAccessStatus", [
      { no: 1, name: "uid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<TimeLimitedAccessStatus>): TimeLimitedAccessStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uid = new Uint8Array(0);
    message.message = "";
    if (value !== undefined) reflectionMergePartial<TimeLimitedAccessStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TimeLimitedAccessStatus,
  ): TimeLimitedAccessStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes uid */ 1:
          message.uid = reader.bytes();
          break;
        case /* string message */ 2:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TimeLimitedAccessStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes uid = 1; */
    if (message.uid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.uid);
    /* string message = 2; */
    if (message.message !== "") writer.tag(2, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TimeLimitedAccessStatus
 */
export const TimeLimitedAccessStatus = new TimeLimitedAccessStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeLimitedAccessResponse$Type extends MessageType<TimeLimitedAccessResponse> {
  constructor() {
    super("Authentication.TimeLimitedAccessResponse", [
      {
        no: 1,
        name: "revision",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "userAccessStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TimeLimitedAccessStatus,
      },
      {
        no: 3,
        name: "teamAccessStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TimeLimitedAccessStatus,
      },
      {
        no: 4,
        name: "recordAccessStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TimeLimitedAccessStatus,
      },
    ]);
  }
  create(value?: PartialMessage<TimeLimitedAccessResponse>): TimeLimitedAccessResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.revision = BigInt(0);
    message.userAccessStatus = [];
    message.teamAccessStatus = [];
    message.recordAccessStatus = [];
    if (value !== undefined)
      reflectionMergePartial<TimeLimitedAccessResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TimeLimitedAccessResponse,
  ): TimeLimitedAccessResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 revision */ 1:
          message.revision = reader.int64().toBigInt();
          break;
        case /* repeated Authentication.TimeLimitedAccessStatus userAccessStatus */ 2:
          message.userAccessStatus.push(
            TimeLimitedAccessStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated Authentication.TimeLimitedAccessStatus teamAccessStatus */ 3:
          message.teamAccessStatus.push(
            TimeLimitedAccessStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated Authentication.TimeLimitedAccessStatus recordAccessStatus */ 4:
          message.recordAccessStatus.push(
            TimeLimitedAccessStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TimeLimitedAccessResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 revision = 1; */
    if (message.revision !== BigInt(0)) writer.tag(1, WireType.Varint).int64(message.revision);
    /* repeated Authentication.TimeLimitedAccessStatus userAccessStatus = 2; */
    for (let i = 0; i < message.userAccessStatus.length; i++)
      TimeLimitedAccessStatus.internalBinaryWrite(
        message.userAccessStatus[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.TimeLimitedAccessStatus teamAccessStatus = 3; */
    for (let i = 0; i < message.teamAccessStatus.length; i++)
      TimeLimitedAccessStatus.internalBinaryWrite(
        message.teamAccessStatus[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Authentication.TimeLimitedAccessStatus recordAccessStatus = 4; */
    for (let i = 0; i < message.recordAccessStatus.length; i++)
      TimeLimitedAccessStatus.internalBinaryWrite(
        message.recordAccessStatus[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TimeLimitedAccessResponse
 */
export const TimeLimitedAccessResponse = new TimeLimitedAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestDownloadRequest$Type extends MessageType<RequestDownloadRequest> {
  constructor() {
    super("Authentication.RequestDownloadRequest", [
      {
        no: 1,
        name: "fileNames",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<RequestDownloadRequest>): RequestDownloadRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.fileNames = [];
    if (value !== undefined) reflectionMergePartial<RequestDownloadRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RequestDownloadRequest,
  ): RequestDownloadRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string fileNames */ 1:
          message.fileNames.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RequestDownloadRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string fileNames = 1; */
    for (let i = 0; i < message.fileNames.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.fileNames[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RequestDownloadRequest
 */
export const RequestDownloadRequest = new RequestDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestDownloadResponse$Type extends MessageType<RequestDownloadResponse> {
  constructor() {
    super("Authentication.RequestDownloadResponse", [
      { no: 1, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "downloads",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => Download,
      },
    ]);
  }
  create(value?: PartialMessage<RequestDownloadResponse>): RequestDownloadResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.result = "";
    message.message = "";
    message.downloads = [];
    if (value !== undefined) reflectionMergePartial<RequestDownloadResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RequestDownloadResponse,
  ): RequestDownloadResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string result */ 1:
          message.result = reader.string();
          break;
        case /* string message */ 2:
          message.message = reader.string();
          break;
        case /* repeated Authentication.Download downloads */ 3:
          message.downloads.push(Download.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RequestDownloadResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string result = 1; */
    if (message.result !== "") writer.tag(1, WireType.LengthDelimited).string(message.result);
    /* string message = 2; */
    if (message.message !== "") writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* repeated Authentication.Download downloads = 3; */
    for (let i = 0; i < message.downloads.length; i++)
      Download.internalBinaryWrite(
        message.downloads[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.RequestDownloadResponse
 */
export const RequestDownloadResponse = new RequestDownloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Download$Type extends MessageType<Download> {
  constructor() {
    super("Authentication.Download", [
      { no: 1, name: "fileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "successStatusCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<Download>): Download {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.fileName = "";
    message.url = "";
    message.successStatusCode = 0;
    if (value !== undefined) reflectionMergePartial<Download>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Download,
  ): Download {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string fileName */ 1:
          message.fileName = reader.string();
          break;
        case /* string url */ 2:
          message.url = reader.string();
          break;
        case /* int32 successStatusCode */ 3:
          message.successStatusCode = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Download,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string fileName = 1; */
    if (message.fileName !== "") writer.tag(1, WireType.LengthDelimited).string(message.fileName);
    /* string url = 2; */
    if (message.url !== "") writer.tag(2, WireType.LengthDelimited).string(message.url);
    /* int32 successStatusCode = 3; */
    if (message.successStatusCode !== 0)
      writer.tag(3, WireType.Varint).int32(message.successStatusCode);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.Download
 */
export const Download = new Download$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserRequest$Type extends MessageType<DeleteUserRequest> {
  constructor() {
    super("Authentication.DeleteUserRequest", [
      { no: 1, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DeleteUserRequest>): DeleteUserRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.reason = "";
    if (value !== undefined) reflectionMergePartial<DeleteUserRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteUserRequest,
  ): DeleteUserRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string reason */ 1:
          message.reason = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteUserRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string reason = 1; */
    if (message.reason !== "") writer.tag(1, WireType.LengthDelimited).string(message.reason);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.DeleteUserRequest
 */
export const DeleteUserRequest = new DeleteUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMasterPasswordRequest$Type extends MessageType<ChangeMasterPasswordRequest> {
  constructor() {
    super("Authentication.ChangeMasterPasswordRequest", [
      { no: 1, name: "authVerifier", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptionParams", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "fromServiceProvider", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "iterationsChange", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeMasterPasswordRequest>): ChangeMasterPasswordRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.authVerifier = new Uint8Array(0);
    message.encryptionParams = new Uint8Array(0);
    message.fromServiceProvider = false;
    message.iterationsChange = false;
    if (value !== undefined)
      reflectionMergePartial<ChangeMasterPasswordRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeMasterPasswordRequest,
  ): ChangeMasterPasswordRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes authVerifier */ 1:
          message.authVerifier = reader.bytes();
          break;
        case /* bytes encryptionParams */ 2:
          message.encryptionParams = reader.bytes();
          break;
        case /* bool fromServiceProvider */ 3:
          message.fromServiceProvider = reader.bool();
          break;
        case /* bool iterationsChange */ 4:
          message.iterationsChange = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeMasterPasswordRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes authVerifier = 1; */
    if (message.authVerifier.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.authVerifier);
    /* bytes encryptionParams = 2; */
    if (message.encryptionParams.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptionParams);
    /* bool fromServiceProvider = 3; */
    if (message.fromServiceProvider !== false)
      writer.tag(3, WireType.Varint).bool(message.fromServiceProvider);
    /* bool iterationsChange = 4; */
    if (message.iterationsChange !== false)
      writer.tag(4, WireType.Varint).bool(message.iterationsChange);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeMasterPasswordRequest
 */
export const ChangeMasterPasswordRequest = new ChangeMasterPasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMasterPasswordResponse$Type extends MessageType<ChangeMasterPasswordResponse> {
  constructor() {
    super("Authentication.ChangeMasterPasswordResponse", [
      { no: 1, name: "encryptedSessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<ChangeMasterPasswordResponse>): ChangeMasterPasswordResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.encryptedSessionToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<ChangeMasterPasswordResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChangeMasterPasswordResponse,
  ): ChangeMasterPasswordResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedSessionToken */ 1:
          message.encryptedSessionToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChangeMasterPasswordResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes encryptedSessionToken = 1; */
    if (message.encryptedSessionToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.encryptedSessionToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.ChangeMasterPasswordResponse
 */
export const ChangeMasterPasswordResponse = new ChangeMasterPasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountRecoverySetupRequest$Type extends MessageType<AccountRecoverySetupRequest> {
  constructor() {
    super("Authentication.AccountRecoverySetupRequest", [
      { no: 1, name: "recoveryEncryptedDataKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "recoveryAuthHash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<AccountRecoverySetupRequest>): AccountRecoverySetupRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recoveryEncryptedDataKey = new Uint8Array(0);
    message.recoveryAuthHash = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<AccountRecoverySetupRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AccountRecoverySetupRequest,
  ): AccountRecoverySetupRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes recoveryEncryptedDataKey */ 1:
          message.recoveryEncryptedDataKey = reader.bytes();
          break;
        case /* bytes recoveryAuthHash */ 2:
          message.recoveryAuthHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AccountRecoverySetupRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes recoveryEncryptedDataKey = 1; */
    if (message.recoveryEncryptedDataKey.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.recoveryEncryptedDataKey);
    /* bytes recoveryAuthHash = 2; */
    if (message.recoveryAuthHash.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.recoveryAuthHash);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AccountRecoverySetupRequest
 */
export const AccountRecoverySetupRequest = new AccountRecoverySetupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountRecoveryVerifyCodeResponse$Type extends MessageType<AccountRecoveryVerifyCodeResponse> {
  constructor() {
    super("Authentication.AccountRecoveryVerifyCodeResponse", [
      {
        no: 1,
        name: "backupKeyType",
        kind: "enum",
        T: () => ["Authentication.BackupKeyType", BackupKeyType],
      },
      {
        no: 2,
        name: "backupKeyDate",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 3, name: "securityQuestion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "salt", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "iterations", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<AccountRecoveryVerifyCodeResponse>,
  ): AccountRecoveryVerifyCodeResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.backupKeyType = 0;
    message.backupKeyDate = BigInt(0);
    message.securityQuestion = "";
    message.salt = new Uint8Array(0);
    message.iterations = 0;
    if (value !== undefined)
      reflectionMergePartial<AccountRecoveryVerifyCodeResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AccountRecoveryVerifyCodeResponse,
  ): AccountRecoveryVerifyCodeResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.BackupKeyType backupKeyType */ 1:
          message.backupKeyType = reader.int32();
          break;
        case /* int64 backupKeyDate */ 2:
          message.backupKeyDate = reader.int64().toBigInt();
          break;
        case /* string securityQuestion */ 3:
          message.securityQuestion = reader.string();
          break;
        case /* bytes salt */ 4:
          message.salt = reader.bytes();
          break;
        case /* int32 iterations */ 5:
          message.iterations = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AccountRecoveryVerifyCodeResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.BackupKeyType backupKeyType = 1; */
    if (message.backupKeyType !== 0) writer.tag(1, WireType.Varint).int32(message.backupKeyType);
    /* int64 backupKeyDate = 2; */
    if (message.backupKeyDate !== BigInt(0))
      writer.tag(2, WireType.Varint).int64(message.backupKeyDate);
    /* string securityQuestion = 3; */
    if (message.securityQuestion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.securityQuestion);
    /* bytes salt = 4; */
    if (message.salt.length) writer.tag(4, WireType.LengthDelimited).bytes(message.salt);
    /* int32 iterations = 5; */
    if (message.iterations !== 0) writer.tag(5, WireType.Varint).int32(message.iterations);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.AccountRecoveryVerifyCodeResponse
 */
export const AccountRecoveryVerifyCodeResponse = new AccountRecoveryVerifyCodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyAccessLoginRequest$Type extends MessageType<EmergencyAccessLoginRequest> {
  constructor() {
    super("Authentication.EmergencyAccessLoginRequest", [
      { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<EmergencyAccessLoginRequest>): EmergencyAccessLoginRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.owner = "";
    if (value !== undefined)
      reflectionMergePartial<EmergencyAccessLoginRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EmergencyAccessLoginRequest,
  ): EmergencyAccessLoginRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string owner */ 1:
          message.owner = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EmergencyAccessLoginRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string owner = 1; */
    if (message.owner !== "") writer.tag(1, WireType.LengthDelimited).string(message.owner);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EmergencyAccessLoginRequest
 */
export const EmergencyAccessLoginRequest = new EmergencyAccessLoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyAccessLoginResponse$Type extends MessageType<EmergencyAccessLoginResponse> {
  constructor() {
    super("Authentication.EmergencyAccessLoginResponse", [
      { no: 1, name: "sessionToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "dataKey", kind: "message", T: () => TypedKey },
      { no: 3, name: "rsaPrivateKey", kind: "message", T: () => TypedKey },
      { no: 4, name: "eccPrivateKey", kind: "message", T: () => TypedKey },
    ]);
  }
  create(value?: PartialMessage<EmergencyAccessLoginResponse>): EmergencyAccessLoginResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.sessionToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<EmergencyAccessLoginResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EmergencyAccessLoginResponse,
  ): EmergencyAccessLoginResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes sessionToken */ 1:
          message.sessionToken = reader.bytes();
          break;
        case /* Enterprise.TypedKey dataKey */ 2:
          message.dataKey = TypedKey.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dataKey,
          );
          break;
        case /* Enterprise.TypedKey rsaPrivateKey */ 3:
          message.rsaPrivateKey = TypedKey.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rsaPrivateKey,
          );
          break;
        case /* Enterprise.TypedKey eccPrivateKey */ 4:
          message.eccPrivateKey = TypedKey.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.eccPrivateKey,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EmergencyAccessLoginResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes sessionToken = 1; */
    if (message.sessionToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.sessionToken);
    /* Enterprise.TypedKey dataKey = 2; */
    if (message.dataKey)
      TypedKey.internalBinaryWrite(
        message.dataKey,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Enterprise.TypedKey rsaPrivateKey = 3; */
    if (message.rsaPrivateKey)
      TypedKey.internalBinaryWrite(
        message.rsaPrivateKey,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* Enterprise.TypedKey eccPrivateKey = 4; */
    if (message.eccPrivateKey)
      TypedKey.internalBinaryWrite(
        message.eccPrivateKey,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.EmergencyAccessLoginResponse
 */
export const EmergencyAccessLoginResponse = new EmergencyAccessLoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTeamKey$Type extends MessageType<UserTeamKey> {
  constructor() {
    super("Authentication.UserTeamKey", [
      { no: 1, name: "teamUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "enterpriseUserId",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 4, name: "encryptedTeamKeyRSA", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 5, name: "encryptedTeamKeyEC", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 6,
        name: "status",
        kind: "enum",
        T: () => ["Authentication.GenericStatus", GenericStatus],
      },
    ]);
  }
  create(value?: PartialMessage<UserTeamKey>): UserTeamKey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.teamUid = new Uint8Array(0);
    message.username = "";
    message.enterpriseUserId = BigInt(0);
    message.encryptedTeamKeyRSA = new Uint8Array(0);
    message.encryptedTeamKeyEC = new Uint8Array(0);
    message.status = 0;
    if (value !== undefined) reflectionMergePartial<UserTeamKey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserTeamKey,
  ): UserTeamKey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes teamUid */ 1:
          message.teamUid = reader.bytes();
          break;
        case /* string username */ 2:
          message.username = reader.string();
          break;
        case /* int64 enterpriseUserId */ 3:
          message.enterpriseUserId = reader.int64().toBigInt();
          break;
        case /* bytes encryptedTeamKeyRSA */ 4:
          message.encryptedTeamKeyRSA = reader.bytes();
          break;
        case /* bytes encryptedTeamKeyEC */ 5:
          message.encryptedTeamKeyEC = reader.bytes();
          break;
        case /* Authentication.GenericStatus status */ 6:
          message.status = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserTeamKey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes teamUid = 1; */
    if (message.teamUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.teamUid);
    /* string username = 2; */
    if (message.username !== "") writer.tag(2, WireType.LengthDelimited).string(message.username);
    /* int64 enterpriseUserId = 3; */
    if (message.enterpriseUserId !== BigInt(0))
      writer.tag(3, WireType.Varint).int64(message.enterpriseUserId);
    /* bytes encryptedTeamKeyRSA = 4; */
    if (message.encryptedTeamKeyRSA.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedTeamKeyRSA);
    /* bytes encryptedTeamKeyEC = 5; */
    if (message.encryptedTeamKeyEC.length)
      writer.tag(5, WireType.LengthDelimited).bytes(message.encryptedTeamKeyEC);
    /* Authentication.GenericStatus status = 6; */
    if (message.status !== 0) writer.tag(6, WireType.Varint).int32(message.status);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UserTeamKey
 */
export const UserTeamKey = new UserTeamKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenericRequestResponse$Type extends MessageType<GenericRequestResponse> {
  constructor() {
    super("Authentication.GenericRequestResponse", [
      {
        no: 1,
        name: "request",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<GenericRequestResponse>): GenericRequestResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.request = [];
    if (value !== undefined) reflectionMergePartial<GenericRequestResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GenericRequestResponse,
  ): GenericRequestResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes request */ 1:
          message.request.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GenericRequestResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes request = 1; */
    for (let i = 0; i < message.request.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.request[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.GenericRequestResponse
 */
export const GenericRequestResponse = new GenericRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyRegistrationRequest$Type extends MessageType<PasskeyRegistrationRequest> {
  constructor() {
    super("Authentication.PasskeyRegistrationRequest", [
      {
        no: 1,
        name: "authenticatorAttachment",
        kind: "enum",
        T: () => ["Authentication.AuthenticatorAttachment", AuthenticatorAttachment],
      },
    ]);
  }
  create(value?: PartialMessage<PasskeyRegistrationRequest>): PasskeyRegistrationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.authenticatorAttachment = 0;
    if (value !== undefined)
      reflectionMergePartial<PasskeyRegistrationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyRegistrationRequest,
  ): PasskeyRegistrationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Authentication.AuthenticatorAttachment authenticatorAttachment */ 1:
          message.authenticatorAttachment = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyRegistrationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthenticatorAttachment authenticatorAttachment = 1; */
    if (message.authenticatorAttachment !== 0)
      writer.tag(1, WireType.Varint).int32(message.authenticatorAttachment);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyRegistrationRequest
 */
export const PasskeyRegistrationRequest = new PasskeyRegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyRegistrationResponse$Type extends MessageType<PasskeyRegistrationResponse> {
  constructor() {
    super("Authentication.PasskeyRegistrationResponse", [
      { no: 1, name: "challengeToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "pkCreationOptions", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyRegistrationResponse>): PasskeyRegistrationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.challengeToken = new Uint8Array(0);
    message.pkCreationOptions = "";
    if (value !== undefined)
      reflectionMergePartial<PasskeyRegistrationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyRegistrationResponse,
  ): PasskeyRegistrationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes challengeToken */ 1:
          message.challengeToken = reader.bytes();
          break;
        case /* string pkCreationOptions */ 2:
          message.pkCreationOptions = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyRegistrationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes challengeToken = 1; */
    if (message.challengeToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.challengeToken);
    /* string pkCreationOptions = 2; */
    if (message.pkCreationOptions !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.pkCreationOptions);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyRegistrationResponse
 */
export const PasskeyRegistrationResponse = new PasskeyRegistrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyRegistrationFinalization$Type extends MessageType<PasskeyRegistrationFinalization> {
  constructor() {
    super("Authentication.PasskeyRegistrationFinalization", [
      {
        no: 3,
        name: "friendlyName",
        kind: "scalar",
        oneof: "FriendlyName",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 1, name: "challengeToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "authenticatorResponse", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyRegistrationFinalization>): PasskeyRegistrationFinalization {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.FriendlyName = { oneofKind: undefined };
    message.challengeToken = new Uint8Array(0);
    message.authenticatorResponse = "";
    if (value !== undefined)
      reflectionMergePartial<PasskeyRegistrationFinalization>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyRegistrationFinalization,
  ): PasskeyRegistrationFinalization {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string friendlyName */ 3:
          message.FriendlyName = {
            oneofKind: "friendlyName",
            friendlyName: reader.string(),
          };
          break;
        case /* bytes challengeToken */ 1:
          message.challengeToken = reader.bytes();
          break;
        case /* string authenticatorResponse */ 2:
          message.authenticatorResponse = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyRegistrationFinalization,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes challengeToken = 1; */
    if (message.challengeToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.challengeToken);
    /* string authenticatorResponse = 2; */
    if (message.authenticatorResponse !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.authenticatorResponse);
    /* string friendlyName = 3; */
    if (message.FriendlyName.oneofKind === "friendlyName")
      writer.tag(3, WireType.LengthDelimited).string(message.FriendlyName.friendlyName);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyRegistrationFinalization
 */
export const PasskeyRegistrationFinalization = new PasskeyRegistrationFinalization$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyAuthenticationRequest$Type extends MessageType<PasskeyAuthenticationRequest> {
  constructor() {
    super("Authentication.PasskeyAuthenticationRequest", [
      { no: 5, name: "username", kind: "scalar", oneof: "Username", T: 9 /*ScalarType.STRING*/ },
      {
        no: 6,
        name: "encryptedLoginToken",
        kind: "scalar",
        oneof: "EncryptedLoginToken",
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 1,
        name: "authenticatorAttachment",
        kind: "enum",
        T: () => ["Authentication.AuthenticatorAttachment", AuthenticatorAttachment],
      },
      {
        no: 2,
        name: "passkeyPurpose",
        kind: "enum",
        T: () => ["Authentication.PasskeyPurpose", PasskeyPurpose],
      },
      { no: 3, name: "clientVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "encryptedDeviceToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyAuthenticationRequest>): PasskeyAuthenticationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.Username = { oneofKind: undefined };
    message.EncryptedLoginToken = { oneofKind: undefined };
    message.authenticatorAttachment = 0;
    message.passkeyPurpose = 0;
    message.clientVersion = "";
    message.encryptedDeviceToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<PasskeyAuthenticationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyAuthenticationRequest,
  ): PasskeyAuthenticationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */ 5:
          message.Username = {
            oneofKind: "username",
            username: reader.string(),
          };
          break;
        case /* bytes encryptedLoginToken */ 6:
          message.EncryptedLoginToken = {
            oneofKind: "encryptedLoginToken",
            encryptedLoginToken: reader.bytes(),
          };
          break;
        case /* Authentication.AuthenticatorAttachment authenticatorAttachment */ 1:
          message.authenticatorAttachment = reader.int32();
          break;
        case /* Authentication.PasskeyPurpose passkeyPurpose */ 2:
          message.passkeyPurpose = reader.int32();
          break;
        case /* string clientVersion */ 3:
          message.clientVersion = reader.string();
          break;
        case /* bytes encryptedDeviceToken */ 4:
          message.encryptedDeviceToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyAuthenticationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Authentication.AuthenticatorAttachment authenticatorAttachment = 1; */
    if (message.authenticatorAttachment !== 0)
      writer.tag(1, WireType.Varint).int32(message.authenticatorAttachment);
    /* Authentication.PasskeyPurpose passkeyPurpose = 2; */
    if (message.passkeyPurpose !== 0) writer.tag(2, WireType.Varint).int32(message.passkeyPurpose);
    /* string clientVersion = 3; */
    if (message.clientVersion !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.clientVersion);
    /* bytes encryptedDeviceToken = 4; */
    if (message.encryptedDeviceToken.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.encryptedDeviceToken);
    /* string username = 5; */
    if (message.Username.oneofKind === "username")
      writer.tag(5, WireType.LengthDelimited).string(message.Username.username);
    /* bytes encryptedLoginToken = 6; */
    if (message.EncryptedLoginToken.oneofKind === "encryptedLoginToken")
      writer
        .tag(6, WireType.LengthDelimited)
        .bytes(message.EncryptedLoginToken.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyAuthenticationRequest
 */
export const PasskeyAuthenticationRequest = new PasskeyAuthenticationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyAuthenticationResponse$Type extends MessageType<PasskeyAuthenticationResponse> {
  constructor() {
    super("Authentication.PasskeyAuthenticationResponse", [
      {
        no: 3,
        name: "encryptedLoginToken",
        kind: "scalar",
        oneof: "EncryptedLoginToken",
        T: 12 /*ScalarType.BYTES*/,
      },
      { no: 1, name: "pkRequestOptions", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "challengeToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyAuthenticationResponse>): PasskeyAuthenticationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.EncryptedLoginToken = { oneofKind: undefined };
    message.pkRequestOptions = "";
    message.challengeToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<PasskeyAuthenticationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyAuthenticationResponse,
  ): PasskeyAuthenticationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 3:
          message.EncryptedLoginToken = {
            oneofKind: "encryptedLoginToken",
            encryptedLoginToken: reader.bytes(),
          };
          break;
        case /* string pkRequestOptions */ 1:
          message.pkRequestOptions = reader.string();
          break;
        case /* bytes challengeToken */ 2:
          message.challengeToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyAuthenticationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string pkRequestOptions = 1; */
    if (message.pkRequestOptions !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.pkRequestOptions);
    /* bytes challengeToken = 2; */
    if (message.challengeToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.challengeToken);
    /* bytes encryptedLoginToken = 3; */
    if (message.EncryptedLoginToken.oneofKind === "encryptedLoginToken")
      writer
        .tag(3, WireType.LengthDelimited)
        .bytes(message.EncryptedLoginToken.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyAuthenticationResponse
 */
export const PasskeyAuthenticationResponse = new PasskeyAuthenticationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyValidationRequest$Type extends MessageType<PasskeyValidationRequest> {
  constructor() {
    super("Authentication.PasskeyValidationRequest", [
      {
        no: 4,
        name: "encryptedLoginToken",
        kind: "scalar",
        oneof: "EncryptedLoginToken",
        T: 12 /*ScalarType.BYTES*/,
      },
      { no: 1, name: "challengeToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "assertionResponse", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "passkeyPurpose",
        kind: "enum",
        T: () => ["Authentication.PasskeyPurpose", PasskeyPurpose],
      },
    ]);
  }
  create(value?: PartialMessage<PasskeyValidationRequest>): PasskeyValidationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.EncryptedLoginToken = { oneofKind: undefined };
    message.challengeToken = new Uint8Array(0);
    message.assertionResponse = new Uint8Array(0);
    message.passkeyPurpose = 0;
    if (value !== undefined) reflectionMergePartial<PasskeyValidationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyValidationRequest,
  ): PasskeyValidationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes encryptedLoginToken */ 4:
          message.EncryptedLoginToken = {
            oneofKind: "encryptedLoginToken",
            encryptedLoginToken: reader.bytes(),
          };
          break;
        case /* bytes challengeToken */ 1:
          message.challengeToken = reader.bytes();
          break;
        case /* bytes assertionResponse */ 2:
          message.assertionResponse = reader.bytes();
          break;
        case /* Authentication.PasskeyPurpose passkeyPurpose */ 3:
          message.passkeyPurpose = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyValidationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes challengeToken = 1; */
    if (message.challengeToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.challengeToken);
    /* bytes assertionResponse = 2; */
    if (message.assertionResponse.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.assertionResponse);
    /* Authentication.PasskeyPurpose passkeyPurpose = 3; */
    if (message.passkeyPurpose !== 0) writer.tag(3, WireType.Varint).int32(message.passkeyPurpose);
    /* bytes encryptedLoginToken = 4; */
    if (message.EncryptedLoginToken.oneofKind === "encryptedLoginToken")
      writer
        .tag(4, WireType.LengthDelimited)
        .bytes(message.EncryptedLoginToken.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyValidationRequest
 */
export const PasskeyValidationRequest = new PasskeyValidationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyValidationResponse$Type extends MessageType<PasskeyValidationResponse> {
  constructor() {
    super("Authentication.PasskeyValidationResponse", [
      { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: "encryptedLoginToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyValidationResponse>): PasskeyValidationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.isValid = false;
    message.encryptedLoginToken = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<PasskeyValidationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyValidationResponse,
  ): PasskeyValidationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool isValid */ 1:
          message.isValid = reader.bool();
          break;
        case /* bytes encryptedLoginToken */ 2:
          message.encryptedLoginToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyValidationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool isValid = 1; */
    if (message.isValid !== false) writer.tag(1, WireType.Varint).bool(message.isValid);
    /* bytes encryptedLoginToken = 2; */
    if (message.encryptedLoginToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedLoginToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyValidationResponse
 */
export const PasskeyValidationResponse = new PasskeyValidationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePasskeyRequest$Type extends MessageType<UpdatePasskeyRequest> {
  constructor() {
    super("Authentication.UpdatePasskeyRequest", [
      {
        no: 3,
        name: "friendlyName",
        kind: "scalar",
        oneof: "FriendlyName",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 1, name: "userId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "credentialId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<UpdatePasskeyRequest>): UpdatePasskeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.FriendlyName = { oneofKind: undefined };
    message.userId = 0;
    message.credentialId = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<UpdatePasskeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdatePasskeyRequest,
  ): UpdatePasskeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string friendlyName */ 3:
          message.FriendlyName = {
            oneofKind: "friendlyName",
            friendlyName: reader.string(),
          };
          break;
        case /* int32 userId */ 1:
          message.userId = reader.int32();
          break;
        case /* bytes credentialId */ 2:
          message.credentialId = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UpdatePasskeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 userId = 1; */
    if (message.userId !== 0) writer.tag(1, WireType.Varint).int32(message.userId);
    /* bytes credentialId = 2; */
    if (message.credentialId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.credentialId);
    /* string friendlyName = 3; */
    if (message.FriendlyName.oneofKind === "friendlyName")
      writer.tag(3, WireType.LengthDelimited).string(message.FriendlyName.friendlyName);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.UpdatePasskeyRequest
 */
export const UpdatePasskeyRequest = new UpdatePasskeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyListRequest$Type extends MessageType<PasskeyListRequest> {
  constructor() {
    super("Authentication.PasskeyListRequest", [
      { no: 1, name: "includeDisabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<PasskeyListRequest>): PasskeyListRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.includeDisabled = false;
    if (value !== undefined) reflectionMergePartial<PasskeyListRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyListRequest,
  ): PasskeyListRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool includeDisabled */ 1:
          message.includeDisabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyListRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool includeDisabled = 1; */
    if (message.includeDisabled !== false)
      writer.tag(1, WireType.Varint).bool(message.includeDisabled);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyListRequest
 */
export const PasskeyListRequest = new PasskeyListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyInfo$Type extends MessageType<PasskeyInfo> {
  constructor() {
    super("Authentication.PasskeyInfo", [
      { no: 1, name: "userId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "credentialId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "friendlyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "AAGUID", kind: "scalar", jsonName: "AAGUID", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "createdAtMillis",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "lastUsedMillis",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: "disabledAtMillis",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<PasskeyInfo>): PasskeyInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.userId = 0;
    message.credentialId = new Uint8Array(0);
    message.friendlyName = "";
    message.aAGUID = "";
    message.createdAtMillis = BigInt(0);
    message.lastUsedMillis = BigInt(0);
    message.disabledAtMillis = BigInt(0);
    if (value !== undefined) reflectionMergePartial<PasskeyInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyInfo,
  ): PasskeyInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 userId */ 1:
          message.userId = reader.int32();
          break;
        case /* bytes credentialId */ 2:
          message.credentialId = reader.bytes();
          break;
        case /* string friendlyName */ 3:
          message.friendlyName = reader.string();
          break;
        case /* string AAGUID */ 4:
          message.aAGUID = reader.string();
          break;
        case /* int64 createdAtMillis */ 5:
          message.createdAtMillis = reader.int64().toBigInt();
          break;
        case /* int64 lastUsedMillis */ 6:
          message.lastUsedMillis = reader.int64().toBigInt();
          break;
        case /* int64 disabledAtMillis */ 7:
          message.disabledAtMillis = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 userId = 1; */
    if (message.userId !== 0) writer.tag(1, WireType.Varint).int32(message.userId);
    /* bytes credentialId = 2; */
    if (message.credentialId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.credentialId);
    /* string friendlyName = 3; */
    if (message.friendlyName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.friendlyName);
    /* string AAGUID = 4; */
    if (message.aAGUID !== "") writer.tag(4, WireType.LengthDelimited).string(message.aAGUID);
    /* int64 createdAtMillis = 5; */
    if (message.createdAtMillis !== BigInt(0))
      writer.tag(5, WireType.Varint).int64(message.createdAtMillis);
    /* int64 lastUsedMillis = 6; */
    if (message.lastUsedMillis !== BigInt(0))
      writer.tag(6, WireType.Varint).int64(message.lastUsedMillis);
    /* int64 disabledAtMillis = 7; */
    if (message.disabledAtMillis !== BigInt(0))
      writer.tag(7, WireType.Varint).int64(message.disabledAtMillis);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyInfo
 */
export const PasskeyInfo = new PasskeyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasskeyListResponse$Type extends MessageType<PasskeyListResponse> {
  constructor() {
    super("Authentication.PasskeyListResponse", [
      {
        no: 1,
        name: "passkeyInfo",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PasskeyInfo,
      },
    ]);
  }
  create(value?: PartialMessage<PasskeyListResponse>): PasskeyListResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.passkeyInfo = [];
    if (value !== undefined) reflectionMergePartial<PasskeyListResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PasskeyListResponse,
  ): PasskeyListResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.PasskeyInfo passkeyInfo */ 1:
          message.passkeyInfo.push(
            PasskeyInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PasskeyListResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.PasskeyInfo passkeyInfo = 1; */
    for (let i = 0; i < message.passkeyInfo.length; i++)
      PasskeyInfo.internalBinaryWrite(
        message.passkeyInfo[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.PasskeyListResponse
 */
export const PasskeyListResponse = new PasskeyListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslationInfo$Type extends MessageType<TranslationInfo> {
  constructor() {
    super("Authentication.TranslationInfo", [
      { no: 1, name: "translationKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "translationValue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<TranslationInfo>): TranslationInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.translationKey = "";
    message.translationValue = "";
    if (value !== undefined) reflectionMergePartial<TranslationInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TranslationInfo,
  ): TranslationInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string translationKey */ 1:
          message.translationKey = reader.string();
          break;
        case /* string translationValue */ 2:
          message.translationValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TranslationInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string translationKey = 1; */
    if (message.translationKey !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.translationKey);
    /* string translationValue = 2; */
    if (message.translationValue !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.translationValue);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TranslationInfo
 */
export const TranslationInfo = new TranslationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslationRequest$Type extends MessageType<TranslationRequest> {
  constructor() {
    super("Authentication.TranslationRequest", [
      {
        no: 1,
        name: "translationKey",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<TranslationRequest>): TranslationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.translationKey = [];
    if (value !== undefined) reflectionMergePartial<TranslationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TranslationRequest,
  ): TranslationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string translationKey */ 1:
          message.translationKey.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TranslationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string translationKey = 1; */
    for (let i = 0; i < message.translationKey.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.translationKey[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TranslationRequest
 */
export const TranslationRequest = new TranslationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslationResponse$Type extends MessageType<TranslationResponse> {
  constructor() {
    super("Authentication.TranslationResponse", [
      {
        no: 1,
        name: "translationInfo",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => TranslationInfo,
      },
    ]);
  }
  create(value?: PartialMessage<TranslationResponse>): TranslationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.translationInfo = [];
    if (value !== undefined) reflectionMergePartial<TranslationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TranslationResponse,
  ): TranslationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Authentication.TranslationInfo translationInfo */ 1:
          message.translationInfo.push(
            TranslationInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TranslationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Authentication.TranslationInfo translationInfo = 1; */
    for (let i = 0; i < message.translationInfo.length; i++)
      TranslationInfo.internalBinaryWrite(
        message.translationInfo[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Authentication.TranslationResponse
 */
export const TranslationResponse = new TranslationResponse$Type();
