// @ts-nocheck
// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "breachwatch.proto" (package "BreachWatch", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message BreachWatch.BreachWatchRecordRequest
 */
export interface BreachWatchRecordRequest {
  /**
   * @generated from protobuf field: bytes recordUid = 1
   */
  recordUid: Uint8Array;
  /**
   * @generated from protobuf field: bytes encryptedData = 2
   */
  encryptedData: Uint8Array;
  /**
   * @generated from protobuf field: BreachWatch.BreachWatchInfoType breachWatchInfoType = 3
   */
  breachWatchInfoType: BreachWatchInfoType;
  /**
   * @generated from protobuf field: bool updateUserWhoScanned = 4
   */
  updateUserWhoScanned: boolean;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchUpdateRequest
 */
export interface BreachWatchUpdateRequest {
  /**
   * @generated from protobuf field: repeated BreachWatch.BreachWatchRecordRequest breachWatchRecordRequest = 1
   */
  breachWatchRecordRequest: BreachWatchRecordRequest[];
  /**
   * @generated from protobuf field: bytes encryptedData = 2
   */
  encryptedData: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchRecordStatus
 */
export interface BreachWatchRecordStatus {
  /**
   * @generated from protobuf field: bytes recordUid = 1
   */
  recordUid: Uint8Array;
  /**
   * @generated from protobuf field: string status = 2
   */
  status: string;
  /**
   * @generated from protobuf field: string reason = 3
   */
  reason: string;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchUpdateResponse
 */
export interface BreachWatchUpdateResponse {
  /**
   * @generated from protobuf field: repeated BreachWatch.BreachWatchRecordStatus breachWatchRecordStatus = 1
   */
  breachWatchRecordStatus: BreachWatchRecordStatus[];
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchTokenRequest
 */
export interface BreachWatchTokenRequest {
  /**
   * @generated from protobuf field: bytes breachWatchToken = 1
   */
  breachWatchToken: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchTokenResponse
 */
export interface BreachWatchTokenResponse {
  /**
   * @generated from protobuf field: bytes breachWatchToken = 1
   */
  breachWatchToken: Uint8Array;
  /**
   * @generated from protobuf field: bool clientEncrypted = 2
   */
  clientEncrypted: boolean;
}
/**
 * @generated from protobuf message BreachWatch.AnonymizedTokenResponse
 */
export interface AnonymizedTokenResponse {
  /**
   * @generated from protobuf field: bytes domainToken = 1
   */
  domainToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes emailToken = 2
   */
  emailToken: Uint8Array;
  /**
   * @generated from protobuf field: bytes passwordToken = 3
   */
  passwordToken: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.HashCheck
 */
export interface HashCheck {
  /**
   * @generated from protobuf field: bytes hash1 = 1
   */
  hash1: Uint8Array;
  /**
   * @generated from protobuf field: bytes euid = 2
   */
  euid: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchStatusRequest
 */
export interface BreachWatchStatusRequest {
  /**
   * @generated from protobuf field: bytes anonymizedToken = 1
   */
  anonymizedToken: Uint8Array;
  /**
   * @generated from protobuf field: repeated BreachWatch.HashCheck hashCheck = 2
   */
  hashCheck: HashCheck[];
  /**
   * @generated from protobuf field: repeated bytes removedEuid = 3
   */
  removedEuid: Uint8Array[];
}
/**
 * @generated from protobuf message BreachWatch.HashStatus
 */
export interface HashStatus {
  /**
   * @generated from protobuf field: bytes hash1 = 1
   */
  hash1: Uint8Array;
  /**
   * @generated from protobuf field: bytes euid = 2
   */
  euid: Uint8Array;
  /**
   * @generated from protobuf field: bool breachDetected = 3
   */
  breachDetected: boolean;
}
/**
 * @generated from protobuf message BreachWatch.BreachWatchStatusResponse
 */
export interface BreachWatchStatusResponse {
  /**
   * @generated from protobuf field: repeated BreachWatch.HashStatus hashStatus = 2
   */
  hashStatus: HashStatus[];
}
/**
 * @generated from protobuf message BreachWatch.EnterprisePublicKeyResponse
 */
export interface EnterprisePublicKeyResponse {
  /**
   * @generated from protobuf field: bytes enterprisePublicKey = 1
   */
  enterprisePublicKey: Uint8Array;
  /**
   * @generated from protobuf field: bytes enterpriseECCPublicKey = 2
   */
  enterpriseECCPublicKey: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.FreeScanRequest
 */
export interface FreeScanRequest {
  /**
   * @generated from protobuf field: bytes hashedEmail = 1
   */
  hashedEmail: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.FreeScanResponse
 */
export interface FreeScanResponse {
  /**
   * @generated from protobuf field: int32 emailBreaches = 1
   */
  emailBreaches: number;
  /**
   * @generated from protobuf field: int32 passwordBreaches = 2
   */
  passwordBreaches: number;
}
/**
 * @generated from protobuf message BreachWatch.PaidUserRequest
 */
export interface PaidUserRequest {
  /**
   * @generated from protobuf field: string email = 1
   */
  email: string;
}
/**
 * @generated from protobuf message BreachWatch.PaidUserResponse
 */
export interface PaidUserResponse {
  /**
   * @generated from protobuf field: bool paidUser = 1
   */
  paidUser: boolean;
}
/**
 * @generated from protobuf message BreachWatch.DetailedScanRequest
 */
export interface DetailedScanRequest {
  /**
   * @generated from protobuf field: string email = 1
   */
  email: string;
}
/**
 * @generated from protobuf message BreachWatch.UseOneTimeTokenRequest
 */
export interface UseOneTimeTokenRequest {
  /**
   * @generated from protobuf field: bytes token = 1
   */
  token: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.BreachEvent
 */
export interface BreachEvent {
  /**
   * @generated from protobuf field: string site = 1
   */
  site: string;
  /**
   * @generated from protobuf field: string email = 2
   */
  email: string;
  /**
   * @generated from protobuf field: bool passwordInBreach = 3
   */
  passwordInBreach: boolean;
  /**
   * @generated from protobuf field: string date = 4
   */
  date: string;
  /**
   * @generated from protobuf field: string description = 5
   */
  description: string;
}
/**
 * @generated from protobuf message BreachWatch.UseOneTimeTokenResponse
 */
export interface UseOneTimeTokenResponse {
  /**
   * @generated from protobuf field: int32 emailBreaches = 1
   */
  emailBreaches: number;
  /**
   * @generated from protobuf field: int32 passwordBreaches = 2
   */
  passwordBreaches: number;
  /**
   * @generated from protobuf field: repeated BreachWatch.BreachEvent breachEvents = 3
   */
  breachEvents: BreachEvent[];
  /**
   * @generated from protobuf field: string email = 4
   */
  email: string;
}
/**
 * @generated from protobuf message BreachWatch.OneTimeUseToken
 */
export interface OneTimeUseToken {
  /**
   * @generated from protobuf field: string email = 1
   */
  email: string;
  /**
   * @generated from protobuf field: string pad = 2
   */
  pad: string;
}
/**
 * @generated from protobuf message BreachWatch.FreePasswordScanRequest
 */
export interface FreePasswordScanRequest {
  /**
   * @generated from protobuf field: bytes hashedPassword = 1
   */
  hashedPassword: Uint8Array;
}
/**
 * @generated from protobuf message BreachWatch.FreePasswordScanResponse
 */
export interface FreePasswordScanResponse {
  /**
   * @generated from protobuf field: int64 passwordBreaches = 1
   */
  passwordBreaches: bigint;
}
/**
 * @generated from protobuf enum BreachWatch.BreachWatchInfoType
 */
export enum BreachWatchInfoType {
  /**
   * @generated from protobuf enum value: RECORD = 0;
   */
  RECORD = 0,
  /**
   * @generated from protobuf enum value: ALTERNATE_PASSWORD = 1;
   */
  ALTERNATE_PASSWORD = 1,
}
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchRecordRequest$Type extends MessageType<BreachWatchRecordRequest> {
  constructor() {
    super("BreachWatch.BreachWatchRecordRequest", [
      { no: 1, name: "recordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "encryptedData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 3,
        name: "breachWatchInfoType",
        kind: "enum",
        T: () => ["BreachWatch.BreachWatchInfoType", BreachWatchInfoType],
      },
      { no: 4, name: "updateUserWhoScanned", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<BreachWatchRecordRequest>): BreachWatchRecordRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recordUid = new Uint8Array(0);
    message.encryptedData = new Uint8Array(0);
    message.breachWatchInfoType = 0;
    message.updateUserWhoScanned = false;
    if (value !== undefined) reflectionMergePartial<BreachWatchRecordRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchRecordRequest,
  ): BreachWatchRecordRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes recordUid */ 1:
          message.recordUid = reader.bytes();
          break;
        case /* bytes encryptedData */ 2:
          message.encryptedData = reader.bytes();
          break;
        case /* BreachWatch.BreachWatchInfoType breachWatchInfoType */ 3:
          message.breachWatchInfoType = reader.int32();
          break;
        case /* bool updateUserWhoScanned */ 4:
          message.updateUserWhoScanned = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchRecordRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes recordUid = 1; */
    if (message.recordUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.recordUid);
    /* bytes encryptedData = 2; */
    if (message.encryptedData.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedData);
    /* BreachWatch.BreachWatchInfoType breachWatchInfoType = 3; */
    if (message.breachWatchInfoType !== 0)
      writer.tag(3, WireType.Varint).int32(message.breachWatchInfoType);
    /* bool updateUserWhoScanned = 4; */
    if (message.updateUserWhoScanned !== false)
      writer.tag(4, WireType.Varint).bool(message.updateUserWhoScanned);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchRecordRequest
 */
export const BreachWatchRecordRequest = new BreachWatchRecordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchUpdateRequest$Type extends MessageType<BreachWatchUpdateRequest> {
  constructor() {
    super("BreachWatch.BreachWatchUpdateRequest", [
      {
        no: 1,
        name: "breachWatchRecordRequest",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BreachWatchRecordRequest,
      },
      { no: 2, name: "encryptedData", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<BreachWatchUpdateRequest>): BreachWatchUpdateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.breachWatchRecordRequest = [];
    message.encryptedData = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<BreachWatchUpdateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchUpdateRequest,
  ): BreachWatchUpdateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated BreachWatch.BreachWatchRecordRequest breachWatchRecordRequest */ 1:
          message.breachWatchRecordRequest.push(
            BreachWatchRecordRequest.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bytes encryptedData */ 2:
          message.encryptedData = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchUpdateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated BreachWatch.BreachWatchRecordRequest breachWatchRecordRequest = 1; */
    for (let i = 0; i < message.breachWatchRecordRequest.length; i++)
      BreachWatchRecordRequest.internalBinaryWrite(
        message.breachWatchRecordRequest[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bytes encryptedData = 2; */
    if (message.encryptedData.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.encryptedData);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchUpdateRequest
 */
export const BreachWatchUpdateRequest = new BreachWatchUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchRecordStatus$Type extends MessageType<BreachWatchRecordStatus> {
  constructor() {
    super("BreachWatch.BreachWatchRecordStatus", [
      { no: 1, name: "recordUid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BreachWatchRecordStatus>): BreachWatchRecordStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recordUid = new Uint8Array(0);
    message.status = "";
    message.reason = "";
    if (value !== undefined) reflectionMergePartial<BreachWatchRecordStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchRecordStatus,
  ): BreachWatchRecordStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes recordUid */ 1:
          message.recordUid = reader.bytes();
          break;
        case /* string status */ 2:
          message.status = reader.string();
          break;
        case /* string reason */ 3:
          message.reason = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchRecordStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes recordUid = 1; */
    if (message.recordUid.length) writer.tag(1, WireType.LengthDelimited).bytes(message.recordUid);
    /* string status = 2; */
    if (message.status !== "") writer.tag(2, WireType.LengthDelimited).string(message.status);
    /* string reason = 3; */
    if (message.reason !== "") writer.tag(3, WireType.LengthDelimited).string(message.reason);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchRecordStatus
 */
export const BreachWatchRecordStatus = new BreachWatchRecordStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchUpdateResponse$Type extends MessageType<BreachWatchUpdateResponse> {
  constructor() {
    super("BreachWatch.BreachWatchUpdateResponse", [
      {
        no: 1,
        name: "breachWatchRecordStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BreachWatchRecordStatus,
      },
    ]);
  }
  create(value?: PartialMessage<BreachWatchUpdateResponse>): BreachWatchUpdateResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.breachWatchRecordStatus = [];
    if (value !== undefined)
      reflectionMergePartial<BreachWatchUpdateResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchUpdateResponse,
  ): BreachWatchUpdateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated BreachWatch.BreachWatchRecordStatus breachWatchRecordStatus */ 1:
          message.breachWatchRecordStatus.push(
            BreachWatchRecordStatus.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchUpdateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated BreachWatch.BreachWatchRecordStatus breachWatchRecordStatus = 1; */
    for (let i = 0; i < message.breachWatchRecordStatus.length; i++)
      BreachWatchRecordStatus.internalBinaryWrite(
        message.breachWatchRecordStatus[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchUpdateResponse
 */
export const BreachWatchUpdateResponse = new BreachWatchUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchTokenRequest$Type extends MessageType<BreachWatchTokenRequest> {
  constructor() {
    super("BreachWatch.BreachWatchTokenRequest", [
      { no: 1, name: "breachWatchToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<BreachWatchTokenRequest>): BreachWatchTokenRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.breachWatchToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<BreachWatchTokenRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchTokenRequest,
  ): BreachWatchTokenRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes breachWatchToken */ 1:
          message.breachWatchToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchTokenRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes breachWatchToken = 1; */
    if (message.breachWatchToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.breachWatchToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchTokenRequest
 */
export const BreachWatchTokenRequest = new BreachWatchTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchTokenResponse$Type extends MessageType<BreachWatchTokenResponse> {
  constructor() {
    super("BreachWatch.BreachWatchTokenResponse", [
      { no: 1, name: "breachWatchToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "clientEncrypted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<BreachWatchTokenResponse>): BreachWatchTokenResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.breachWatchToken = new Uint8Array(0);
    message.clientEncrypted = false;
    if (value !== undefined) reflectionMergePartial<BreachWatchTokenResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchTokenResponse,
  ): BreachWatchTokenResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes breachWatchToken */ 1:
          message.breachWatchToken = reader.bytes();
          break;
        case /* bool clientEncrypted */ 2:
          message.clientEncrypted = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchTokenResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes breachWatchToken = 1; */
    if (message.breachWatchToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.breachWatchToken);
    /* bool clientEncrypted = 2; */
    if (message.clientEncrypted !== false)
      writer.tag(2, WireType.Varint).bool(message.clientEncrypted);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchTokenResponse
 */
export const BreachWatchTokenResponse = new BreachWatchTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnonymizedTokenResponse$Type extends MessageType<AnonymizedTokenResponse> {
  constructor() {
    super("BreachWatch.AnonymizedTokenResponse", [
      { no: 1, name: "domainToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "emailToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "passwordToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<AnonymizedTokenResponse>): AnonymizedTokenResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.domainToken = new Uint8Array(0);
    message.emailToken = new Uint8Array(0);
    message.passwordToken = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<AnonymizedTokenResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AnonymizedTokenResponse,
  ): AnonymizedTokenResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes domainToken */ 1:
          message.domainToken = reader.bytes();
          break;
        case /* bytes emailToken */ 2:
          message.emailToken = reader.bytes();
          break;
        case /* bytes passwordToken */ 3:
          message.passwordToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AnonymizedTokenResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes domainToken = 1; */
    if (message.domainToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.domainToken);
    /* bytes emailToken = 2; */
    if (message.emailToken.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.emailToken);
    /* bytes passwordToken = 3; */
    if (message.passwordToken.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.passwordToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.AnonymizedTokenResponse
 */
export const AnonymizedTokenResponse = new AnonymizedTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HashCheck$Type extends MessageType<HashCheck> {
  constructor() {
    super("BreachWatch.HashCheck", [
      { no: 1, name: "hash1", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "euid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<HashCheck>): HashCheck {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.hash1 = new Uint8Array(0);
    message.euid = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<HashCheck>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HashCheck,
  ): HashCheck {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash1 */ 1:
          message.hash1 = reader.bytes();
          break;
        case /* bytes euid */ 2:
          message.euid = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: HashCheck,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes hash1 = 1; */
    if (message.hash1.length) writer.tag(1, WireType.LengthDelimited).bytes(message.hash1);
    /* bytes euid = 2; */
    if (message.euid.length) writer.tag(2, WireType.LengthDelimited).bytes(message.euid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.HashCheck
 */
export const HashCheck = new HashCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchStatusRequest$Type extends MessageType<BreachWatchStatusRequest> {
  constructor() {
    super("BreachWatch.BreachWatchStatusRequest", [
      { no: 1, name: "anonymizedToken", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "hashCheck",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => HashCheck,
      },
      {
        no: 3,
        name: "removedEuid",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<BreachWatchStatusRequest>): BreachWatchStatusRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.anonymizedToken = new Uint8Array(0);
    message.hashCheck = [];
    message.removedEuid = [];
    if (value !== undefined) reflectionMergePartial<BreachWatchStatusRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchStatusRequest,
  ): BreachWatchStatusRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes anonymizedToken */ 1:
          message.anonymizedToken = reader.bytes();
          break;
        case /* repeated BreachWatch.HashCheck hashCheck */ 2:
          message.hashCheck.push(HashCheck.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated bytes removedEuid */ 3:
          message.removedEuid.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchStatusRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes anonymizedToken = 1; */
    if (message.anonymizedToken.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.anonymizedToken);
    /* repeated BreachWatch.HashCheck hashCheck = 2; */
    for (let i = 0; i < message.hashCheck.length; i++)
      HashCheck.internalBinaryWrite(
        message.hashCheck[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated bytes removedEuid = 3; */
    for (let i = 0; i < message.removedEuid.length; i++)
      writer.tag(3, WireType.LengthDelimited).bytes(message.removedEuid[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchStatusRequest
 */
export const BreachWatchStatusRequest = new BreachWatchStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HashStatus$Type extends MessageType<HashStatus> {
  constructor() {
    super("BreachWatch.HashStatus", [
      { no: 1, name: "hash1", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "euid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 3, name: "breachDetected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<HashStatus>): HashStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.hash1 = new Uint8Array(0);
    message.euid = new Uint8Array(0);
    message.breachDetected = false;
    if (value !== undefined) reflectionMergePartial<HashStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HashStatus,
  ): HashStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hash1 */ 1:
          message.hash1 = reader.bytes();
          break;
        case /* bytes euid */ 2:
          message.euid = reader.bytes();
          break;
        case /* bool breachDetected */ 3:
          message.breachDetected = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: HashStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes hash1 = 1; */
    if (message.hash1.length) writer.tag(1, WireType.LengthDelimited).bytes(message.hash1);
    /* bytes euid = 2; */
    if (message.euid.length) writer.tag(2, WireType.LengthDelimited).bytes(message.euid);
    /* bool breachDetected = 3; */
    if (message.breachDetected !== false)
      writer.tag(3, WireType.Varint).bool(message.breachDetected);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.HashStatus
 */
export const HashStatus = new HashStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachWatchStatusResponse$Type extends MessageType<BreachWatchStatusResponse> {
  constructor() {
    super("BreachWatch.BreachWatchStatusResponse", [
      {
        no: 2,
        name: "hashStatus",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => HashStatus,
      },
    ]);
  }
  create(value?: PartialMessage<BreachWatchStatusResponse>): BreachWatchStatusResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.hashStatus = [];
    if (value !== undefined)
      reflectionMergePartial<BreachWatchStatusResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachWatchStatusResponse,
  ): BreachWatchStatusResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated BreachWatch.HashStatus hashStatus */ 2:
          message.hashStatus.push(HashStatus.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachWatchStatusResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated BreachWatch.HashStatus hashStatus = 2; */
    for (let i = 0; i < message.hashStatus.length; i++)
      HashStatus.internalBinaryWrite(
        message.hashStatus[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachWatchStatusResponse
 */
export const BreachWatchStatusResponse = new BreachWatchStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterprisePublicKeyResponse$Type extends MessageType<EnterprisePublicKeyResponse> {
  constructor() {
    super("BreachWatch.EnterprisePublicKeyResponse", [
      { no: 1, name: "enterprisePublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      { no: 2, name: "enterpriseECCPublicKey", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<EnterprisePublicKeyResponse>): EnterprisePublicKeyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.enterprisePublicKey = new Uint8Array(0);
    message.enterpriseECCPublicKey = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<EnterprisePublicKeyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EnterprisePublicKeyResponse,
  ): EnterprisePublicKeyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes enterprisePublicKey */ 1:
          message.enterprisePublicKey = reader.bytes();
          break;
        case /* bytes enterpriseECCPublicKey */ 2:
          message.enterpriseECCPublicKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EnterprisePublicKeyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes enterprisePublicKey = 1; */
    if (message.enterprisePublicKey.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.enterprisePublicKey);
    /* bytes enterpriseECCPublicKey = 2; */
    if (message.enterpriseECCPublicKey.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.enterpriseECCPublicKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.EnterprisePublicKeyResponse
 */
export const EnterprisePublicKeyResponse = new EnterprisePublicKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreeScanRequest$Type extends MessageType<FreeScanRequest> {
  constructor() {
    super("BreachWatch.FreeScanRequest", [
      { no: 1, name: "hashedEmail", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<FreeScanRequest>): FreeScanRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.hashedEmail = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<FreeScanRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FreeScanRequest,
  ): FreeScanRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hashedEmail */ 1:
          message.hashedEmail = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FreeScanRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes hashedEmail = 1; */
    if (message.hashedEmail.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hashedEmail);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.FreeScanRequest
 */
export const FreeScanRequest = new FreeScanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreeScanResponse$Type extends MessageType<FreeScanResponse> {
  constructor() {
    super("BreachWatch.FreeScanResponse", [
      { no: 1, name: "emailBreaches", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "passwordBreaches", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<FreeScanResponse>): FreeScanResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.emailBreaches = 0;
    message.passwordBreaches = 0;
    if (value !== undefined) reflectionMergePartial<FreeScanResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FreeScanResponse,
  ): FreeScanResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 emailBreaches */ 1:
          message.emailBreaches = reader.int32();
          break;
        case /* int32 passwordBreaches */ 2:
          message.passwordBreaches = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FreeScanResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 emailBreaches = 1; */
    if (message.emailBreaches !== 0) writer.tag(1, WireType.Varint).int32(message.emailBreaches);
    /* int32 passwordBreaches = 2; */
    if (message.passwordBreaches !== 0)
      writer.tag(2, WireType.Varint).int32(message.passwordBreaches);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.FreeScanResponse
 */
export const FreeScanResponse = new FreeScanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaidUserRequest$Type extends MessageType<PaidUserRequest> {
  constructor() {
    super("BreachWatch.PaidUserRequest", [
      { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<PaidUserRequest>): PaidUserRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.email = "";
    if (value !== undefined) reflectionMergePartial<PaidUserRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PaidUserRequest,
  ): PaidUserRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.email = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PaidUserRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.email !== "") writer.tag(1, WireType.LengthDelimited).string(message.email);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.PaidUserRequest
 */
export const PaidUserRequest = new PaidUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaidUserResponse$Type extends MessageType<PaidUserResponse> {
  constructor() {
    super("BreachWatch.PaidUserResponse", [
      { no: 1, name: "paidUser", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<PaidUserResponse>): PaidUserResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.paidUser = false;
    if (value !== undefined) reflectionMergePartial<PaidUserResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PaidUserResponse,
  ): PaidUserResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool paidUser */ 1:
          message.paidUser = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PaidUserResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool paidUser = 1; */
    if (message.paidUser !== false) writer.tag(1, WireType.Varint).bool(message.paidUser);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.PaidUserResponse
 */
export const PaidUserResponse = new PaidUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DetailedScanRequest$Type extends MessageType<DetailedScanRequest> {
  constructor() {
    super("BreachWatch.DetailedScanRequest", [
      { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DetailedScanRequest>): DetailedScanRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.email = "";
    if (value !== undefined) reflectionMergePartial<DetailedScanRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DetailedScanRequest,
  ): DetailedScanRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.email = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DetailedScanRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.email !== "") writer.tag(1, WireType.LengthDelimited).string(message.email);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.DetailedScanRequest
 */
export const DetailedScanRequest = new DetailedScanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseOneTimeTokenRequest$Type extends MessageType<UseOneTimeTokenRequest> {
  constructor() {
    super("BreachWatch.UseOneTimeTokenRequest", [
      { no: 1, name: "token", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<UseOneTimeTokenRequest>): UseOneTimeTokenRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.token = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<UseOneTimeTokenRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UseOneTimeTokenRequest,
  ): UseOneTimeTokenRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes token */ 1:
          message.token = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UseOneTimeTokenRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes token = 1; */
    if (message.token.length) writer.tag(1, WireType.LengthDelimited).bytes(message.token);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.UseOneTimeTokenRequest
 */
export const UseOneTimeTokenRequest = new UseOneTimeTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BreachEvent$Type extends MessageType<BreachEvent> {
  constructor() {
    super("BreachWatch.BreachEvent", [
      { no: 1, name: "site", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "passwordInBreach", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BreachEvent>): BreachEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.site = "";
    message.email = "";
    message.passwordInBreach = false;
    message.date = "";
    message.description = "";
    if (value !== undefined) reflectionMergePartial<BreachEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BreachEvent,
  ): BreachEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string site */ 1:
          message.site = reader.string();
          break;
        case /* string email */ 2:
          message.email = reader.string();
          break;
        case /* bool passwordInBreach */ 3:
          message.passwordInBreach = reader.bool();
          break;
        case /* string date */ 4:
          message.date = reader.string();
          break;
        case /* string description */ 5:
          message.description = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BreachEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string site = 1; */
    if (message.site !== "") writer.tag(1, WireType.LengthDelimited).string(message.site);
    /* string email = 2; */
    if (message.email !== "") writer.tag(2, WireType.LengthDelimited).string(message.email);
    /* bool passwordInBreach = 3; */
    if (message.passwordInBreach !== false)
      writer.tag(3, WireType.Varint).bool(message.passwordInBreach);
    /* string date = 4; */
    if (message.date !== "") writer.tag(4, WireType.LengthDelimited).string(message.date);
    /* string description = 5; */
    if (message.description !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.description);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.BreachEvent
 */
export const BreachEvent = new BreachEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseOneTimeTokenResponse$Type extends MessageType<UseOneTimeTokenResponse> {
  constructor() {
    super("BreachWatch.UseOneTimeTokenResponse", [
      { no: 1, name: "emailBreaches", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "passwordBreaches", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: "breachEvents",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BreachEvent,
      },
      { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<UseOneTimeTokenResponse>): UseOneTimeTokenResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.emailBreaches = 0;
    message.passwordBreaches = 0;
    message.breachEvents = [];
    message.email = "";
    if (value !== undefined) reflectionMergePartial<UseOneTimeTokenResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UseOneTimeTokenResponse,
  ): UseOneTimeTokenResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 emailBreaches */ 1:
          message.emailBreaches = reader.int32();
          break;
        case /* int32 passwordBreaches */ 2:
          message.passwordBreaches = reader.int32();
          break;
        case /* repeated BreachWatch.BreachEvent breachEvents */ 3:
          message.breachEvents.push(
            BreachEvent.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string email */ 4:
          message.email = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UseOneTimeTokenResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 emailBreaches = 1; */
    if (message.emailBreaches !== 0) writer.tag(1, WireType.Varint).int32(message.emailBreaches);
    /* int32 passwordBreaches = 2; */
    if (message.passwordBreaches !== 0)
      writer.tag(2, WireType.Varint).int32(message.passwordBreaches);
    /* repeated BreachWatch.BreachEvent breachEvents = 3; */
    for (let i = 0; i < message.breachEvents.length; i++)
      BreachEvent.internalBinaryWrite(
        message.breachEvents[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string email = 4; */
    if (message.email !== "") writer.tag(4, WireType.LengthDelimited).string(message.email);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.UseOneTimeTokenResponse
 */
export const UseOneTimeTokenResponse = new UseOneTimeTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneTimeUseToken$Type extends MessageType<OneTimeUseToken> {
  constructor() {
    super("BreachWatch.OneTimeUseToken", [
      { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "pad", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<OneTimeUseToken>): OneTimeUseToken {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.email = "";
    message.pad = "";
    if (value !== undefined) reflectionMergePartial<OneTimeUseToken>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OneTimeUseToken,
  ): OneTimeUseToken {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.email = reader.string();
          break;
        case /* string pad */ 2:
          message.pad = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: OneTimeUseToken,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.email !== "") writer.tag(1, WireType.LengthDelimited).string(message.email);
    /* string pad = 2; */
    if (message.pad !== "") writer.tag(2, WireType.LengthDelimited).string(message.pad);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.OneTimeUseToken
 */
export const OneTimeUseToken = new OneTimeUseToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreePasswordScanRequest$Type extends MessageType<FreePasswordScanRequest> {
  constructor() {
    super("BreachWatch.FreePasswordScanRequest", [
      { no: 1, name: "hashedPassword", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<FreePasswordScanRequest>): FreePasswordScanRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.hashedPassword = new Uint8Array(0);
    if (value !== undefined) reflectionMergePartial<FreePasswordScanRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FreePasswordScanRequest,
  ): FreePasswordScanRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes hashedPassword */ 1:
          message.hashedPassword = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FreePasswordScanRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes hashedPassword = 1; */
    if (message.hashedPassword.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.hashedPassword);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.FreePasswordScanRequest
 */
export const FreePasswordScanRequest = new FreePasswordScanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreePasswordScanResponse$Type extends MessageType<FreePasswordScanResponse> {
  constructor() {
    super("BreachWatch.FreePasswordScanResponse", [
      {
        no: 1,
        name: "passwordBreaches",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<FreePasswordScanResponse>): FreePasswordScanResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.passwordBreaches = BigInt(0);
    if (value !== undefined) reflectionMergePartial<FreePasswordScanResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FreePasswordScanResponse,
  ): FreePasswordScanResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 passwordBreaches */ 1:
          message.passwordBreaches = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FreePasswordScanResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 passwordBreaches = 1; */
    if (message.passwordBreaches !== BigInt(0))
      writer.tag(1, WireType.Varint).int64(message.passwordBreaches);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BreachWatch.FreePasswordScanResponse
 */
export const FreePasswordScanResponse = new FreePasswordScanResponse$Type();
